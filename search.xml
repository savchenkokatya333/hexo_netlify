<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>【medium】3Sum</title>
      <link href="/LeetCode-015-3Sum.html"/>
      <url>/LeetCode-015-3Sum.html</url>
      
        <content type="html"><![CDATA[<p>Given an array <code>nums</code> of <em>n</em> integers, are there elements <em>a</em>, <em>b</em>, <em>c</em> in <code>nums</code> such that <em>a</em> + <em>b</em> + <em>c</em> = 0? Find all unique triplets in the array which gives the sum of zero.</p><p><strong>Note:</strong></p><p>The solution set must not contain duplicate triplets.</p><p><strong>Example:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Given array nums = [-1, 0, 1, 2, -1, -4],</span><br><span class="line"></span><br><span class="line">A solution set is:</span><br><span class="line">[</span><br><span class="line">  [-1, 0, 1],</span><br><span class="line">  [-1, -1, 2]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><a id="more"></a><hr><h3 id="思路分析："><a href="#思路分析：" class="headerlink" title="思路分析："></a>思路分析：</h3><ul><li>前面做过类似的 2 个数相加，<a href="https://smileyx.top/leetcode-002-add%20two%20numbers">LeetCode-001-Two Sum</a>，这里要更复杂，三个数相加，那么可以先拿出一个数，剩下的两个数利用前面的方法来找，见代码块 1.1</li><li>也是和前面一样，需要先取出一个元素，然后去寻找剩下的 2 个数相加等于<code>target</code>，因为是三数相加等于 0 ，那么<code>target</code>应为前面取出的数的相反数。再操作之前，应该将给的<code>nums</code>排个序，然后利用前后指针的思想，初始化时前指针指向当前取出元素的下一个，后指针指向末尾，因为现在列表是有序的，那么当前后指针元素相加大于<code>target</code>时，很明显应该将后指针向前移动一位（意味着元素变小），小于<code>target</code>时同理将前指针向后移动一位，具体见代码 2.1</li></ul><hr><h3 id="代码实现："><a href="#代码实现：" class="headerlink" title="代码实现："></a>代码实现：</h3><blockquote><p>1.1</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">threeSum</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        temp_res = []</span><br><span class="line">        <span class="keyword">for</span> index <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">            nums_copy = nums[:]</span><br><span class="line">            nums_copy.pop(index)</span><br><span class="line">            sub_list =  self.twoSum(nums_copy, -nums[index])</span><br><span class="line">            <span class="keyword">if</span> sub_list:</span><br><span class="line">                <span class="keyword">for</span> sub <span class="keyword">in</span> sub_list:</span><br><span class="line">                    sub.insert(<span class="number">0</span>, nums[index])</span><br><span class="line">                    sub.sort()</span><br><span class="line">                    temp_res.append(sub)</span><br><span class="line">        temp_res = list(set(str(item) <span class="keyword">for</span> item <span class="keyword">in</span> temp_res))</span><br><span class="line">        res = [eval(item) <span class="keyword">for</span> item <span class="keyword">in</span> temp_res]</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">twoSum</span><span class="params">(self, list, target)</span>:</span></span><br><span class="line">        dict = &#123;&#125;</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> index, value <span class="keyword">in</span> enumerate(list):</span><br><span class="line">            <span class="keyword">if</span> target-value <span class="keyword">in</span> dict.values():</span><br><span class="line">                res.append([target-value, value])</span><br><span class="line">            dict[index] = value</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p>可以看到这段代码的时间复杂度好像是$O(n^{2})$，提交后果然<code>TLE</code>，但既然选择贴上来肯定就是有价值的，可以看到在 13 行做了一个去重的操作，但这个去重卡了好久，开始想的是直接用<code>set</code>来去重，代码就是这样的：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">temp_res = set(temp_res)</span><br></pre></td></tr></table></figure><p>但报错<code>TypeError: unhashable type: &#39;list&#39;</code>，特意去查了什么意思。原来<code>set</code>对传入的参数有要求：<strong>是可迭代类型，迭代的每个元素都是可哈希的。</strong>原来我一直以为传入一个可迭代的对象就好了，受到<code>set([1, 2, 3])</code>的影响，而这里<code>temp_res</code>的格式是<code>[[], [],..]</code>（列表的嵌套），满足了第一个条件：是可迭代对象，但是迭代出来的单个元素还是<code>list</code>，而<code>list</code>是不可哈希的，至此才弄清了出错的原因。<strong>解决方案：将嵌套在里面的<code>list</code>转成字符串（字符串是可哈希的），然后再利用<code>set</code>去重，最后再用<code>eval</code>函数将字符串恢复成列表。</strong></p><p>[注]：<code>list、set、dict</code>是不可哈希的，<code>int、float、str、tuple</code>是可哈希的</p><blockquote><p>2.1</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">threeSum</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        nums.sort()</span><br><span class="line">        picked = set()</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> index <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">            <span class="keyword">if</span> nums[index] &gt; <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">if</span> nums[index] <span class="keyword">in</span> picked:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            left_cursor = index + <span class="number">1</span></span><br><span class="line">            right_cursor = len(nums) - <span class="number">1</span></span><br><span class="line">            target = -nums[index]</span><br><span class="line">            <span class="keyword">while</span> left_cursor &lt; right_cursor:</span><br><span class="line">                <span class="keyword">if</span> nums[left_cursor] + nums[right_cursor] &lt; target:</span><br><span class="line">                    left_cursor += <span class="number">1</span></span><br><span class="line">                <span class="keyword">elif</span> nums[left_cursor] + nums[right_cursor] &gt; target:</span><br><span class="line">                    right_cursor -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    res.append([nums[index], nums[left_cursor], nums[right_cursor]])</span><br><span class="line">                    left_cursor += <span class="number">1</span></span><br><span class="line">                    right_cursor -= <span class="number">1</span></span><br><span class="line">            picked.add(nums[index])</span><br><span class="line">        res = list(set(str(item) <span class="keyword">for</span> item <span class="keyword">in</span> res))</span><br><span class="line">        res = [eval(item) <span class="keyword">for</span> item <span class="keyword">in</span> res]</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p>可以看到我做了两个剪枝优化：</p><p>①第一步取元素的时候并没有遍历完<code>nums</code>，因为要求和等于 0 ，要么三个数都为 0 ，要么就是有正有负，而这时<code>nums</code>是有序的，当我取第一个值都大于 0 时，后面就不用找了，不可能和为 0 了，直接<code>break</code>就好。</p><p>②记录前面已经取出的值，如果如果再碰到这个值可以直接跳过，减少一些重复项。</p><p>开始我以为这里不需要单独的去重了，因为循环中已经避免了。但提交后碰到这么个栗子：<code>nums = [[-2,0,0,2,2]]</code>，还是会出现重复值，还是乖乖的加上了 24、25 两行代码。</p><hr><h3 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h3><ul><li><a href="https://leetcode.com/problems/3sum/" target="_blank" rel="noopener">题目链接</a></li><li><a href="https://segmentfault.com/q/1010000000394830" target="_blank" rel="noopener">segmentfault回答</a></li><li><a href="http://www.chenxm.cc/article/541.html" target="_blank" rel="noopener">python 字典列表/列表套字典 去重重复的字典数据</a></li><li><a href="https://blog.csdn.net/lanchunhui/article/details/50955238" target="_blank" rel="noopener">Python debug——TypeError: unhashable type（list/set/dict）</a></li><li><a href="https://blog.csdn.net/zhanh1218/article/details/37562167" target="_blank" rel="noopener">Python:eval的妙用和滥用</a></li><li><a href="http://www.cnblogs.com/grandyang/p/4481576.html" target="_blank" rel="noopener">[LeetCode] 3Sum 三数之和</a></li><li><a href="https://segmentfault.com/a/1190000003740669" target="_blank" rel="noopener">[Leetcode] 3Sum 4Sum 3Sum Closet 多数和</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> LeetCode日记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>记一次用Flask搭建简单博客</title>
      <link href="/%E8%AE%B0%E4%B8%80%E6%AC%A1%E7%94%A8Flask%E6%90%AD%E5%BB%BA%E7%AE%80%E5%8D%95%E5%8D%9A%E5%AE%A2.html"/>
      <url>/%E8%AE%B0%E4%B8%80%E6%AC%A1%E7%94%A8Flask%E6%90%AD%E5%BB%BA%E7%AE%80%E5%8D%95%E5%8D%9A%E5%AE%A2.html</url>
      
        <content type="html"><![CDATA[<p><img src="http://m-markdown-image.oss-cn-beijing.aliyuncs.com/2018-12-18-63858f3716f4ddf6047e8921d2d86418.jpg" alt=""></p><a id="more"></a><p>本篇基于这个<a href="https://blog.miguelgrinberg.com/post/the-flask-mega-tutorial-part-i-hello-world" target="_blank" rel="noopener">教程</a>，属于照葫芦画瓢，但我相信会得到一些东西！</p><h3 id="Day-1"><a href="#Day-1" class="headerlink" title="Day 1"></a>Day 1</h3><p>从学到第 3 节才有写本篇的想法，那就从这里开始吧，前 3 节的内容还比较容易，首先就是安装，我是用 <code>conda</code> 创建了另一个<code>python</code>的虚拟环境<code>flaskBlog</code>，在这个环境中安装<code>flask</code>，也是作者推荐的做法。然后创建项目目录，并开启<code>flask</code>服务，于是有了标志的<code>Hello, World</code>页面。</p><p>第 2 节讲的是模板的应用，首先创建基础的模板页面，即所有页面都应该有的元素丢在这里面，有点父类的意思。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    &#123;% if title %&#125;</span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>&#123;&#123; title &#125;&#125; blog<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    &#123;% else %&#125;</span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span> Flask blog<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    &#123;% endif %&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span>&gt;</span>Flask Blog: <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"/index"</span>&gt;</span>Home<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">hr</span>&gt;</span></span><br><span class="line">        &#123;% block content %&#125;&#123;% endblock %&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>重要的就是这个<code>block</code>语句，<code>base.html</code>只写了公共的元素，后面的页面直接继承该模板，然后在对应的<code>block</code>中添加自己特有的元素就好，例如这里的<code>index.html</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;% extends "base.html" %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% block content %&#125;</span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hi, &#123;&#123; user.userName &#125;&#125;!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    &#123;% for post in posts %&#125;</span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; post.author.userName &#125;&#125; says: <span class="tag">&lt;<span class="name">b</span>&gt;</span>&#123;&#123; post.body &#125;&#125;<span class="tag">&lt;/<span class="name">b</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    &#123;% endfor %&#125;</span><br><span class="line">&#123;% endblock %&#125;</span><br></pre></td></tr></table></figure><p>可以看到顶部直接<code>extends</code>，在对应的<code>block</code>中写上欢迎信息，注意上面的<code>block</code>的名字是<code>content</code>，则下面继承时也应该是<code>content</code>，这样如果有多个<code>block</code>，则可以根据名字来对应。</p><p>第 3 节讲到了表单，这里并不是用<code>html</code>原生的表单，而是用的第三方库<code>Flask-WTF</code>，这个库可以用<code>python</code>的<code>class</code>来表示表单，面向对象嘛，具体做法就是：</p><p>①创建<code>forms.py</code>，以后的表单都写在该文件中</p><p>②创建<code>LoginForm class</code>，里面的变量就是登录表单的元素，例如这里我先写了账户、密码、记住我、登录四个元素</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> flask_wtf <span class="keyword">import</span> FlaskForm</span><br><span class="line"><span class="keyword">from</span> wtforms <span class="keyword">import</span> StringField, PasswordField, BooleanField, SubmitField</span><br><span class="line"><span class="keyword">from</span> wtforms.validators <span class="keyword">import</span> DataRequired</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LoginForm</span><span class="params">(FlaskForm)</span>:</span></span><br><span class="line">    userName = StringField(<span class="string">'用户名:'</span>, validators=[DataRequired()])</span><br><span class="line">    userPwd = PasswordField(<span class="string">'密码:'</span>, validators=[DataRequired()])</span><br><span class="line">    rememberMe = BooleanField(<span class="string">'记住我'</span>)</span><br><span class="line">    submit = SubmitField(<span class="string">'登录'</span>)</span><br></pre></td></tr></table></figure><p>③有了逻辑上的登录表单，接下来就是编写登录页面<code>login.html</code>，同样需继承自<code>base.html</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&#123;% extends 'base.html' %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% block content %&#125;</span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>登录<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">""</span> <span class="attr">method</span>=<span class="string">"post"</span> <span class="attr">novalidate</span>&gt;</span></span><br><span class="line">        &#123;&#123; form.hidden_tag() &#125;&#125;</span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">            &#123;&#123; form.userName.label &#125;&#125;<span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">            &#123;&#123; form.userName(size=20) &#125;&#125;<span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">            &#123;% for error in form.userName.errors %&#125;</span><br><span class="line">            <span class="tag">&lt;<span class="name">span</span> <span class="attr">style</span>=<span class="string">"color: red;"</span>&gt;</span>[&#123;&#123; error &#125;&#125;]<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">            &#123;% endfor %&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">            &#123;&#123; form.userPwd.label &#125;&#125;<span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">            &#123;&#123; form.userPwd(size=20) &#125;&#125;<span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">            &#123;% for error in form.userPwd.errors %&#125;</span><br><span class="line">            <span class="tag">&lt;<span class="name">span</span> <span class="attr">style</span>=<span class="string">"color: red"</span>&gt;</span>[&#123;&#123; error &#125;&#125;]<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">            &#123;% endfor %&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">            &#123;&#123; form.rememberMe() &#125;&#125;</span><br><span class="line">            &#123;&#123; form.rememberMe.label &#125;&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; form.submit() &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line">&#123;% endblock %&#125;</span><br></pre></td></tr></table></figure><p>④有了上面两部的基础，剩下的就是配置路由了，当路由为<code>/login</code>时，应当渲染登录页面，并且在点击登录时可以接收到前端提交的数据，但暂时不做处理，直接显示在页面上。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@app.route('/login', methods=['GET','POST'])</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">login</span><span class="params">()</span>:</span></span><br><span class="line">    form = LoginForm()</span><br><span class="line">    <span class="keyword">if</span> form.validate_on_submit():</span><br><span class="line">        flash(<span class="string">'userName is:&#123;&#125;, userPwd is:&#123;&#125;'</span>.</span><br><span class="line">              format(form.userName.data, form.userPwd.data))</span><br><span class="line">        <span class="keyword">return</span> redirect(url_for(<span class="string">'index'</span>))</span><br><span class="line">    <span class="keyword">return</span> render_template(<span class="string">'login.html'</span>, title=<span class="string">'登录'</span>, form=form)</span><br></pre></td></tr></table></figure><p>注意这里的路由函数中多了一个<code>methods</code>参数，并且我把<code>GET</code>和<code>POST</code>都填上去了，目的是为了该路由方法可以处理这两种请求。这里用<code>flash</code>想将数据显示到页面上，那么页面上也要有相应的坑啊，于是需要修改<code>base.html</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"># ...</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        Flask Blog:</span><br><span class="line">        <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"&#123;&#123; url_for('index') &#125;&#125;"</span>&gt;</span>主页<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"&#123;&#123; url_for('login') &#125;&#125;"</span>&gt;</span>登录<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">hr</span>&gt;</span></span><br><span class="line">    &#123;% with messages = get_flashed_messages() %&#125;</span><br><span class="line">        &#123;% if messages %&#125;</span><br><span class="line">            <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">                &#123;% for message in messages %&#125;</span><br><span class="line">                    <span class="tag">&lt;<span class="name">li</span>&gt;</span>&#123;&#123; message &#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">                &#123;% endfor %&#125;</span><br><span class="line">            <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">        &#123;% endif %&#125;</span><br><span class="line">    &#123;% endwith %&#125;</span><br><span class="line">    &#123;% block content %&#125;</span><br><span class="line">    &#123;% endblock %&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><hr><h3 id="Day-2"><a href="#Day-2" class="headerlink" title="Day 2"></a>Day 2</h3><p>今天做了第 4 节的内容，创建数据库，采用的轻量级的<code>SQLite</code>，并使用<code>Flask-SQLAlchemy</code>插件使用面向对象的概念来操作数据库，并添加<code>Flask-Migrate</code>来应对今后有可能的数据迁移，暂时可能只是安装和配置完而已，并没有真正的用到。</p><p><code>ORM</code>还真是第一次了解到，学了几年的面向对象编程，竟然没想到数据库也有面向对象的方式，原来一谈到操作数据库首先冒出来的就是<code>select * from XX</code>，而<code>ORM（Object-relational mapping）</code>可以让我们以操作对象的方式操作数据库，具体介绍可以看：<a href="https://segmentfault.com/a/1190000011642533" target="_blank" rel="noopener">什么是 ORM ？（segmentfault）</a>、<a href="https://stackoverflow.com/questions/1279613/what-is-an-orm-and-where-can-i-learn-more-about-it" target="_blank" rel="noopener">stackoverflow 回答</a></p><p>现在就应该设计数据库的表了，暂时就只需要 2 张表，一张<code>user</code>表和一张<code>post</code>表，表结构如下：</p><p><img src="http://m-markdown-image.oss-cn-beijing.aliyuncs.com/2018-12-19-%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-19%2022.09.47.png" alt=""></p><p><code>post</code>表中用一个外键<code>userId</code>把文章和用户联系起来，一个用户可以写多篇文章，所以他们的关系明显是<code>1:n</code>，既然<code>ORM</code>是面向对象的方式，那么即<strong>意味着一张表就对应着一个类，表中的一条记录就是这个类的一个实体</strong>，所以接下来该创建<code>user</code>类和<code>post</code>类了：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> app <span class="keyword">import</span> db</span><br><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span><span class="params">(db.Model)</span>:</span></span><br><span class="line">    id = db.Column(db.Integer, primary_key=<span class="keyword">True</span>)</span><br><span class="line">    userName = db.Column(db.String(<span class="number">64</span>), index=<span class="keyword">True</span>, unique=<span class="keyword">True</span>)</span><br><span class="line">    userPwd = db.Column(db.String(<span class="number">128</span>))</span><br><span class="line">    phone = db.Column(db.Integer, index=<span class="keyword">True</span>, unique=<span class="keyword">True</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">'&lt;User &#123;&#125;&gt;'</span>.format(self.userName)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Post</span><span class="params">(db.Model)</span>:</span></span><br><span class="line">    id = db.Column(db.Integer, primary_key=<span class="keyword">True</span>)</span><br><span class="line">    body = db.Column(db.String(<span class="number">140</span>))</span><br><span class="line">    timestamp = db.Column(db.DateTime, index=<span class="keyword">True</span>, default=datetime.utcnow)</span><br><span class="line">    userId = db.Column(db.Integer, db.ForeignKey(<span class="string">'user.id'</span>))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">'&lt;Post &#123;&#125;&gt;'</span>.format(self.body)</span><br></pre></td></tr></table></figure><p>这里要说两点：</p><p>①建<code>user</code>表的时候给<code>userName、phone</code>加上了索引，那么索引到底是什么意思呢？<strong>索引就是一种数据结构</strong>，给合适的属性加上索引后，查询会变快。网上有很多的解释文章，这里贴两篇不错的：<a href="https://zhuanlan.zhihu.com/p/23624390" target="_blank" rel="noopener">深入浅出数据库索引原理</a>、<a href="https://blog.csdn.net/weiliangliang111/article/details/51333169" target="_blank" rel="noopener">数据库索引到底是什么，是怎样工作的？</a>、<a href="https://blog.csdn.net/suifeng3051/article/details/52669644" target="_blank" rel="noopener">数据库索引原理及优化</a></p><p>②这里重构了<code>__repr__</code>方法，它的作用就是在<strong>查看其类的实体时更加友好</strong>，可以自定义其显示的内容，而不是默认的显示实体在内存中的地址，具体参看：<a href="https://blog.csdn.net/luckytanggu/article/details/53649156" target="_blank" rel="noopener">Python中<strong>repr</strong>和<strong>str</strong>区别</a></p><hr><h3 id="Day-3"><a href="#Day-3" class="headerlink" title="Day 3"></a>Day 3</h3><p>第 5 节的内容是用户登录，但在处理登录之前先要解决前一节的遗留问题，那就是密码的存储，密码肯定是不能明文存在数据库中的，是需要加密的，这里是调用<code>werkzeug</code>库来进行哈希加密，但它的验证方式有点不同，正常来说验证时的操作是：将用户输入的密码进行哈希加密，然后与数据库存的进行比对。但这个库却提供了一个验证函数<code>check_password_hash(str_hash, str)</code>，因为其加密函数<code>generate_password_hash(str)</code>对同一个字符串两次加密的结果是不同的，所以笔记用它给的验证函数来验证。故现在就需要对前面创建的<code>User Model</code>进行更改：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span><span class="params">(db.Model)</span>:</span></span><br><span class="line">    <span class="comment">#...</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">set_userPwd</span><span class="params">(self, password)</span>:</span></span><br><span class="line">        self.userPwd = generate_password_hash(password)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">check_userPwd</span><span class="params">(self, password)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> check_password_hash(self.userPwd, password)</span><br></pre></td></tr></table></figure><p>连登录都有插件可以用，涨见识了，这里就是用的<code>flask-login</code>插件来完成后面的登录/登出，注册功能。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@app.route('/login', methods=['GET','POST'])</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">login</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">if</span> current_user.is_authenticated:</span><br><span class="line">        <span class="keyword">return</span> redirect(url_for(<span class="string">'index'</span>))</span><br><span class="line">    form = LoginForm()</span><br><span class="line">    <span class="keyword">if</span> form.validate_on_submit():</span><br><span class="line">        user = User.query.filter_by(userName = form.userName.data).first()</span><br><span class="line">        <span class="keyword">if</span> user <span class="keyword">is</span> <span class="keyword">None</span> <span class="keyword">or</span> <span class="keyword">not</span> user.check_userPwd(form.userPwd.data):</span><br><span class="line">            flash(<span class="string">'Invalid userName or userPwd'</span>)</span><br><span class="line">            <span class="keyword">return</span> redirect(url_for(<span class="string">'login'</span>))</span><br><span class="line">        login_user(user, remember=form.rememberMe.data)</span><br><span class="line">        next_page = request.args.get(<span class="string">'next'</span>)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> next_page <span class="keyword">or</span> url_parse(next_page).netloc != <span class="string">''</span>:</span><br><span class="line">            next_page = url_for(<span class="string">'index'</span>)</span><br><span class="line">        <span class="keyword">return</span> redirect(next_page)</span><br><span class="line">    <span class="keyword">return</span> render_template(<span class="string">'login.html'</span>, title=<span class="string">'登录'</span>, form=form)</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route('/logout')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">logout</span><span class="params">()</span>:</span></span><br><span class="line">    logout_user()</span><br><span class="line">    <span class="keyword">return</span> redirect(url_for(<span class="string">'index'</span>))</span><br></pre></td></tr></table></figure><p>这里贴出了处理登录/登出的函数（上面需要<code>import</code>相应的函数，这里没贴），对于登录，可以看到这里首先判断当前用户<code>current_user</code>的状态，如果已经登录，则无需再登录，否则进行后续的查数据库验证。它这个库帮你做好了<code>session</code>的工作。</p><p>后面的注册功能实现和前面流程差不多：</p><p>①写注册页面需要的表单</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RegistrationForm</span><span class="params">(FlaskForm)</span>:</span></span><br><span class="line">    userName = StringField(<span class="string">'用户名'</span>, validators=[DataRequired()])</span><br><span class="line">    phone = StringField(<span class="string">'电话'</span>, validators=[DataRequired()])</span><br><span class="line">    userPwd = PasswordField(<span class="string">'密码'</span>,validators=[DataRequired()])</span><br><span class="line">    userPwd2 = PasswordField(<span class="string">'重复密码'</span>, validators=[DataRequired(), EqualTo(<span class="string">'userPwd'</span>)])</span><br><span class="line">    submit = SubmitField(<span class="string">'注册'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">validate_userName</span><span class="params">(self, userName)</span>:</span></span><br><span class="line">        user = User.query.filter_by(userName = userName.data).first()</span><br><span class="line">        <span class="keyword">if</span> user <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</span><br><span class="line">            <span class="keyword">raise</span> ValidationError(<span class="string">'用户名已存在'</span>)</span><br></pre></td></tr></table></figure><p>②写注册的页面<code>register.html</code></p><p>③配置注册路由</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@app.route('/register', methods=['GET', 'POST'])</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">register</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">if</span> current_user.is_authenticated:</span><br><span class="line">        <span class="keyword">return</span> redirect(url_for(<span class="string">'index'</span>))</span><br><span class="line">    form = RegistrationForm()</span><br><span class="line">    <span class="keyword">if</span> form.validate_on_submit():</span><br><span class="line">        user = User(userName = form.userName.data, phone=form.phone.data)</span><br><span class="line">        user.set_userPwd(form.userPwd.data)</span><br><span class="line">        db.session.add(user)</span><br><span class="line">        db.session.commit()</span><br><span class="line">        flash(<span class="string">'注册成功'</span>)</span><br><span class="line">        <span class="keyword">return</span> redirect(url_for(<span class="string">'login'</span>))</span><br><span class="line">    <span class="keyword">return</span> render_template(<span class="string">'register.html'</span>, title = <span class="string">'注册'</span>,form = form)</span><br></pre></td></tr></table></figure><p>推荐阅读：</p><ul><li><a href="https://mp.weixin.qq.com/s/0dOaIbXTAwSwh8lSj7Ee3w" target="_blank" rel="noopener">一次忘记密码引发的算法思考</a></li><li><a href="https://www.infoq.cn/article/how-to-encrypt-the-user-password-correctly" target="_blank" rel="noopener">如何正确对用户密码进行加密？</a></li></ul><hr><h3 id="Day-4"><a href="#Day-4" class="headerlink" title="Day 4:"></a>Day 4:</h3>]]></content>
      
      
      <categories>
          
          <category> 练级之路 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Flask </tag>
            
            <tag> SQLite </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>【medium】Integer to Roman</title>
      <link href="/LeetCode-012-Integer%20to%20Roman.html"/>
      <url>/LeetCode-012-Integer%20to%20Roman.html</url>
      
        <content type="html"><![CDATA[<p>Roman numerals are represented by seven different symbols: <code>I</code>, <code>V</code>, <code>X</code>, <code>L</code>, <code>C</code>, <code>D</code> and <code>M</code>.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Symbol       Value</span><br><span class="line">I             1</span><br><span class="line">V             5</span><br><span class="line">X             10</span><br><span class="line">L             50</span><br><span class="line">C             100</span><br><span class="line">D             500</span><br><span class="line">M             1000</span><br></pre></td></tr></table></figure><a id="more"></a><p>For example, two is written as <code>II</code> in Roman numeral, just two one’s added together. Twelve is written as, <code>XII</code>, which is simply <code>X</code> + <code>II</code>. The number twenty seven is written as <code>XXVII</code>, which is <code>XX</code> + <code>V</code> + <code>II</code>.</p><p>Roman numerals are usually written largest to smallest from left to right. However, the numeral for four is not <code>IIII</code>. Instead, the number four is written as <code>IV</code>. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as <code>IX</code>. There are six instances where subtraction is used:</p><ul><li><code>I</code> can be placed before <code>V</code> (5) and <code>X</code> (10) to make 4 and 9. </li><li><code>X</code> can be placed before <code>L</code> (50) and <code>C</code> (100) to make 40 and 90. </li><li><code>C</code> can be placed before <code>D</code> (500) and <code>M</code> (1000) to make 400 and 900.</li></ul><p>Given an integer, convert it to a roman numeral. Input is guaranteed to be within the range from 1 to 3999.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: 3</span><br><span class="line">Output: &quot;III&quot;</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: 4</span><br><span class="line">Output: &quot;IV&quot;</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: 9</span><br><span class="line">Output: &quot;IX&quot;</span><br></pre></td></tr></table></figure><p><strong>Example 4:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: 58</span><br><span class="line">Output: &quot;LVIII&quot;</span><br><span class="line">Explanation: L = 50, V = 5, III = 3.</span><br></pre></td></tr></table></figure><p><strong>Example 5:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: 1994</span><br><span class="line">Output: &quot;MCMXCIV&quot;</span><br><span class="line">Explanation: M = 1000, CM = 900, XC = 90 and IV = 4.</span><br></pre></td></tr></table></figure><hr><h3 id="思路分析："><a href="#思路分析：" class="headerlink" title="思路分析："></a>思路分析：</h3><ul><li>可以发现罗马数字是将整数的各个位，即个位、十位、百位等分别表示出来并连在一起，那么可以就根据这个规律来操作，现将输入数字的每个位都提取出来，然后用罗马字符表示，最后组合起来，见代码块 1.1</li><li>贪心法，列出非叠加的所有组合，然后每次通过查表来找出当前最大的数，将其对应的罗马字符添加到结果中，减去后再继续查表，重复上述操作。其实最好理解贪心法的例子就是换零钱，例如有 36 块，一般人的换法一定是先拿一张 20 的，还剩 16 ，再拿一张 10 的，还剩 6 ，再拿一张 5 的，还剩 1 ，则最后再拿一张 1 的，所以最终的零钱就是：20+10+5+1。见代码块 2.1</li></ul><hr><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现:"></a>代码实现:</h3><blockquote><p>1.1</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">intToRoman</span><span class="params">(self, num)</span>:</span></span><br><span class="line">        symbolList = [<span class="string">'M'</span>, <span class="string">'D'</span>, <span class="string">'C'</span>, <span class="string">'L'</span>, <span class="string">'X'</span>, <span class="string">'V'</span>, <span class="string">'I'</span>]</span><br><span class="line">        valueList = [<span class="number">1000</span>, <span class="number">500</span>, <span class="number">100</span>, <span class="number">50</span>, <span class="number">10</span>, <span class="number">5</span>, <span class="number">1</span>]</span><br><span class="line">        res = <span class="string">''</span></span><br><span class="line">        <span class="keyword">for</span> index <span class="keyword">in</span> range(<span class="number">0</span>, len(valueList), <span class="number">2</span>):</span><br><span class="line">            x = num // valueList[index]</span><br><span class="line">            <span class="keyword">if</span> x &lt; <span class="number">4</span>:</span><br><span class="line">               <span class="keyword">for</span> i <span class="keyword">in</span> range(x):</span><br><span class="line">                   res += symbolList[index]</span><br><span class="line">            <span class="keyword">elif</span> x == <span class="number">4</span>:</span><br><span class="line">                res += symbolList[index]+symbolList[index<span class="number">-1</span>]</span><br><span class="line">            <span class="keyword">elif</span> x &lt; <span class="number">9</span>:</span><br><span class="line">                res += symbolList[index<span class="number">-1</span>]</span><br><span class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> range(x<span class="number">-5</span>):</span><br><span class="line">                    res += symbolList[index]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                res += symbolList[index]+ symbolList[index<span class="number">-2</span>]</span><br><span class="line">            num %= valueList[index]</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p>可以看到我将每个位上的数字分了 4 种情况：</p><p>①小于 4 时，则是简单的叠加，例如 3 就是三个<code>I</code>叠加， 30 就是三个<code>X</code>叠加， 300 就是三个<code>C</code>叠加，以此类推。</p><p>②等于 4 时，则是相邻两位相加，且小的在前，大的在后，例如 4 就是 1 和 5 的相加<code>IV</code>, 40 就是 10 和 50 的相加<code>XL</code>，那 4000 呢？照理说应该是 1000 和 5000 的相加，但题目这里并没有给 5000对应的罗马数字，而且题目说了输入整数范围是 1-3999。</p><p>③大于 4 且小于 9，则是综合了①和②，先写上当前的罗马数字，再看剩下的需要叠加几次，例如 8 就是先写 5 ，剩下的 3 就还要 3 个 1 来叠加 3 次，即<code>V</code>+<code>I</code>+<code>I</code>+<code>I</code>，以此类推。</p><p>④等于 9 时，其实和②一样，只不过不是相邻两位相加了，而是中间需要隔一个，例如 9 是 1 和 10 的相加<code>IX</code>，90 就是 10 和 100 的相加<code>XC</code></p><p>其实我觉得这段代码最精髓的地方在于开始两个列表的设置，非常方便后面的操作，而不是像我原来在<a href="https://smileyx.top/leetcode-013-roman%20to%20integer">【easy】Roman to Integer</a>中的写成字典的形式。</p><blockquote><p>2.1 贪心法</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">intToRoman</span><span class="params">(self, num)</span>:</span></span><br><span class="line">        symbolList = [<span class="string">'M'</span>, <span class="string">'CM'</span>, <span class="string">'D'</span>, <span class="string">'CD'</span>, <span class="string">'C'</span>, <span class="string">'XC'</span>, <span class="string">'L'</span>, <span class="string">'XL'</span>, <span class="string">'X'</span>, <span class="string">'IX'</span>, <span class="string">'V'</span>, <span class="string">'IV'</span>, <span class="string">'I'</span>]</span><br><span class="line">        valueList = [<span class="number">1000</span>, <span class="number">900</span>, <span class="number">500</span>, <span class="number">400</span>, <span class="number">100</span>, <span class="number">90</span>, <span class="number">50</span>, <span class="number">40</span>, <span class="number">10</span>, <span class="number">9</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">1</span>]</span><br><span class="line">        res = <span class="string">''</span></span><br><span class="line">        <span class="keyword">for</span> index <span class="keyword">in</span> range(len(valueList)):</span><br><span class="line">            <span class="keyword">while</span> num &gt;= valueList[index]:</span><br><span class="line">                res += symbolList[index]</span><br><span class="line">                num -= valueList[index]</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p>基于贪心的代码实现逻辑更简单，我感觉<strong>重点更在于列出所有非叠加的可能</strong>，即列表中的 900、400 等，而不是 300、200 之类的。</p><hr><h3 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h3><ul><li><a href="https://leetcode.com/problems/integer-to-roman/" target="_blank" rel="noopener">题目链接</a></li><li><a href="https://www.cnblogs.com/grandyang/p/4123374.html" target="_blank" rel="noopener">[LeetCode] Integer to Roman 整数转化成罗马数字</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> LeetCode日记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 贪心 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>【medium】Container With Most Water</title>
      <link href="/LeetCode-011-Container%20With%20Most%20Water.html"/>
      <url>/LeetCode-011-Container%20With%20Most%20Water.html</url>
      
        <content type="html"><![CDATA[<p>Given <em>n</em> non-negative integers <em>a1</em>, <em>a2</em>, …, <em>an</em> , where each represents a point at coordinate (<em>i</em>, <em>ai</em>). <em>n</em> vertical lines are drawn such that the two endpoints of line <em>i</em> is at (<em>i</em>, <em>ai</em>) and (<em>i</em>, 0). Find two lines, which together with x-axis forms a container, such that the container contains the most water.</p><p><strong>Note:</strong> You may not slant the container and <em>n</em> is at least 2.</p><p><img src="http://m-markdown-image.oss-cn-beijing.aliyuncs.com/2018-12-17-question_11.jpg" alt=""></p><p>The above vertical lines are represented by array [1,8,6,2,5,4,8,3,7]. In this case, the max area of water (blue section) the container can contain is 49.</p><p><strong>Example:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,8,6,2,5,4,8,3,7]</span><br><span class="line">Output: 49</span><br></pre></td></tr></table></figure><a id="more"></a><hr><h3 id="思路分析："><a href="#思路分析：" class="headerlink" title="思路分析："></a>思路分析：</h3><ul><li><p>暴力法，这又是我首先想到的方法，即两层遍历，找出所有的组合的容量，记录最大的一个返回，可是会报<code>TLE</code>异常，这里也就不贴代码了，说实话有点丢人</p></li><li><p>参考了网上一种$O(n)$的方法，基于贪心的思想。需要前后两个指针，最大容量其实取决于首尾两个边中较短的那个，跟中间边的高度没有任何关系，那么我们默认初始最大容量就是全部，即两个指针分别指向首尾，计算出当前的最大容量，然后将较小的边向中间移动一个（当然是移动指针），看能不能将较短的边换大一点，这样一直继续到前后指针碰头。有大佬指出：</p><blockquote><p>假如 A[0] &lt; A[n-1]，那么对于任意 k (k&lt;n-1)，A[0] 到 A[k] 所装的水一定会小于 A[0]到 A[n-1] 所装的水，所以我们只要关心 A[1] 到 A[n-1] 的最大盛水量就好了。</p></blockquote></li></ul><hr><h3 id="代码实现："><a href="#代码实现：" class="headerlink" title="代码实现："></a>代码实现：</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxArea</span><span class="params">(self, height)</span>:</span></span><br><span class="line">        leftIndex = <span class="number">0</span></span><br><span class="line">        rightIndex = len(height) - <span class="number">1</span></span><br><span class="line">        maxArea = min(height[leftIndex], height[rightIndex]) * (rightIndex - leftIndex)</span><br><span class="line">        <span class="keyword">while</span> leftIndex &lt; rightIndex:</span><br><span class="line">            <span class="keyword">if</span> height[leftIndex] &lt; height[rightIndex]:</span><br><span class="line">                leftIndex += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                rightIndex -= <span class="number">1</span></span><br><span class="line">            area = min(height[leftIndex], height[rightIndex]) * (rightIndex - leftIndex)</span><br><span class="line">            <span class="keyword">if</span> area &gt; maxArea:</span><br><span class="line">                maxArea = area</span><br><span class="line">        <span class="keyword">return</span> maxArea</span><br></pre></td></tr></table></figure><hr><h3 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h3><ul><li><a href="https://leetcode.com/problems/container-with-most-water/" target="_blank" rel="noopener">题目链接</a></li><li><a href="https://yanjia.me/zh/2018/11/13/leetcode-container-with-most-water/" target="_blank" rel="noopener">[Leetcode] Container With Most Water 最大盛水容器</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> LeetCode日记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 贪心 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>【medium】Longest Palindromic Substring</title>
      <link href="/LeetCode-005-Longest%20Palindromic%20Substring.html"/>
      <url>/LeetCode-005-Longest%20Palindromic%20Substring.html</url>
      
        <content type="html"><![CDATA[<p>Given a string <strong>s</strong>, find the longest palindromic substring in <strong>s</strong>. You may assume that the maximum length of <strong>s</strong> is 1000.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;babad&quot;</span><br><span class="line">Output: &quot;bab&quot;</span><br><span class="line">Note: &quot;aba&quot; is also a valid answer.</span><br></pre></td></tr></table></figure><a id="more"></a><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;cbbd&quot;</span><br><span class="line">Output: &quot;bb&quot;</span><br></pre></td></tr></table></figure><p>其实题目表述的不是很清楚，它的要求应该是找到最大的且第一个回文子串，例如字符串为<code>abacdc</code>，它应该返回的是<code>aba</code>，而不是<code>cdc</code>。</p><hr><h3 id="思路分析："><a href="#思路分析：" class="headerlink" title="思路分析："></a>思路分析：</h3><ul><li><p>独家自创法，观察到回文串的首尾字符一定是相同的，所以拿这个特征来作为一个判断标志，前后两个指针，当前后指针所指的元素相等时，则判断前后指针所夹着的是不是回文串。代码见 1.1</p></li><li><p>动态规划，若一个大回文串按比例缩小，仍然是回文串，即<code>abba</code>是回文串，那么收尾同时缩小一个后，<code>bb</code>也是回文串，即可以<strong>将大问题划分为小问题</strong>，同时如果先计算小问题，那么小问题的结果在后面计算大问题时可以直接利用，即<strong>重复利用前面的结果</strong>，这两点恰恰是动态规划思想的核心。那么具体的解决办法就是：</p><ul><li>利用一个二维数组<code>dp[i][j]</code>来存原字符串下标从<code>i</code>到<code>j</code>是否是回文串</li><li>接下来就是遍历，遍历的前 2 趟其实是计算小问题的过程，后面就是直接利用前面的小结果了</li></ul><p>具体看代码 2.1 吧，可能会比文字描述更清楚。</p></li><li><p>中心扩散法，由于回文串的长度可奇可偶，那么当长度为奇数时，中心点就一个值，长度为偶数时，中心点就有两个值，在这两种情况下，由中心点同时向两边扩散，判断是否是回文串，从而找到最大的回文子串。具体做法就是：遍历字符串，遍历到的每个节点都当成中心点，并考虑上面说的奇偶两种情况。代码见 3.1 和 3.2</p></li></ul><hr><h3 id="代码实现："><a href="#代码实现：" class="headerlink" title="代码实现："></a>代码实现：</h3><blockquote><p>1.1 独家自创</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestPalindrome</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        j = <span class="number">0</span>   <span class="comment">#①</span></span><br><span class="line">        res = <span class="string">''</span></span><br><span class="line">        sLen = len(s)</span><br><span class="line">        maxLen = len(res)</span><br><span class="line">        <span class="keyword">while</span> i &lt; sLen - maxLen:    <span class="comment">#②</span></span><br><span class="line">            <span class="keyword">while</span> j &lt; sLen:</span><br><span class="line">                <span class="keyword">if</span> s[i] == s[j]:</span><br><span class="line">                    <span class="keyword">if</span> s[i:j + <span class="number">1</span>] == s[i:j + <span class="number">1</span>][::<span class="number">-1</span>]:  <span class="comment">#③</span></span><br><span class="line">                        <span class="comment"># if len(s[i:j + 1]) &gt; maxLen:  #④</span></span><br><span class="line">                        res = s[i:j + <span class="number">1</span>]</span><br><span class="line">                        maxLen = len(res)</span><br><span class="line">                    j += <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    j += <span class="number">1</span></span><br><span class="line">            i = i + <span class="number">1</span></span><br><span class="line">            j = i + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p>代码中标注了需要注意的几个点：</p><p>①<code>j</code>为什么不初始化为 1 ，因为当字符串的长度为 1 时，最长回文子串就是它自己，而若<code>j = 1</code>则默认回文子串的长度从 2 开始。</p><p>②这里的循环条件为什么是<code>i &lt; sLen - maxLen</code>，因为这里是找最大的回文子串，而不是所有的，故前指针<code>i</code>无需遍历到最后，例如字符串：<code>bananas</code>，当<code>i = 1</code>时找到最大回文子串为<code>anana</code>，长度为 5 ，那么<code>i</code>就无需继续向后遍历了，因为后面只有 5 个元素了，即使是回文子串，其长度也不会比 5 大了，所以这时退出循环即可。而至于为什么是<code>&lt;</code>，而不是我开始写的<code>&lt;=</code>，可以结合④运行并单步调试，看看哪里会出问题。</p><p>③这里就是判断前后指针所夹的是不是回文子串，即正着和反着是不是相等。开始对切片的翻转操作是这样写的：<code>s[i:j+1:-1]</code>，但是这样得到的是空字符串，网上也都没有谈到过这个问题，于是翻书。才知道如果步进是负的话，前面的范围也要反过来。因为标准的切片形式为<code>X[i:j:k]</code>，始终都是以<code>i+k</code>前进的，所以当<code>k</code>是负时，应该把<code>j</code>和<code>i</code>调换位置，写成<code>X[j:i:k]</code>才能得到正确的结果。当然，也可以跟上面代码一样，切片和翻转分开来。</p><blockquote><p>2.1 动态规划</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestPalindrome</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        res = <span class="string">''</span></span><br><span class="line">        sLen = len(s)</span><br><span class="line">        maxLen = <span class="number">0</span></span><br><span class="line">        dp = [[<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(sLen)] <span class="keyword">for</span> j <span class="keyword">in</span> range(sLen)]</span><br><span class="line">        <span class="keyword">for</span> gap <span class="keyword">in</span> range(sLen):</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(sLen - gap):</span><br><span class="line">                <span class="keyword">if</span> gap == <span class="number">0</span>:</span><br><span class="line">                    dp[i][i + gap] = <span class="number">1</span></span><br><span class="line">                <span class="keyword">elif</span> gap == <span class="number">1</span>:</span><br><span class="line">                    dp[i][i + gap] = <span class="number">1</span> <span class="keyword">if</span> s[i] == s[i + gap] <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">if</span> s[i] == s[i + gap]:</span><br><span class="line">                        dp[i][i + gap] = <span class="number">1</span> <span class="keyword">if</span> dp[i + <span class="number">1</span>][i + gap - <span class="number">1</span>] <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        dp[i][i + gap] = <span class="number">0</span></span><br><span class="line">                <span class="keyword">if</span> dp[i][i + gap] <span class="keyword">and</span> gap &gt; maxLen - <span class="number">1</span>:</span><br><span class="line">                    maxLen = gap + <span class="number">1</span></span><br><span class="line">                    res = s[i:i + gap + <span class="number">1</span>]</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p>由于动态规划是一个自底向上的过程，那么它就必须遍历完才知道结果，我感觉不太适合这个题目（要求找最大，并不是所有），时间、空间效率都很差，提交有可能超时，另开辟了 $n^{2}$ 的空间。另外在<code>python</code>中用二维数组还是第一次（<code>python</code>中没有数组，只有列表，所以这里只能在列表中嵌套列表来表示二维数组，也可以调用<code>numpy</code>来创建）</p><blockquote><p>3.1 中心扩散法</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestPalindrome</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> len(s) &lt; <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> s</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            res = <span class="string">''</span></span><br><span class="line">            maxLen = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> centerIndex <span class="keyword">in</span> range(len(s)):</span><br><span class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>):</span><br><span class="line">                    leftIndex = centerIndex</span><br><span class="line">                    rightIndex = centerIndex+i</span><br><span class="line">                    <span class="keyword">if</span> rightIndex == len(s):<span class="comment">#①</span></span><br><span class="line">                        <span class="keyword">break</span></span><br><span class="line">                    <span class="keyword">while</span> s[leftIndex] == s[rightIndex] <span class="keyword">and</span> leftIndex &gt;= <span class="number">0</span> <span class="keyword">and</span> rightIndex &lt; len(s):</span><br><span class="line">                        leftIndex -= <span class="number">1</span></span><br><span class="line">                        rightIndex += <span class="number">1</span></span><br><span class="line">                        <span class="keyword">if</span> rightIndex == len(s):<span class="comment">#②</span></span><br><span class="line">                            <span class="keyword">break</span></span><br><span class="line">                    <span class="keyword">if</span> len(s[leftIndex+<span class="number">1</span>:rightIndex]) &gt; maxLen:</span><br><span class="line">                        res = s[leftIndex+<span class="number">1</span>:rightIndex]</span><br><span class="line">                        maxLen = len(res)</span><br><span class="line">            <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p>这段代码就是在一个函数内完成所有功能，有些杂乱，但好歹能正确跑出结果。其中第二层循环是计算的奇偶两种情况：当长度为奇数时，<code>leftIndex</code>和<code>rightIndex</code>应该相同，指向唯一一个中心点；当长度为偶数时，<code>rightIndex</code>应该比<code>leftIndex</code>大 1 ，表示中心点由 2 个元素组成。然后分别从<code>leftIndex</code>和<code>rightIndex</code>开始向两边扩散。开始写完后，总是报下标越界错误，调试半天加了①②的判断后才行。</p><blockquote><p>3.2 中心扩散法</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestPalindrome</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> len(s) &lt; <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> s</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            res = <span class="string">''</span></span><br><span class="line">            <span class="keyword">for</span> centerIndex <span class="keyword">in</span> range(len(s)):</span><br><span class="line">                subS_1 = self.spreadFromCenter(s, centerIndex, <span class="number">0</span>)</span><br><span class="line">                subS_2 = self.spreadFromCenter(s, centerIndex, <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">if</span> len(subS_1) &gt; len(res):</span><br><span class="line">                    res = subS_1</span><br><span class="line">                <span class="keyword">if</span> len(subS_2) &gt; len(res):</span><br><span class="line">                    res = subS_2</span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">spreadFromCenter</span><span class="params">(self, s, centerIndex, gap)</span>:</span></span><br><span class="line">        leftIndex = centerIndex</span><br><span class="line">        rightIndex = centerIndex + gap</span><br><span class="line">        temp = <span class="string">''</span></span><br><span class="line">        <span class="keyword">while</span> leftIndex &gt;= <span class="number">0</span> <span class="keyword">and</span> rightIndex &lt; len(s) <span class="keyword">and</span> s[leftIndex] == s[rightIndex]:</span><br><span class="line">            temp = s[leftIndex:rightIndex + <span class="number">1</span>]</span><br><span class="line">            leftIndex -= <span class="number">1</span></span><br><span class="line">            rightIndex += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> temp</span><br></pre></td></tr></table></figure><p>前面 3.1 的代码可读性不好，逻辑也混乱，于是有了这个修改版。将寻找回文子串的功能提取了出来，逻辑判断也更加清晰。具体在：</p><p>①<code>spreadFromCenter</code>方法接受的<code>gap</code>参数表明了奇偶情况，奇数则<code>leftIndex == rightIndex</code>，偶数则<code>rightIndex = leftIndex+1</code>，在函数内部只管向两边扩散并提取回文串。</p><p>②不需要<code>maxLen</code>这个多余变量，因为已经有了<code>res</code>，需要时直接<code>len(res)</code>就行</p><p>③去掉了多余的判断，在 3.1 中两次判断<code>rightIndex</code>是否越界。其实如果<code>while</code>语句的条件顺序对，则根本不需要上面的判断。在 3.1 中我是这样写的：<code>while s[leftIndex] == s[rightIndex] and leftIndex &gt;= 0 and rightIndex &lt; len(s):</code>，问题出在哪里呢？我把<code>s[leftIndex] == s[rightIndex]</code>的条件摆在第一个，而把防止越界的条件<code>leftIndex &gt;= 0</code>、<code>rightIndex &lt; len(s)</code>放在后面，那么循环中<code>rightIndex</code> 向后移动时，再进循环就可能下标越界。所以在这里，我先判断是否存在越界的可能，再判断其值是否相等。可见当有多个判断条件时，摆放顺序还是挺重要的，原来都没太注意这点。</p><hr><h3 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h3><ul><li><a href="https://leetcode.com/problems/longest-palindromic-substring/" target="_blank" rel="noopener">题目链接</a></li><li><a href="https://segmentfault.com/a/1190000002991199#articleHeader10" target="_blank" rel="noopener">最长回文子串-SegmentFault</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> LeetCode日记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 字符串 </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>【easy】Merge Sorted Array</title>
      <link href="/LeetCode-088-Merge%20Sorted%20Array.html"/>
      <url>/LeetCode-088-Merge%20Sorted%20Array.html</url>
      
        <content type="html"><![CDATA[<p>Given two sorted integer arrays <em>nums1</em> and <em>nums2</em>, merge <em>nums2</em> into <em>nums1</em> as one sorted array.</p><p><strong>Note:</strong></p><ul><li>The number of elements initialized in <em>nums1</em> and <em>nums2</em> are <em>m</em> and <em>n</em> respectively.</li><li>You may assume that <em>nums1</em> has enough space (size that is greater or equal to <em>m</em> + <em>n</em>) to hold additional elements from <em>nums2</em>.</li></ul><p><strong>Example:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">nums1 = [1,2,3,0,0,0], m = 3</span><br><span class="line">nums2 = [2,5,6],       n = 3</span><br><span class="line"></span><br><span class="line">Output: [1,2,2,3,5,6]</span><br></pre></td></tr></table></figure><a id="more"></a><hr><h3 id="思路分析："><a href="#思路分析：" class="headerlink" title="思路分析："></a>思路分析：</h3><ul><li>因为题目说<code>nums1</code>的长度是够的，例子也说明了这个问题，后面都是用 0 补位。那么最无脑的方法就是将<code>nums2</code>添加到<code>nums1</code>数字的后面，组成一个列表，然后进行排序。代码见 1.1</li><li>因为给的列表都是已经排好序的，那么就可以<strong>从后向前</strong>比较，较大的放到<code>nums1[i+j+1]</code>的位置上，可以发现还是比较好操作的，但是从前向后比较的话，就有点不好操作了。代码见 2.1</li></ul><hr><h3 id="代码实现："><a href="#代码实现：" class="headerlink" title="代码实现："></a>代码实现：</h3><blockquote><p>1.1</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">merge</span><span class="params">(self, nums1, m, nums2, n)</span>:</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(m, m + n):</span><br><span class="line">            nums1[i] = nums2[m + n - i - <span class="number">1</span>]</span><br><span class="line">        nums1.sort()</span><br><span class="line">        print(nums1)</span><br></pre></td></tr></table></figure><blockquote><p>2.1</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">merge</span><span class="params">(self, nums1, m, nums2, n)</span>:</span></span><br><span class="line">        i = m<span class="number">-1</span></span><br><span class="line">        j = n<span class="number">-1</span></span><br><span class="line">        <span class="keyword">while</span> i &gt;= <span class="number">0</span> <span class="keyword">and</span> j &gt;= <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">if</span> nums1[i] &gt; nums2[j]:</span><br><span class="line">                nums1[i+j+<span class="number">1</span>] = nums1[i]</span><br><span class="line">                i -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                nums1[i+j+<span class="number">1</span>] = nums2[j]</span><br><span class="line">                j -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> i &lt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">for</span> t <span class="keyword">in</span> range(<span class="number">0</span>, j+<span class="number">1</span>):</span><br><span class="line">                nums1[t] = nums2[t]</span><br></pre></td></tr></table></figure><hr><h3 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h3><ul><li><a href="https://leetcode.com/problems/merge-sorted-array/" target="_blank" rel="noopener">题目链接</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> LeetCode日记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>【easy】Remove Duplicates from Sorted List</title>
      <link href="/LeetCode-83-Remove%20Duplicates%20from%20Sorted%20List.html"/>
      <url>/LeetCode-83-Remove%20Duplicates%20from%20Sorted%20List.html</url>
      
        <content type="html"><![CDATA[<p>Given a sorted linked list, delete all duplicates such that each element appear only <em>once</em>.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: 1-&gt;1-&gt;2</span><br><span class="line">Output: 1-&gt;2</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: 1-&gt;1-&gt;2-&gt;3-&gt;3</span><br><span class="line">Output: 1-&gt;2-&gt;3</span><br></pre></td></tr></table></figure><p>又是链表去重的问题，前面做过的，只不过前面操作的的是<code>list</code>结构的，这里是它定义的链表结构（哎，我也不知道要怎么说了）</p><a id="more"></a><hr><h3 id="思路分析："><a href="#思路分析：" class="headerlink" title="思路分析："></a>思路分析：</h3><ul><li>和前面 <a href="https://smileyx.top/leetcode-026-remove%20duplicates%20from%20sorted%20array">Remove Duplicates from Sorted Array</a> 的思路是一样的，即采用快慢指针来解决，具体看前面的吧，还有图，这里就不重复了，直接贴代码。</li></ul><hr><h3 id="代码实现："><a href="#代码实现：" class="headerlink" title="代码实现："></a>代码实现：</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deleteDuplicates</span><span class="params">(self, head)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type head: ListNode</span></span><br><span class="line"><span class="string">        :rtype: ListNode</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> head:</span><br><span class="line">            pre = head</span><br><span class="line">            cursor = head.next</span><br><span class="line">            <span class="keyword">while</span> cursor:</span><br><span class="line">                <span class="keyword">if</span> pre.val == cursor.val:</span><br><span class="line">                    cursor = cursor.next</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    pre.next = cursor</span><br><span class="line">                    pre = cursor</span><br><span class="line">                    cursor = cursor.next</span><br><span class="line">            pre.next = <span class="keyword">None</span></span><br><span class="line">            <span class="keyword">return</span> head</span><br></pre></td></tr></table></figure><p>和前面的代码很像，只不过要注意在循环结束后，在<code>pre</code>指针的位置进行截断。</p><hr><h3 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h3><ul><li><a href="https://leetcode.com/problems/remove-duplicates-from-sorted-list/" target="_blank" rel="noopener">题目链接</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> LeetCode日记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>【easy】Two Sum</title>
      <link href="/LeetCode-001-Two%20Sum.html"/>
      <url>/LeetCode-001-Two%20Sum.html</url>
      
        <content type="html"><![CDATA[<p>Given an array of integers, return <strong>indices</strong> of the two numbers such that they add up to a specific target.</p><p>You may assume that each input would have <strong>exactly</strong> one solution, and you may not use the <em>same</em> element twice.</p><p><strong>Example:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Given nums = [2, 7, 11, 15], target = 9,</span><br><span class="line"></span><br><span class="line">Because nums[0] + nums[1] = 2 + 7 = 9,</span><br><span class="line">return [0, 1].</span><br></pre></td></tr></table></figure><a id="more"></a><hr><h3 id="思路分析："><a href="#思路分析：" class="headerlink" title="思路分析："></a>思路分析：</h3><ul><li><p>暴力方法，即用双层循环，枚举所有的组合，判断是否相加等于<code>target</code> ，对应代码块 1.1</p></li><li><p>只用一层循环，判断<code>target</code>减去取出的数是否在剩下的<code>list</code>中，这里用了 2 种写法，分别对应代码块 2.1 和 2.2</p></li></ul><hr><h3 id="代码实现："><a href="#代码实现：" class="headerlink" title="代码实现："></a>代码实现：</h3><blockquote><p>1.1</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">twoSum</span><span class="params">(self, nums, target)</span>:</span></span><br><span class="line">        <span class="keyword">for</span> i, valueX <span class="keyword">in</span> enumerate(nums):</span><br><span class="line">            <span class="keyword">for</span> j, valueY <span class="keyword">in</span> enumerate(nums[i+<span class="number">1</span>:]):</span><br><span class="line">                <span class="keyword">if</span> valueX + valueY == target:</span><br><span class="line">                    <span class="keyword">return</span> [i, i+j+<span class="number">1</span>]</span><br></pre></td></tr></table></figure><p>由于用了双层循环，时间复杂度达到了平方级别，所以耗时太多，在<code>LeetCode</code>上通不过测试。</p><p><img src="http://m-markdown-image.oss-cn-beijing.aliyuncs.com/2018-12-08-%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-12%2014.43.25.png" alt=""></p><blockquote><p>2.1</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">twoSum</span><span class="params">(self, nums, target)</span>:</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">            <span class="keyword">if</span> (target-nums[i]) <span class="keyword">in</span> nums[i+<span class="number">1</span>:]:</span><br><span class="line">                <span class="keyword">return</span> [i, nums[i+<span class="number">1</span>:].index(target-nums[i]) + (i+<span class="number">1</span>)]</span><br></pre></td></tr></table></figure><p>这里虽然只用了一层循环，但可能由于是用了<code>in</code>句或者<code>index()</code>方法的原因，耗时也很多，具体原因见后面总结。</p><p><img src="http://m-markdown-image.oss-cn-beijing.aliyuncs.com/2018-12-08-%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-12%2014.57.44.png" alt=""></p><blockquote><p>2.2</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">twoSum</span><span class="params">(self, nums, target)</span>:</span></span><br><span class="line">        hash_map = dict()</span><br><span class="line">        <span class="keyword">for</span> i, value <span class="keyword">in</span> enumerate(nums):</span><br><span class="line">            <span class="keyword">if</span> (target-value) <span class="keyword">in</span> hash_map:</span><br><span class="line">                <span class="keyword">return</span> [i, hash_map[target-value]]</span><br><span class="line">            hash_map[target-value] = i</span><br></pre></td></tr></table></figure><p>这里的方法速度就明显比前面的快，具体原因见下面总结</p><p><img src="http://m-markdown-image.oss-cn-beijing.aliyuncs.com/2018-12-08-%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-12%2015.22.51.png" alt=""></p><hr><h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><p>从 2.1 和 2.2 来看，同样只有一层循环，为什么速度差距这么大，原因并不是开始认为的<code>in</code>语句和<code>index()</code>方法的问题，本质原因其实是在 2.1 中，是在<code>list</code>中查找，而在 2.2 中，则是在<code>dict</code>中查找，而<strong>在<code>python</code>中<code>list</code>的存储结构就是线性表</strong>，可知查询复杂度很高，<strong>而<code>dict</code>的存储结构则是<code>hash</code>表</strong>，可知查询复杂度较低。</p><hr><h3 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h3><ul><li><p><a href="https://leetcode.com/problems/two-sum/" target="_blank" rel="noopener">题目链接</a></p></li><li><p><a href="https://blog.csdn.net/wzgbm/article/details/54691615" target="_blank" rel="noopener">python中in在list和dict中查找效率比较 - CSDN博客</a></p></li><li><a href="https://blog.csdn.net/jmh1996/article/details/78481365" target="_blank" rel="noopener">Python 中list, set, dict的大规模查找效率 - CSDN博客</a></li><li><a href="https://www.ibm.com/developerworks/cn/linux/l-cn-python-optim/index.html" target="_blank" rel="noopener">Python 代码性能优化技巧</a> </li><li><a href="https://blog.csdn.net/xiaoping8411/article/details/7706376" target="_blank" rel="noopener">查找算法之哈希查找 - CSDN博客</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> LeetCode日记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>【medium】Add Two Numbers</title>
      <link href="/LeetCode-002-Add%20Two%20Numbers.html"/>
      <url>/LeetCode-002-Add%20Two%20Numbers.html</url>
      
        <content type="html"><![CDATA[<p>You are given two <strong>non-empty</strong> linked lists representing two non-negative integers. The digits are stored in <strong>reverse order</strong> and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.</p><p>You may assume the two numbers do not contain any leading zero, except the number 0 itself.</p><p><strong>Example:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: (2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)</span><br><span class="line">Output: 7 -&gt; 0 -&gt; 8</span><br><span class="line">Explanation: 342 + 465 = 807.</span><br></pre></td></tr></table></figure><a id="more"></a><p>这里需要注意的就是给出的链表都是倒序的，即表头就是个位，表尾才是最高位，这极大方便了我们计算。（刚开始在这里弄了好久，以为是正序，那就还要对位后再相加，最后才发现是反的，相当于从个位到高位已经对好了）</p><hr><h3 id="思路分析："><a href="#思路分析：" class="headerlink" title="思路分析："></a>思路分析：</h3><ul><li><p>我最开始想到的就是<strong>按位相加，然后向前进位</strong>，就和我们手算一样的流程，但落实到代码上就歇菜了，于是在看了网上的大堆资料后，写了了残废版 1.1 ，最终版 1.2 ，关于代码的具体分析见下面代码实现</p></li><li><p>首先将两个链表的数据一一取出来加入对应的字符串，然后转换成<code>int</code>类型相加，最后再用结果生成对应的链表，对应代码块 2.1</p></li></ul><hr><h3 id="代码实现："><a href="#代码实现：" class="headerlink" title="代码实现："></a>代码实现：</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addTwoNumbers</span><span class="params">(self, l1, l2)</span>:</span></span><br><span class="line">        head = ListNode(<span class="number">0</span>)</span><br><span class="line">        head.next = l1</span><br><span class="line">        carry = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> l1 <span class="keyword">or</span> l2 <span class="keyword">or</span> carry != <span class="number">0</span>:</span><br><span class="line">            v1 = l1.val <span class="keyword">if</span> l1 <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">            v2 = l2.val <span class="keyword">if</span> l2 <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">            add = v1 + v2 + carry</span><br><span class="line">            <span class="keyword">if</span> add &gt;= <span class="number">10</span>:</span><br><span class="line">                carry = <span class="number">1</span></span><br><span class="line">                add -= <span class="number">10</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                carry = <span class="number">0</span></span><br><span class="line">            l1.val = add</span><br><span class="line">            l1 = l1.next</span><br><span class="line">            l2 = l2.next</span><br><span class="line">        <span class="keyword">return</span> head.next</span><br></pre></td></tr></table></figure><p>可以看到给的初始测试数据是能通过的，但后面就通不过了。</p><p><img src="http://m-markdown-image.oss-cn-beijing.aliyuncs.com/2018-12-08-%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-13%2021.41.26.png" alt=""></p><p><img src="http://m-markdown-image.oss-cn-beijing.aliyuncs.com/2018-12-08-%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-13%2021.42.09.png" alt=""></p><p>分析下问题出在哪里：</p><ul><li>这里我是直接用<code>L1</code>来存最后的结果，当<code>L1</code> 的长度大于或等于<code>L2</code>的长度，且最高位没有继续向前进位的情况下，该方法是可行的，也就解释了为什么第一个测试数据能通过，而后面出错的测试数据则是在最高位产生了进位，而代码并没有在进位时产生一个新的节点来存数据。</li></ul><p>解决方法：</p><ul><li>如果还是要用现存的列表来存结果，那么首先就需要判断 L1 和 L2 的长度， 选择较长的那个链表来存数据，那么前面就不会存在无节点存数据的问题，需要注意的是如果最高位存在进位，仍然要申请一个新节点来存。</li><li>上面这种方法有点过于复杂，既然有可能也要申请新节点，那么为什么不直接新建一个链表来存数据呢，于是有了下面的代码块。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addTwoNumbers</span><span class="params">(self, l1, l2)</span>:</span></span><br><span class="line">        head = result = ListNode(<span class="number">0</span>)<span class="comment">#①</span></span><br><span class="line">        carry = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> l1 <span class="keyword">or</span> l2 <span class="keyword">or</span> carry != <span class="number">0</span>:</span><br><span class="line">            v1 = l1.val <span class="keyword">if</span> l1 <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">            v2 = l2.val <span class="keyword">if</span> l2 <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">            add = v1 + v2 + carry</span><br><span class="line">            <span class="keyword">if</span> add &gt;= <span class="number">10</span>:</span><br><span class="line">                carry = <span class="number">1</span></span><br><span class="line">                add -= <span class="number">10</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                carry = <span class="number">0</span></span><br><span class="line">            result.next = ListNode(add)<span class="comment">#②</span></span><br><span class="line">            result = result.next<span class="comment">#③</span></span><br><span class="line">            <span class="keyword">if</span> l1:</span><br><span class="line">                l1 = l1.next</span><br><span class="line">            <span class="keyword">if</span> l2:</span><br><span class="line">                l2 = l2.next</span><br><span class="line">        <span class="keyword">return</span> head.next</span><br></pre></td></tr></table></figure><p>写这段代码时，关于结果链表各个节点的连接纠结了好久，下面画了一个图来帮助理解上面代码的 3 个关键点，对应于代码中注释的 ① ② ③：</p><p><img src="http://m-markdown-image.oss-cn-beijing.aliyuncs.com/2018-12-08-IMG_3709.JPG" alt=""></p><p>这里的<code>result</code>可以相当于游标，是跟着新节点走的</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addTwoNumbers</span><span class="params">(self, l1, l2)</span>:</span></span><br><span class="line">        l1_str = l2_str = <span class="string">''</span></span><br><span class="line">        head = result = ListNode(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">while</span> l1 <span class="keyword">or</span> l2:</span><br><span class="line">            <span class="keyword">if</span> l1:</span><br><span class="line">                l1_str += str(l1.val)</span><br><span class="line">            <span class="keyword">if</span> l2:</span><br><span class="line">                l2_str += str(l2.val)</span><br><span class="line">            <span class="keyword">if</span> l1:</span><br><span class="line">                l1 = l1.next</span><br><span class="line">            <span class="keyword">if</span> l2:</span><br><span class="line">                l2 = l2.next</span><br><span class="line">        sum = int(l1_str[::<span class="number">-1</span>]) + int(l2_str[::<span class="number">-1</span>])</span><br><span class="line">        sum_str = str(sum)[::<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> value <span class="keyword">in</span> sum_str:</span><br><span class="line">            result.next = ListNode(int(value))</span><br><span class="line">            result = result.next</span><br><span class="line">        <span class="keyword">return</span> head.next</span><br></pre></td></tr></table></figure><p>另外鉴于我对数据结构的掌握实在太差，永远只停留在表面上的了解，一落实到代码实现就GG，于是打算在刷<code>LeetCode</code>的同时，对基础的数据结构的实现也做下练习：<code>Python实现单链表</code></p><hr><h3 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h3><ul><li><a href="https://leetcode.com/problems/add-two-numbers/" target="_blank" rel="noopener">题目链接</a></li><li><a href="https://www.jianshu.com/p/5d8f13225adf" target="_blank" rel="noopener">LeetCode题解2：Add two numbers - 简书</a></li><li><a href="https://www.jianshu.com/p/15079795f604?utm_campaign=maleskine&amp;utm_content=note&amp;utm_medium=seo_notes&amp;utm_source=recommendation" target="_blank" rel="noopener">LeetCode 解题报告 - 2. Add Two Numbers - 简书</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> LeetCode日记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>【easy】Reverse Integer</title>
      <link href="/LeetCode-007-Reverse%20Integer.html"/>
      <url>/LeetCode-007-Reverse%20Integer.html</url>
      
        <content type="html"><![CDATA[<p>Given a 32-bit signed integer, reverse digits of an integer.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: 123</span><br><span class="line">Output: 321</span><br></pre></td></tr></table></figure><a id="more"></a><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: -123</span><br><span class="line">Output: -321</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: 120</span><br><span class="line">Output: 21</span><br></pre></td></tr></table></figure><p><strong>Note:</strong><br>Assume we are dealing with an environment which could only store integers within the 32-bit signed integer range: [−231,  231 − 1]. For the purpose of this problem, assume that your function returns 0 when the reversed integer overflows.</p><hr><h3 id="思路整理："><a href="#思路整理：" class="headerlink" title="思路整理："></a>思路整理：</h3><ul><li><p>我首先想到的是将数字去除符号后转换成字符串，然后利用切片来翻转字符串，去掉开头连续的 0（如果有的话），最后补上符号位转换成数字类型返回。见代码块 1.1 </p></li><li><p>通过不断除 10 取余的方法来讲数字倒置，然后将倒置的数字乘 10 的相应次方来得到最后的答案。见代码块 2.1</p></li></ul><hr><h3 id="代码实现："><a href="#代码实现：" class="headerlink" title="代码实现："></a>代码实现：</h3><blockquote><p>1.1</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverse</span><span class="params">(self, x)</span>:</span></span><br><span class="line">isNegative = <span class="keyword">False</span> <span class="keyword">if</span> x&gt;=<span class="number">0</span> <span class="keyword">else</span> <span class="keyword">True</span></span><br><span class="line">        reverseStr = str(-x)[::<span class="number">-1</span>] <span class="keyword">if</span> isNegative <span class="keyword">else</span> str(x)[::<span class="number">-1</span>]</span><br><span class="line">        flag = <span class="number">0</span></span><br><span class="line">        result = <span class="string">''</span></span><br><span class="line">        <span class="keyword">for</span> value <span class="keyword">in</span> reverseStr:</span><br><span class="line">            <span class="keyword">if</span> value != <span class="number">0</span>:</span><br><span class="line">                flag = <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">if</span> flag:</span><br><span class="line">                result += value</span><br><span class="line">        <span class="keyword">if</span> int(result) &lt; (<span class="number">2</span>**<span class="number">31</span>)<span class="number">-1</span>:</span><br><span class="line">            <span class="keyword">return</span> -int(result) <span class="keyword">if</span> isNegative <span class="keyword">else</span> int(result)</span><br></pre></td></tr></table></figure><p>写完后看了看别人的代码，发现用<code>int</code>将字符串转换成数字类型时，它能自动去掉前面连续的 0 ，再看看我的代码，简直蠢！处理了半天前面的 0 ，修改见 1.2</p><blockquote><p>1.2</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverse</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type x: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        reverseStr = str(-x)[::<span class="number">-1</span>] <span class="keyword">if</span> x&lt;<span class="number">0</span> <span class="keyword">else</span> str(x)[::<span class="number">-1</span>]</span><br><span class="line">        <span class="keyword">if</span> int(reverseStr) &lt; (<span class="number">2</span>**<span class="number">31</span>)<span class="number">-1</span>:</span><br><span class="line">            <span class="keyword">return</span> -int(reverseStr) <span class="keyword">if</span> x&lt;<span class="number">0</span> <span class="keyword">else</span> int(reverseStr)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br></pre></td></tr></table></figure><blockquote><p>2.1</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverse</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">:type x: int</span></span><br><span class="line"><span class="string">:rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        a = x <span class="keyword">if</span> x &gt; <span class="number">0</span> <span class="keyword">else</span> -x</span><br><span class="line">        b = <span class="number">0</span></span><br><span class="line">        temp = []</span><br><span class="line">        <span class="keyword">while</span> a != <span class="number">0</span>:</span><br><span class="line">            b = a % <span class="number">10</span></span><br><span class="line">            a //= <span class="number">10</span></span><br><span class="line">            temp.append(b)</span><br><span class="line">        tempLength = len(temp)</span><br><span class="line">        reverseNum = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(tempLength):</span><br><span class="line">            reverseNum += temp[i]*(<span class="number">10</span>**(tempLength-i<span class="number">-1</span>))</span><br><span class="line">        <span class="keyword">if</span> reverseNum &lt; -(<span class="number">2</span>**<span class="number">31</span>) <span class="keyword">or</span> reverseNum &gt; (<span class="number">2</span>**<span class="number">31</span>)<span class="number">-1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> reverseNum <span class="keyword">if</span> x&gt;<span class="number">0</span> <span class="keyword">else</span> -reverseNum</span><br></pre></td></tr></table></figure><p>将计算过程画出来如下：</p><p><img src="http://m-markdown-image.oss-cn-beijing.aliyuncs.com/2018-12-08-IMG_3723.JPG" alt=""></p><hr><h3 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h3><ul><li><a href="https://leetcode.com/problems/reverse-integer/" target="_blank" rel="noopener">题目链接</a></li><li><a href="https://blog.csdn.net/huzq1976/article/details/51581330" target="_blank" rel="noopener">python中的除法，取整和求模 - CSDN博客</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> LeetCode日记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>【easy】Longest Substring Without Repeating Characters</title>
      <link href="/LeetCode-009-Palindrome%20Number.html"/>
      <url>/LeetCode-009-Palindrome%20Number.html</url>
      
        <content type="html"><![CDATA[<p>Determine whether an integer is a palindrome. An integer is a palindrome when it reads the same backward as forward.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: 121</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure><a id="more"></a><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: -121</span><br><span class="line">Output: false</span><br><span class="line">Explanation: From left to right, it reads -121. From right to left, it becomes 121-. Therefore it is not a palindrome.</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: 10</span><br><span class="line">Output: false</span><br><span class="line">Explanation: Reads 01 from right to left. Therefore it is not a palindrome.</span><br></pre></td></tr></table></figure><p><strong>Follow up:</strong></p><p>Coud you solve it without converting the integer to a string?</p><p>本题比较简单，可以直接套用<code>Reverse Integer</code>里面的第二种方法，就直接贴代码吧</p><hr><h3 id="代码实现："><a href="#代码实现：" class="headerlink" title="代码实现："></a>代码实现：</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isPalindrome</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">  :type x: int</span></span><br><span class="line"><span class="string">  :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line"><span class="keyword">if</span> x &lt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            a = x</span><br><span class="line">            b, reverse = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">            temp = []</span><br><span class="line">            <span class="keyword">while</span> a != <span class="number">0</span>:</span><br><span class="line">                b = a % <span class="number">10</span></span><br><span class="line">                a //= <span class="number">10</span></span><br><span class="line">                temp.append(b)</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(len(temp)):</span><br><span class="line">                reverse += temp[i]*(<span class="number">10</span>**(len(temp)-i<span class="number">-1</span>))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">True</span> <span class="keyword">if</span> reverse == x <span class="keyword">else</span> <span class="keyword">False</span></span><br></pre></td></tr></table></figure><hr><h3 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h3><ul><li><a href="https://leetcode.com/problems/palindrome-number/" target="_blank" rel="noopener">题目链接</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> LeetCode日记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>【easy】Roman to Integer</title>
      <link href="/LeetCode-013-Roman%20to%20Integer.html"/>
      <url>/LeetCode-013-Roman%20to%20Integer.html</url>
      
        <content type="html"><![CDATA[<p>Roman numerals are represented by seven different symbols: <code>I</code>, <code>V</code>, <code>X</code>, <code>L</code>, <code>C</code>, <code>D</code> and <code>M</code>.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Symbol       Value</span><br><span class="line">I             1</span><br><span class="line">V             5</span><br><span class="line">X             10</span><br><span class="line">L             50</span><br><span class="line">C             100</span><br><span class="line">D             500</span><br><span class="line">M             1000</span><br></pre></td></tr></table></figure><a id="more"></a><p>For example, two is written as <code>II</code> in Roman numeral, just two one’s added together. Twelve is written as, <code>XII</code>, which is simply <code>X</code> + <code>II</code>. The number twenty seven is written as <code>XXVII</code>, which is <code>XX</code> + <code>V</code> + <code>II</code>.</p><p>Roman numerals are usually written largest to smallest from left to right. However, the numeral for four is not <code>IIII</code>. Instead, the number four is written as <code>IV</code>. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as <code>IX</code>. There are six instances where subtraction is used:</p><ul><li><code>I</code> can be placed before <code>V</code> (5) and <code>X</code> (10) to make 4 and 9. </li><li><code>X</code> can be placed before <code>L</code> (50) and <code>C</code> (100) to make 40 and 90. </li><li><code>C</code> can be placed before <code>D</code> (500) and <code>M</code> (1000) to make 400 and 900.</li></ul><p>Given a roman numeral, convert it to an integer. Input is guaranteed to be within the range from 1 to 3999.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;III&quot;</span><br><span class="line">Output: 3</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;IV&quot;</span><br><span class="line">Output: 4</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;IX&quot;</span><br><span class="line">Output: 9</span><br></pre></td></tr></table></figure><p><strong>Example 4:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;LVIII&quot;</span><br><span class="line">Output: 58</span><br><span class="line">Explanation: L = 50, V= 5, III = 3.</span><br></pre></td></tr></table></figure><p><strong>Example 5:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;MCMXCIV&quot;</span><br><span class="line">Output: 1994</span><br><span class="line">Explanation: M = 1000, CM = 900, XC = 90 and IV = 4.</span><br></pre></td></tr></table></figure><p>题目好长，其实主要就是要理解罗马数字规则，理解了规则还是很好写出来的，题目没说要做错误判断，即测试的数据都是正确的罗马数字，所以后面的代码也没对罗马数字的正确与否做判断，默认正确的情况下进行处理。</p><hr><h3 id="代码实现："><a href="#代码实现：" class="headerlink" title="代码实现："></a>代码实现：</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">romanToInt</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        dict = &#123;<span class="string">'I'</span>: <span class="number">1</span>, <span class="string">'V'</span>: <span class="number">5</span>, <span class="string">'X'</span>: <span class="number">10</span>, <span class="string">'L'</span>: <span class="number">50</span>, <span class="string">'C'</span>: <span class="number">100</span>, <span class="string">'D'</span>: <span class="number">500</span>, <span class="string">'M'</span>: <span class="number">1000</span>&#125;</span><br><span class="line">        length, sum, cursor = len(s), <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> cursor &lt; length:</span><br><span class="line">            <span class="keyword">if</span> cursor == length - <span class="number">1</span>:</span><br><span class="line">                sum += dict[s[cursor]]</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                flag = dict[s[cursor + <span class="number">1</span>]] // dict[s[cursor]]</span><br><span class="line">                <span class="keyword">if</span> flag &lt;= <span class="number">1</span>:</span><br><span class="line">                    sum += dict[s[cursor]]</span><br><span class="line">                    cursor += <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    sum += (dict[s[cursor + <span class="number">1</span>]] - dict[s[cursor]])</span><br><span class="line">                    cursor += <span class="number">2</span></span><br><span class="line">        <span class="keyword">return</span> sum</span><br></pre></td></tr></table></figure><hr><h3 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h3><ul><li><a href="https://leetcode.com/problems/roman-to-integer/" target="_blank" rel="noopener">题目链接</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> LeetCode日记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>【easy】Longest Common Prefix</title>
      <link href="/LeetCode-014-Longest%20Common%20Prefix.html"/>
      <url>/LeetCode-014-Longest%20Common%20Prefix.html</url>
      
        <content type="html"><![CDATA[<p>Write a function to find the longest common prefix string amongst an array of strings.</p><p>If there is no common prefix, return an empty string <code>&quot;&quot;</code>.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [&quot;flower&quot;,&quot;flow&quot;,&quot;flight&quot;]</span><br><span class="line">Output: &quot;fl&quot;</span><br></pre></td></tr></table></figure><a id="more"></a><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [&quot;dog&quot;,&quot;racecar&quot;,&quot;car&quot;]</span><br><span class="line">Output: &quot;&quot;</span><br><span class="line">Explanation: There is no common prefix among the input strings.</span><br></pre></td></tr></table></figure><hr><h3 id="思路分析："><a href="#思路分析：" class="headerlink" title="思路分析："></a>思路分析：</h3><ul><li>审题真的很重要，开始花了大量时间，结果写成了获得最长公共子串，提交总失败，后来又看了看题目，才发现是最长公共前缀，不过还好，有了前面的思考容量，公共前缀很好写了。我的想法是首先找出序列中最短的字符串，由这个字符串下手，从<strong>大到小进行切片</strong>，并与其它字符串的前缀进行比较。这时如果成功找到第一个前缀，即可退出循环，因为是从大到小进行的切片。详细还是见代码块 1.1<br>[注]：最长公共子串也放到代码块 1.2 了（这个竟花了大半天，哎，菜是原罪）</li></ul><hr><h3 id="代码实现："><a href="#代码实现：" class="headerlink" title="代码实现："></a>代码实现：</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestCommonPrefix</span><span class="params">(self, strs)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">  :type***strs: List[str]</span></span><br><span class="line"><span class="string">  :rtype***: str</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line"><span class="keyword">if</span> strs:</span><br><span class="line">            <span class="comment">#首先找到列表中最短的字符串及其长度</span></span><br><span class="line">            shortStr = strs[<span class="number">0</span>]</span><br><span class="line">            shortLength = len(strs[<span class="number">0</span>])</span><br><span class="line">            <span class="keyword">for</span> s <span class="keyword">in</span> strs[<span class="number">1</span>:]:</span><br><span class="line">                <span class="keyword">if</span> len(s) &lt; shortLength:</span><br><span class="line">                    shortStr = s</span><br><span class="line">            cursor = shortLength</span><br><span class="line">            strs.remove(shortStr)</span><br><span class="line">            flag = <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> cursor &gt; <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">for</span> s <span class="keyword">in</span> strs:</span><br><span class="line">  <span class="comment">#注意，这里是找公共前缀，那么该字符串必然是其他字符串的前缀</span></span><br><span class="line">  <span class="comment">#而不能简单的用 not in s 来判断</span></span><br><span class="line">                    <span class="keyword">if</span> shortStr[:cursor] != s[:cursor]:</span><br><span class="line">                        flag = <span class="number">0</span></span><br><span class="line">                        <span class="keyword">break</span></span><br><span class="line">                <span class="keyword">if</span> flag:</span><br><span class="line">                    <span class="keyword">return</span> shortStr[:cursor]</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    cursor -= <span class="number">1</span></span><br><span class="line">                    flag = <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> <span class="string">''</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">''</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestCommonPrefix</span><span class="params">(self, strs)</span>:</span></span><br><span class="line">  <span class="keyword">if</span> strs:</span><br><span class="line">            shortStr = strs[<span class="number">0</span>]</span><br><span class="line">            shortLength = len(strs[<span class="number">0</span>])</span><br><span class="line">            <span class="keyword">for</span> s <span class="keyword">in</span> strs[<span class="number">1</span>:]:</span><br><span class="line">                <span class="keyword">if</span> len(s) &lt; shortLength:</span><br><span class="line">                    shortStr = s</span><br><span class="line">                    shortLength = len(s)</span><br><span class="line">            cursor = <span class="number">0</span></span><br><span class="line">            gap = shortLength</span><br><span class="line">            flag = <span class="number">1</span></span><br><span class="line">            <span class="comment">#注意list的remove方法删除特定元素后，并无返回值</span></span><br><span class="line">            <span class="comment">#执行完毕后list的相应元素已经被删除了</span></span><br><span class="line">            strs.remove(shortStr)</span><br><span class="line">            <span class="keyword">while</span> gap &gt; <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">if</span> cursor + gap &gt; shortLength:</span><br><span class="line">                    gap -= <span class="number">1</span></span><br><span class="line">                    cursor = <span class="number">0</span></span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">for</span> s <span class="keyword">in</span> strs:</span><br><span class="line">                        <span class="keyword">if</span> shortStr[cursor:cursor + gap] <span class="keyword">not</span> <span class="keyword">in</span> s:</span><br><span class="line">                            flag = <span class="number">0</span></span><br><span class="line">                            <span class="keyword">break</span></span><br><span class="line">                    <span class="keyword">if</span> flag:</span><br><span class="line">                        <span class="keyword">return</span> shortStr[cursor:cursor + gap]</span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        cursor += <span class="number">1</span></span><br><span class="line">                        flag = <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> <span class="string">''</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">''</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    sol = Solution()</span><br><span class="line">    print(sol.longestCommonPrefix([<span class="string">"dog"</span>,<span class="string">"racogecar"</span>,<span class="string">"cogar"</span>]))</span><br><span class="line">    print(sol.longestCommonPrefix([<span class="string">"dog"</span>,<span class="string">"racggecar"</span>,<span class="string">"cogar"</span>]))</span><br></pre></td></tr></table></figure><p><img src="http://m-markdown-image.oss-cn-beijing.aliyuncs.com/2018-12-08-%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-21%2016.58.37.png" alt=""></p><p>简单测试了一下应该是没有问题的。当时在写的时候循环判断那里折腾了好久，比如：</p><ul><li>忘记加 continue 语句</li><li>在当前循环中将标志位<code>flag</code>设为 0 后，开始新循环后并没有将<code>flag</code>恢复成 1</li></ul>]]></content>
      
      
      <categories>
          
          <category> LeetCode日记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 字符串公共前缀 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>【easy】Valid Parentheses</title>
      <link href="/LeetCode-020-Valid%20Parentheses.html"/>
      <url>/LeetCode-020-Valid%20Parentheses.html</url>
      
        <content type="html"><![CDATA[<p>Given a string containing just the characters <code>&#39;(&#39;</code>, <code>&#39;)&#39;</code>, <code>&#39;{&#39;</code>, <code>&#39;}&#39;</code>, <code>&#39;[&#39;</code> and <code>&#39;]&#39;</code>, determine if the input string is valid.</p><p>An input string is valid if:</p><ol><li>Open brackets must be closed by the same type of brackets.</li><li>Open brackets must be closed in the correct order.</li></ol><p>Note that an empty string is also considered valid.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;()&quot;</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure><a id="more"></a><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;()[]&#123;&#125;&quot;</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;(]&quot;</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure><p><strong>Example 4:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;([)]&quot;</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure><p><strong>Example 5:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;&#123;[]&#125;&quot;</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure><hr><h3 id="思路分析："><a href="#思路分析：" class="headerlink" title="思路分析："></a>思路分析：</h3><ul><li>因为就是单单判断括号匹配，没有加入运算，所以思路很简单，遍历字符串，若是左括号，则进栈，否则判断栈顶元素是否与之匹配，若匹配则让栈顶元素出栈并继续循环，若不匹配直接返回<code>False</code>退出循环。但是需要注意的是最后循环结束后，若栈中还剩元素，则还是需要返回<code>False</code></li></ul><hr><h3 id="代码实现："><a href="#代码实现：" class="headerlink" title="代码实现："></a>代码实现：</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isValid</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">  :type***s: str</span></span><br><span class="line"><span class="string">  :rtype***: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line"><span class="keyword">if</span> len(s) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            matchs = &#123;<span class="string">'('</span>: <span class="string">')'</span>, <span class="string">'['</span>: <span class="string">']'</span>, <span class="string">'&#123;'</span>: <span class="string">'&#125;'</span>&#125;</span><br><span class="line">            stack = []</span><br><span class="line">            <span class="keyword">for</span> s <span class="keyword">in</span> s:</span><br><span class="line">                <span class="keyword">if</span> s <span class="keyword">in</span> matchs:</span><br><span class="line">                    stack.append(s)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">if</span> stack:</span><br><span class="line">                        <span class="keyword">if</span> matchs.get(stack[len(stack)<span class="number">-1</span>]) == s:</span><br><span class="line">                            stack.pop()</span><br><span class="line">                        <span class="keyword">else</span>:</span><br><span class="line">                            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span> <span class="keyword">if</span> stack <span class="keyword">else</span> <span class="keyword">True</span></span><br></pre></td></tr></table></figure><p>开始提交时总错误，还是考虑问题不够全面，只考虑了正常情况。另外，字典的遍历在前面<code>读取 txt 内容，写入 xls 文件</code>中写过了。在写这个题的时候就有写一个简单的栈的想法，刚好在<code>LeetCode</code>上找到了这种题，那下篇就撸个简单的栈吧。</p><hr><h3 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h3><ul><li><a href="https://leetcode.com/problems/valid-parentheses/" target="_blank" rel="noopener">题目链接</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> LeetCode日记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 栈 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>【easy】Merge Two Sorted Lists</title>
      <link href="/LeetCode-021-Merge%20Two%20Sorted%20Lists.html"/>
      <url>/LeetCode-021-Merge%20Two%20Sorted%20Lists.html</url>
      
        <content type="html"><![CDATA[<p>Merge two sorted linked lists and return it as a new list. The new list should be made by splicing together the nodes of the first two lists.</p><p><strong>Example:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: 1-&gt;2-&gt;4, 1-&gt;3-&gt;4</span><br><span class="line">Output: 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4</span><br></pre></td></tr></table></figure><p>题目就是要合并2个有序的列表，方法也就是同时遍历2个列表，比较元素并把较小的添加到结果链表中。</p><a id="more"></a><hr><h3 id="代码实现："><a href="#代码实现：" class="headerlink" title="代码实现："></a>代码实现：</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mergeTwoLists</span><span class="params">(self, l1, l2)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type l1: ListNode</span></span><br><span class="line"><span class="string">        :type l2: ListNode</span></span><br><span class="line"><span class="string">        :rtype: ListNode</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        head = cursor = ListNode(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">while</span> l1 <span class="keyword">and</span> l2:</span><br><span class="line">            <span class="keyword">if</span> l1.val &lt;= l2.val:</span><br><span class="line">                cursor.next = ListNode(l1.val)</span><br><span class="line">                l1 = l1.next</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                cursor.next = ListNode(l2.val)</span><br><span class="line">                l2 = l2.next</span><br><span class="line">            cursor = cursor.next</span><br><span class="line">        <span class="keyword">while</span> l1:</span><br><span class="line">            cursor.next = ListNode(l1.val)</span><br><span class="line">            l1 = l1.next</span><br><span class="line">            cursor = cursor.next</span><br><span class="line">        <span class="keyword">while</span> l2:</span><br><span class="line">            cursor.next = ListNode(l2.val)</span><br><span class="line">            l2 = l2.next</span><br><span class="line">            cursor = cursor.next</span><br><span class="line">        <span class="keyword">return</span> head.next</span><br></pre></td></tr></table></figure><p>这里有点蠢的就是当有一个链表遍历结束后，我竟然还对另外的链表继续遍历！！直接将另外的<br>链表给<code>cursor</code>就好了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mergeTwoLists</span><span class="params">(self, l1, l2)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type l1: ListNode</span></span><br><span class="line"><span class="string">        :type l2: ListNode</span></span><br><span class="line"><span class="string">        :rtype: ListNode</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        head = cursor = ListNode(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">while</span> l1 <span class="keyword">and</span> l2:</span><br><span class="line">            <span class="keyword">if</span> l1.val &lt;= l2.val:</span><br><span class="line">                cursor.next = ListNode(l1.val)</span><br><span class="line">                l1 = l1.next</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                cursor.next = ListNode(l2.val)</span><br><span class="line">                l2 = l2.next</span><br><span class="line">            cursor = cursor.next</span><br><span class="line">        cursor.next = l1 <span class="keyword">if</span> l1 <span class="keyword">else</span> l2</span><br><span class="line">        <span class="keyword">return</span> head.next</span><br></pre></td></tr></table></figure><hr><h3 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h3><ul><li><a href="https://leetcode.com/problems/merge-two-sorted-lists/" target="_blank" rel="noopener">题目链接</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> LeetCode日记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>【easy】Remove Duplicates from Sorted Array</title>
      <link href="/LeetCode-026-Remove%20Duplicates%20from%20Sorted%20Array.html"/>
      <url>/LeetCode-026-Remove%20Duplicates%20from%20Sorted%20Array.html</url>
      
        <content type="html"><![CDATA[<p>Given a sorted array <em>nums</em>, remove the duplicates <a href="https://en.wikipedia.org/wiki/In-place_algorithm" target="_blank" rel="noopener"><strong>in-place</strong></a> such that each element appear only <em>once</em> and return the new length.</p><p>Do not allocate extra space for another array, you must do this by <strong>modifying the input array in-place</strong> with O(1) extra memory.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Given nums = [1,1,2],</span><br><span class="line"></span><br><span class="line">Your function should return length = 2, with the first two elements of nums being 1 and 2 respectively.</span><br><span class="line"></span><br><span class="line">It doesn&apos;t matter what you leave beyond the returned length.</span><br></pre></td></tr></table></figure><a id="more"></a><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Given nums = [0,0,1,1,1,2,2,3,3,4],</span><br><span class="line"></span><br><span class="line">Your function should return length = 5, with the first five elements of nums being modified to 0, 1, 2, 3, and 4 respectively.</span><br><span class="line"></span><br><span class="line">It doesn&apos;t matter what values are set beyond the returned length.</span><br></pre></td></tr></table></figure><p>题目要求的是原地操作，即不能开辟新空间</p><hr><h3 id="思路分析："><a href="#思路分析：" class="headerlink" title="思路分析："></a>思路分析：</h3><ul><li><p>用快慢指针的思想，针对本题，初始化令慢指针指向第一个元素，令快指针指向第二个元素：</p><p>若快慢指针所指向的2个值不相等：慢指针先前进一步，将当前指向的元素修改为快指针所指的元素，然后快指针再前进一步</p><p>若相等：则快慢指针都向前走一步就好</p><p>最后当快指针走到末尾时退出循环，文字表述实在太蛋疼，画张图吧（注意图上红色的地方，表示着对原列表的修改。）：</p><p><img src="http://m-markdown-image.oss-cn-beijing.aliyuncs.com/2018-12-10-IMG_3738.JPG" alt=""></p></li></ul><hr><h3 id="代码实现："><a href="#代码实现：" class="headerlink" title="代码实现："></a>代码实现：</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeDuplicates</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        i, j = <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">        length = len(nums)</span><br><span class="line">        <span class="keyword">if</span> length &lt; <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> len(nums)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">while</span> j &lt; length:</span><br><span class="line">                <span class="keyword">if</span> nums[i] == nums[j]:</span><br><span class="line">                    j += <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    i += <span class="number">1</span></span><br><span class="line">                    nums[i] = nums[j]</span><br><span class="line">                    j += <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> i+<span class="number">1</span></span><br></pre></td></tr></table></figure><hr><h3 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h3><ul><li><a href="https://leetcode.com/problems/remove-duplicates-from-sorted-array/" target="_blank" rel="noopener">题目链接</a></li><li><a href="https://medium.com/@urdreamliu/26-%E5%9C%96%E8%A7%A3-remove-duplicates-from-sorted-array-cbee5b2d4df8" target="_blank" rel="noopener">26.圖解Remove Duplicates from Sorted Array</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> LeetCode日记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>【easy】Remove Element</title>
      <link href="/LeetCode-027-Remove%20Element.html"/>
      <url>/LeetCode-027-Remove%20Element.html</url>
      
        <content type="html"><![CDATA[<p>Given an array <em>nums</em> and a value <em>val</em>, remove all instances of that value <a href="https://en.wikipedia.org/wiki/In-place_algorithm" target="_blank" rel="noopener"><strong>in-place</strong></a> and return the new length.</p><p>Do not allocate extra space for another array, you must do this by <strong>modifying the input array in-place</strong> with O(1) extra memory.</p><p>The order of elements can be changed. It doesn’t matter what you leave beyond the new length.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Given nums = [3,2,2,3], val = 3,</span><br><span class="line"></span><br><span class="line">Your function should return length = 2, with the first two elements of nums being 2.</span><br><span class="line"></span><br><span class="line">It doesn&apos;t matter what you leave beyond the returned length.</span><br></pre></td></tr></table></figure><a id="more"></a><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Given nums = [0,1,2,2,3,0,4,2], val = 2,</span><br><span class="line"></span><br><span class="line">Your function should return length = 5, with the first five elements of nums containing 0, 1, 3, 0, and 4.</span><br><span class="line"></span><br><span class="line">Note that the order of those five elements can be arbitrary.</span><br><span class="line"></span><br><span class="line">It doesn&apos;t matter what values are set beyond the returned length.</span><br></pre></td></tr></table></figure><p>注意这里题目的要求，只能对原列表进行操作，而不能创建新的列表</p><hr><h3 id="思路分析："><a href="#思路分析：" class="headerlink" title="思路分析："></a>思路分析：</h3><ul><li><p>这题的思路和上一题<code>Remove Duplicates from Sorted Array</code>的思路很像，都是利用了快慢指针来处理，首先快慢指针初始化都指向第一个元素，比较快指针所指向的值与给定要删除元素的关系：<br>​    若不等：则判断快慢指针是否指向同一位置：<br>​        若不是，则需将快指针所指的元素赋给慢指针所指的位置，再将快慢指针都走一步<br>​    若相等：则只走快指针<br>画个图帮助理解：</p><p><img src="http://m-markdown-image.oss-cn-beijing.aliyuncs.com/2018-12-08-IMG_3724.JPG" alt=""></p></li></ul><hr><h3 id="代码实现："><a href="#代码实现：" class="headerlink" title="代码实现："></a>代码实现：</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeElement</span><span class="params">(self, nums, val)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">  :type nums: List[int]</span></span><br><span class="line"><span class="string">  :type val: int</span></span><br><span class="line"><span class="string">  :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">  i = j = <span class="number">0</span></span><br><span class="line">        length = len(nums)</span><br><span class="line">        <span class="keyword">while</span> j &lt; length:</span><br><span class="line">            <span class="keyword">if</span> nums[j] == val:</span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> i != j:</span><br><span class="line">                    nums[i] = nums[j]</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> i</span><br></pre></td></tr></table></figure><hr><h3 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h3><ul><li><a href="https://leetcode.com/problems/remove-element/" target="_blank" rel="noopener">题目链接</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> LeetCode日记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>【easy】Implement strStr()</title>
      <link href="/LeetCode-028-Implement%20strStr().html"/>
      <url>/LeetCode-028-Implement%20strStr().html</url>
      
        <content type="html"><![CDATA[<p>Implement <a href="http://www.cplusplus.com/reference/cstring/strstr/" target="_blank" rel="noopener">strStr()</a>.</p><p>Return the index of the first occurrence of needle in haystack, or <strong>-1</strong> if needle is not part of haystack.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: haystack = &quot;hello&quot;, needle = &quot;ll&quot;</span><br><span class="line">Output: 2</span><br></pre></td></tr></table></figure><a id="more"></a><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: haystack = &quot;aaaaa&quot;, needle = &quot;bba&quot;</span><br><span class="line">Output: -1</span><br></pre></td></tr></table></figure><p>本题很简单，就是简单的遍历<code>haystack</code> ，根据<code>needle</code>的长度切片比较，若相同则直接返回此时的<code>index</code>，若遍历结束则说明没有找到，返回 -1</p><hr><h3 id="代码实现："><a href="#代码实现：" class="headerlink" title="代码实现："></a>代码实现：</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">strStr</span><span class="params">(self, haystack, needle)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type haystack: str</span></span><br><span class="line"><span class="string">        :type needle: str</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        minLen = len(needle)</span><br><span class="line">        maxLen = len(haystack)</span><br><span class="line">        index = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> index &lt;= maxLen-minLen:</span><br><span class="line">            <span class="keyword">if</span> haystack[index:index+minLen] == needle:</span><br><span class="line">                <span class="keyword">return</span> index</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                index +=<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure><hr><h3 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h3><ul><li><a href="https://leetcode.com/problems/implement-strstr/" target="_blank" rel="noopener">题目链接</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> LeetCode日记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 字符串 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>【medium】Longest Substring Without Repeating Characters</title>
      <link href="/LeetCode-003-Longest%20Substring%20Without%20Repeating%20Characters.html"/>
      <url>/LeetCode-003-Longest%20Substring%20Without%20Repeating%20Characters.html</url>
      
        <content type="html"><![CDATA[<p>Given a string, find the length of the <strong>longest substring</strong> without repeating characters.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;abcabcbb&quot;</span><br><span class="line">Output: 3 </span><br><span class="line">Explanation: The answer is &quot;abc&quot;, with the length of 3.</span><br></pre></td></tr></table></figure><a id="more"></a><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;bbbbb&quot;</span><br><span class="line">Output: 1</span><br><span class="line">Explanation: The answer is &quot;b&quot;, with the length of 1.</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;pwwkew&quot;</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: The answer is &quot;wke&quot;, with the length of 3. </span><br><span class="line">             Note that the answer must be a substring, &quot;pwke&quot; is a subsequence and not a substring.</span><br></pre></td></tr></table></figure><p>首先解读一下题目，要求字符串的最长无重复子串的长度，而不是求无重复子序列（子串要连续，而子序列可以不连续）</p><hr><h3 id="思路分析："><a href="#思路分析：" class="headerlink" title="思路分析："></a>思路分析：</h3><p>本题属于中等难度，我没有想出方法来解决，也没必要死耗，于是打算中等难度的题目先看网上的解决方案，然后理解其思想，自己演算，自己撸码。</p><ul><li>用滑动窗口来解决，即设左右 2 个指针，维持一个窗口，保证窗口内的元素无重复，其实就是前面的快慢指针思想。还要有一个 hashmap 来存窗口内元素和下标的映射关系，方便移动左右指针。从头遍历字符串：<br>若元素不在哈希表内，则直接加入哈希表（移动右指针），即扩大窗口<br>若在哈希表内：<br>​    若该元素在哈希表中对应的下标小于左指针，什么操作都没有<br>​    否则，移动左指针，即缩小窗口<br>​    添加该元素及其下标到哈希表中<br>记录当前窗口大小，判断是否更新结果</li></ul><p><img src="http://m-markdown-image.oss-cn-beijing.aliyuncs.com/2018-12-08-IMG_3726.JPG" alt=""></p><hr><h3 id="代码实现："><a href="#代码实现：" class="headerlink" title="代码实现："></a>代码实现：</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">  :type s: str</span></span><br><span class="line"><span class="string">  :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">hashMap = dict()</span><br><span class="line">        left, right = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        length = len(s)</span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> right &lt; length:</span><br><span class="line">            <span class="keyword">if</span> hashMap:</span><br><span class="line">                <span class="keyword">if</span> s[right] <span class="keyword">in</span> hashMap:</span><br><span class="line">                    <span class="comment">#这种情况第一次写的时候没有考虑，例如 ‘abba’</span></span><br><span class="line">                    <span class="keyword">if</span> left &lt;= hashMap[s[right]]:</span><br><span class="line">                        left = hashMap[s[right]] + <span class="number">1</span></span><br><span class="line">                hashMap[s[right]] = right</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                hashMap[s[left]] = left</span><br><span class="line">                res = <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> (right-left) &gt; res<span class="number">-1</span>:</span><br><span class="line">                res = right-left+<span class="number">1</span></span><br><span class="line">            right += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><hr><h3 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h3><ul><li><a href="https://leetcode.com/problems/longest-substring-without-repeating-characters/" target="_blank" rel="noopener">题目链接</a></li><li><a href="http://www.cnblogs.com/grandyang/p/4480780.html" target="_blank" rel="noopener">LeetCode Longest Substring Without Repeating Characters 最长无重复字符的子串 - Grandyang - 博客园</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> LeetCode日记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 字符串 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>【easy】Search Insert Position</title>
      <link href="/LeetCode-035-Search%20Insert%20Position.html"/>
      <url>/LeetCode-035-Search%20Insert%20Position.html</url>
      
        <content type="html"><![CDATA[<p>Given a sorted array and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order.</p><p>You may assume no duplicates in the array.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,3,5,6], 5</span><br><span class="line">Output: 2</span><br></pre></td></tr></table></figure><a id="more"></a><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,3,5,6], 2</span><br><span class="line">Output: 1</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,3,5,6], 7</span><br><span class="line">Output: 4</span><br></pre></td></tr></table></figure><p><strong>Example 4:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,3,5,6], 0</span><br><span class="line">Output: 0</span><br></pre></td></tr></table></figure><hr><h3 id="思路分析："><a href="#思路分析：" class="headerlink" title="思路分析："></a>思路分析：</h3><ul><li>很容易想到的就是遍历查找，代码很简单，让程序去跑吧，代码见 1.1</li><li>由于题目给的是已经排好序的，所以可以尝试一下折半查找，代码见 2.1</li></ul><hr><h3 id="代码实现："><a href="#代码实现：" class="headerlink" title="代码实现："></a>代码实现：</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">searchInsert</span><span class="params">(self, nums, target)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :type target: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        length = len(nums)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(length):</span><br><span class="line">            <span class="keyword">if</span> nums[i] &gt;= target:</span><br><span class="line">                <span class="keyword">return</span> i</span><br><span class="line">        <span class="keyword">return</span> length</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">searchInsert</span><span class="params">(self, nums, target)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :type target: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        start, end = <span class="number">0</span>, len(nums) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> start &lt; end:</span><br><span class="line">            mid = (start + end) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> nums[mid] &gt; target:</span><br><span class="line">                end = mid - <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> nums[mid] &lt; target:</span><br><span class="line">                start = mid + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> mid</span><br><span class="line">        <span class="comment">#循环结束后start==end</span></span><br><span class="line">        <span class="keyword">if</span> nums[start] &gt;= target:</span><br><span class="line">            <span class="keyword">return</span> start</span><br><span class="line">        <span class="keyword">elif</span> nums[start] &lt; target:</span><br><span class="line">            <span class="keyword">return</span> start + <span class="number">1</span></span><br></pre></td></tr></table></figure><p>但是就提交后的运行时间来看，并没有太大的差距，没有道理啊。于是自行验证，整理代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> time, decimal</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">searchInsert_1</span><span class="params">(self, nums, target)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">  :type nums: List[int]</span></span><br><span class="line"><span class="string">  :type target: int</span></span><br><span class="line"><span class="string">  :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">length = len(nums)</span><br><span class="line">        sum = <span class="number">0</span></span><br><span class="line">        startTime = time.time()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(length):</span><br><span class="line">            sum += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> nums[i] &gt;= target:</span><br><span class="line">                <span class="keyword">return</span> i, sum, time.time() - startTime</span><br><span class="line">        <span class="keyword">return</span> length, sum, time.time() - startTime</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">searchInsert_2</span><span class="params">(self, nums, target)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">  :type nums: List[int]</span></span><br><span class="line"><span class="string">  :type target: int</span></span><br><span class="line"><span class="string">  :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">start, end = <span class="number">0</span>, len(nums) - <span class="number">1</span></span><br><span class="line">        sum = <span class="number">0</span></span><br><span class="line">        startTime = time.time()</span><br><span class="line">        <span class="keyword">while</span> start &lt; end:</span><br><span class="line">            sum += <span class="number">1</span></span><br><span class="line">            mid = (start + end) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> nums[mid] &gt; target:</span><br><span class="line">                end = mid - <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> nums[mid] &lt; target:</span><br><span class="line">                start = mid + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> mid, sum, time.time() - startTime</span><br><span class="line">        <span class="keyword">if</span> nums[start] &gt;= target:</span><br><span class="line">            <span class="keyword">return</span> start, sum, time.time() - startTime</span><br><span class="line">        <span class="keyword">elif</span> nums[start] &lt; target:</span><br><span class="line">            <span class="keyword">return</span> start + <span class="number">1</span>, sum, time.time() - startTime</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    list = np.random.randint(<span class="number">0</span>, <span class="number">1000000</span>, <span class="number">1000000</span>)</span><br><span class="line">    list.sort()</span><br><span class="line">    sol = Solution()</span><br><span class="line">    pos_1, times_1, time_1 = sol.searchInsert_1(list, <span class="number">1999999</span>)</span><br><span class="line">    pos_2, times_2, time_2 = sol.searchInsert_2(list, <span class="number">1999999</span>)</span><br><span class="line">    print(<span class="string">'遍历：位置&#123;&#125;, 查找&#123;&#125;次，用时&#123;&#125;s'</span>.format(pos_1, times_1, time_1))</span><br><span class="line">    print(<span class="string">'折半：位置&#123;&#125;, 查找&#123;&#125;次，用时&#123;&#125;s'</span>.format(pos_2, times_2, decimal.Decimal.from_float(time_2)))</span><br></pre></td></tr></table></figure><p><img src="http://m-markdown-image.oss-cn-beijing.aliyuncs.com/2018-12-08-%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-03%2014.31.04.png" alt=""><br>这里测试的数据集是随机产生的100w整数列表，而且考虑最差的情况，即 target 在最后，那么差距就很明显了，遍历的话要遍历完，而折半只需查找19次，用时也远远比遍历少。关于折半查找的平均时间复杂度为 log(n)</p><hr><h3 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h3><ul><li><a href="https://leetcode.com/problems/search-insert-position/" target="_blank" rel="noopener">题目链接</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> LeetCode日记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 链表 </tag>
            
            <tag> 二分查找 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>写在诞生之初</title>
      <link href="/%E5%86%99%E5%9C%A8%E8%AF%9E%E7%94%9F%E4%B9%8B%E5%88%9D.html"/>
      <url>/%E5%86%99%E5%9C%A8%E8%AF%9E%E7%94%9F%E4%B9%8B%E5%88%9D.html</url>
      
        <content type="html"><![CDATA[<p>其实半年前我就搭过一个博客，开始建的时候激情满满，结果仍旧是3分钟热度，更了几篇就停下了，总是觉得我写的东西太低端，网上一搜一大堆，写这些东西浪费时间。但最近时不时在网上看见一些优秀的博客，其作者也是跟我差不多年龄，而且最开始写的很基础的人大有人在，可以清晰的看到他们的成长轨迹。我突然觉得这样也挺好的，回首能清楚的看到自己学了什么，干了什么，不至于每到年末，都不知道今年到底做了什么。</p><a id="more"></a><p>于是我又开始搜博客搭建方案（和半年前一样），原来采取的是<code>Hexo + github pages</code>，但最近看到了用<code>Netlify</code>来部署博客的，心想总要做点改变吧，嗯，就用<code>Hexo + Netlify</code>！选主题的时候着实又纠结了一把，我这个人对视觉体验有种莫名的执着，于是对主题的美感要求就比较高，好不容易在众多主题中找到了一个<a href="https://github.com/ahonn/hexo-theme-even" target="_blank" rel="noopener"><code>even</code></a>主题，配色很是喜欢，但无奈作者就是没有添加站内搜索功能（个人觉得这个功能非常重要），我自己来定制吧，可惜没那个能力，只好还是选择烂大街的<code>next</code>主题，暂时先这样吧，最近会把笔记迁移到这里来，最后，希望自己这次能把博客持续的更新下去！</p><p><img src="http://m-markdown-image.oss-cn-beijing.aliyuncs.com/2018-12-06-0fc951db7b786ace3b418a36ac2dde14.jpg" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 瞎bb而已 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>【easy】Maximum Subarray</title>
      <link href="/LeetCode-053-Maximum%20Subarray.html"/>
      <url>/LeetCode-053-Maximum%20Subarray.html</url>
      
        <content type="html"><![CDATA[<p>Given an integer array <code>nums</code>, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum.</p><p><strong>Example:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [-2,1,-3,4,-1,2,1,-5,4],</span><br><span class="line">Output: 6</span><br><span class="line">Explanation: [4,-1,2,1] has the largest sum = 6.</span><br></pre></td></tr></table></figure><p>本题是一个求最大子序列和的问题，虽标注为 easy 难度，可是真不简单啊，上网一搜才发现是个经典题。</p><a id="more"></a><hr><h3 id="思路分析："><a href="#思路分析：" class="headerlink" title="思路分析："></a>思路分析：</h3><ul><li><p>暴力方法，我好像也只能想出这种思考容量小的方法了，哎。三重循环，想想就可怕。</p><p>第一层：维护一个窗口的大小，从 0 到数组的长度；</p><p>第二层：确定窗口的起始位置，即从 0 到数组的长度-窗口大小；</p><p>第三层：遍历窗口内的元素并相加，判断是否为最大和。</p></li><li><p>Kadane算法思想（通俗版）:如果从头遍历整个列表，那么每个元素就只有 2 个选择：</p><p>​    1.加入前面的子序列</p><p>​    2.自己另起炉灶，成为另一个子序列的头元素</p><p>那么它将如何选择呢？这时候就要做一个判断：若我加入后，咱们序列的总和比我还小，那我还加入你们干嘛，拖我后退嘛，我要自己另起一个子序列。而若我加入后，咱们序列的总和比我大了，那还说什么呢？赶紧加入啊，大佬带带我。另外维护一个全局的最大和就行了。</p></li></ul><p>[注]：看网上很多说这里的第二种思路就是动态规划（动态规划原来学过，但现在仅存的映像是见过这 4 个字，赶紧偷偷去查下），<strong>动态规划的核心思想就是记住已经求过的解</strong>，详细的可以看下面贴的链接。</p><hr><h3 id="代码实现："><a href="#代码实现：" class="headerlink" title="代码实现："></a>代码实现：</h3><figure class="highlight python"><figcaption><span>1.1</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxSubArray</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        wsize = <span class="number">0</span></span><br><span class="line">        maxSum = nums[<span class="number">0</span>]</span><br><span class="line">        length = len(nums)</span><br><span class="line">        temp = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> wsize &lt; length:</span><br><span class="line">            <span class="keyword">for</span> start <span class="keyword">in</span> range(length - wsize):</span><br><span class="line">                <span class="keyword">for</span> value <span class="keyword">in</span> nums[start:start + wsize + <span class="number">1</span>]:</span><br><span class="line">                    temp += value</span><br><span class="line">                    maxSum = max(temp, maxSum)</span><br><span class="line">                temp = <span class="number">0</span></span><br><span class="line">            wsize += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> maxSum</span><br></pre></td></tr></table></figure><p><img src="http://m-markdown-image.oss-cn-beijing.aliyuncs.com/2018-12-04-%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-04%2014.04.15.png" alt=""></p><p>果不其然超时了，我拿这里测试用例在自己电脑上也跑了大几秒，以后这种 3 重循环的代码还是别写了，太丢人</p><figure class="highlight python"><figcaption><span>2.1</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxSubArray</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        tempSum, maxSum = nums[<span class="number">0</span>], nums[<span class="number">0</span>]</span><br><span class="line">        length = len(nums)</span><br><span class="line">        <span class="keyword">for</span> value <span class="keyword">in</span> nums[<span class="number">1</span>:]:</span><br><span class="line">            tempSum = max(value, value + tempSum)</span><br><span class="line">            maxSum = max(tempSum, maxSum)</span><br><span class="line">        <span class="keyword">return</span> maxSum</span><br></pre></td></tr></table></figure><p>明显优雅了很多，也同样在电脑上跑了一下测试用例，嗖的一下就出来了，瞬间感觉我就是个小学生！我也要变强！充钱行吗？</p><hr><h3 id="推荐阅读："><a href="#推荐阅读：" class="headerlink" title="推荐阅读："></a>推荐阅读：</h3><ul><li><p><a href="https://leetcode.com/problems/maximum-subarray/" target="_blank" rel="noopener">题目链接</a></p></li><li><p><a href="https://en.wikipedia.org/wiki/Maximum_subarray_problem" target="_blank" rel="noopener">Maximum subarray problem</a></p></li><li><a href="https://blog.csdn.net/u013309870/article/details/75193592" target="_blank" rel="noopener">算法-动态规划 Dynamic Programming–从菜鸟到老鸟</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> LeetCode日记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 最大子序列 </tag>
            
            <tag> 经典题 </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>【easy】Plus One</title>
      <link href="/LeetCode-066-Plus%20One.html"/>
      <url>/LeetCode-066-Plus%20One.html</url>
      
        <content type="html"><![CDATA[<p>Given a <strong>non-empty</strong> array of digits representing a non-negative integer, plus one to the integer.</p><p>The digits are stored such that the most significant digit is at the head of the list, and each element in the array contain a single digit.</p><p>You may assume the integer does not contain any leading zero, except the number 0 itself.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,2,3]</span><br><span class="line">Output: [1,2,4]</span><br><span class="line">Explanation: The array represents the integer 123.</span><br></pre></td></tr></table></figure><a id="more"></a><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [4,3,2,1]</span><br><span class="line">Output: [4,3,2,2]</span><br><span class="line">Explanation: The array represents the integer 4321.</span><br></pre></td></tr></table></figure><p>前面做过类似的题，难度比这大，可以看下面贴的链接，共写了 2 种实现，思路前面写过就不写了，这里就直接贴代码，相当于前面的一次回顾吧，温故而知新嘛。</p><hr><h3 id="代码实现："><a href="#代码实现：" class="headerlink" title="代码实现："></a>代码实现：</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">plusOne</span><span class="params">(self, digits)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type digits: List[int]</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        tempStr = <span class="string">''</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> value <span class="keyword">in</span> digits:</span><br><span class="line">            tempStr += str(value)</span><br><span class="line">        tempNum = int(tempStr) + <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> value <span class="keyword">in</span> str(tempNum):</span><br><span class="line">            res.append(int(value))</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p>这个是转换成字符串处理，总感觉有点无脑，我更喜欢下面的进位方法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">plusOne</span><span class="params">(self, digits)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type digits: List[int]</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        flag = <span class="number">1</span></span><br><span class="line">        digits.reverse()</span><br><span class="line">        <span class="keyword">for</span> item <span class="keyword">in</span> enumerate(digits):</span><br><span class="line">            <span class="keyword">if</span> item[<span class="number">1</span>]+flag == <span class="number">10</span>:</span><br><span class="line">                flag = <span class="number">1</span></span><br><span class="line">                digits[item[<span class="number">0</span>]] = <span class="number">0</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                digits[item[<span class="number">0</span>]]+=<span class="number">1</span></span><br><span class="line">                flag = <span class="number">0</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">if</span> digits[<span class="number">-1</span>] == <span class="number">0</span>:</span><br><span class="line">            digits.append(<span class="number">1</span>)</span><br><span class="line">        digits.reverse()</span><br><span class="line">        <span class="keyword">return</span> digits</span><br></pre></td></tr></table></figure><p>这里的进位其实很简单，因为只加 1 ，那么一旦进位不为 1 的话，就可以直接退出了，不会新产生进位了。</p><hr><h3 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h3><ul><li><a href="https://leetcode.com/problems/plus-one/" target="_blank" rel="noopener">题目链接</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> LeetCode日记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 字符串 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>【easy】Add Binary</title>
      <link href="/LeetCode-067-Add%20Binary.html"/>
      <url>/LeetCode-067-Add%20Binary.html</url>
      
        <content type="html"><![CDATA[<p>Given two binary strings, return their sum (also a binary string).</p><p>The input strings are both <strong>non-empty</strong> and contains only characters <code>1</code> or <code>0</code>.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: a = &quot;11&quot;, b = &quot;1&quot;</span><br><span class="line">Output: &quot;100&quot;</span><br></pre></td></tr></table></figure><a id="more"></a><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: a = &quot;1010&quot;, b = &quot;1011&quot;</span><br><span class="line">Output: &quot;10101&quot;</span><br></pre></td></tr></table></figure><p>开始做题之前，我们先弄清题目的意思，<code>Binary</code>是啥意思？（偷偷查一下）原来是二进制，那么题目就是要求做二进制的加法。</p><hr><h3 id="思路分析："><a href="#思路分析：" class="headerlink" title="思路分析："></a>思路分析：</h3><ul><li>首先来个讨巧的方式，即用<code>python</code>中的进制转换，直接转换为 10 进制相加，然后返回二进制的结果，虽然能出结果，但我想这不是出题人的目的。</li><li>跟 066 题又很像，即按位相加，外加一个进位标志，具体看代码吧，不多bb。</li></ul><hr><h3 id="代码实现："><a href="#代码实现：" class="headerlink" title="代码实现："></a>代码实现：</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addBinary</span><span class="params">(self, a, b)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type a: str</span></span><br><span class="line"><span class="string">        :type b: str</span></span><br><span class="line"><span class="string">        :rtype: str</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        temp = int(a, <span class="number">2</span>) + int(b, <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> bin(temp)[<span class="number">2</span>:]</span><br></pre></td></tr></table></figure><p>解释下这里为什么要对结果字符串进行切片，是因为<code>bin()</code>函数返回的字符串的前 2 位表示进制，即是<code>0b</code>，所以要去除。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addBinary</span><span class="params">(self, a, b)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type a: str</span></span><br><span class="line"><span class="string">        :type b: str</span></span><br><span class="line"><span class="string">        :rtype: str</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        a = a[::<span class="number">-1</span>]</span><br><span class="line">        b = b[::<span class="number">-1</span>]</span><br><span class="line">        flag, cursor = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        a_len, b_len = len(a), len(b)</span><br><span class="line">        res = <span class="string">''</span></span><br><span class="line">        <span class="keyword">while</span> cursor &lt; max(a_len, b_len) <span class="keyword">or</span> flag:</span><br><span class="line">            a_value = int(a[cursor]) <span class="keyword">if</span> cursor &lt; a_len <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">            b_value = int(b[cursor]) <span class="keyword">if</span> cursor &lt; b_len <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">            temp = a_value + b_value + flag</span><br><span class="line">            <span class="keyword">if</span> temp &lt; <span class="number">2</span>:</span><br><span class="line">                flag = <span class="number">0</span></span><br><span class="line">                res += str(temp)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                flag = <span class="number">1</span></span><br><span class="line">                res += str(temp<span class="number">-2</span>)</span><br><span class="line">            cursor += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res[::<span class="number">-1</span>]</span><br></pre></td></tr></table></figure><p>这里说一下我写的时候踩的坑：</p><ul><li>对字符串使用了<code>reverse()</code>方法，由于上一题给的是列表，倒转列表用到了这个方法，然后我想字符串也是可迭代对象，应该也是可以用这个方法的，结果报错，于是只能倒着切片。</li><li>第 22 行这里我开始是直接加的 0 ，没有考虑到 <code>temp</code>为 3 的情况，考虑问题不够全面啊！</li></ul><hr><h3 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h3><ul><li><p><a href="https://leetcode.com/problems/add-binary/" target="_blank" rel="noopener">题目链接</a></p></li><li><p><a href="https://www.jianshu.com/p/452bd7ce9056" target="_blank" rel="noopener">Python进制快速转换</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> LeetCode日记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 字符串 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>【easy】Sqrt(x)</title>
      <link href="/LeetCode-069-Sqrt(x).html"/>
      <url>/LeetCode-069-Sqrt(x).html</url>
      
        <content type="html"><![CDATA[<p>Implement <code>int sqrt(int x)</code>.</p><p>Compute and return the square root of <em>x</em>, where <em>x</em> is guaranteed to be a non-negative integer.</p><p>Since the return type is an integer, the decimal digits are truncated and only the integer part of the result is returned.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: 4</span><br><span class="line">Output: 2</span><br></pre></td></tr></table></figure><a id="more"></a><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: 8</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: The square root of 8 is 2.82842..., and since </span><br><span class="line">             the decimal part is truncated, 2 is returned.</span><br></pre></td></tr></table></figure><hr><h3 id="思路分析："><a href="#思路分析：" class="headerlink" title="思路分析："></a>思路分析：</h3><ul><li>原先想的是从 0 开始挨个儿遍历，然后找到其平方最接近且不超过<code>x</code>的数，但经过前面题目的洗礼，像暴力遍历的方法只能想一想而已，千万别去实现，太蠢了。那么这里就用二分查找吧，而且在网上恰巧看到说一个正数<code>x</code>的平方根不会大于$\frac{1}{2}x+1$，那么初始的左右边界就确定了，下面循环判断就好了，具体见代码。</li></ul><p>[注]：其实网上对这题的思路还有一个什么牛顿迭代法，是一个基于迭代的方法，我不太喜欢，就不去实现了。</p><hr><h3 id="代码实现："><a href="#代码实现：" class="headerlink" title="代码实现："></a>代码实现：</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mySqrt</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type x: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        right = (x // <span class="number">2</span>) + <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> left &lt; right:</span><br><span class="line">            mid = (left + right) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> pow(mid, <span class="number">2</span>) &lt; x:</span><br><span class="line">                left = mid+<span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> pow(mid, <span class="number">2</span>) &gt; x:</span><br><span class="line">                right = mid<span class="number">-1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> mid</span><br><span class="line">        <span class="keyword">if</span> pow(left, <span class="number">2</span>) &gt; x:</span><br><span class="line">            <span class="keyword">return</span> left<span class="number">-1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> left</span><br></pre></td></tr></table></figure><p>循环结束后这里的判断很重要，开始我就是直接返回<code>left</code>的值，发现有些情况没有考虑到。</p><hr><h3 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h3><ul><li><a href="https://leetcode.com/problems/sqrtx/" target="_blank" rel="noopener">题目链接</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> LeetCode日记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 二分查找 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>【easy】Min Stack</title>
      <link href="/LeetCode-155-Min%20Stack.html"/>
      <url>/LeetCode-155-Min%20Stack.html</url>
      
        <content type="html"><![CDATA[<p>Design a stack that supports push, pop, top, and retrieving the minimum element in constant time.</p><ul><li>push(x) – Push element x onto stack.</li><li>pop() – Removes the element on top of the stack.</li><li>top() – Get the top element.</li><li>getMin() – Retrieve the minimum element in the stack.</li></ul><p><strong>Example:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">MinStack minStack = new MinStack();</span><br><span class="line">minStack.push(-2);</span><br><span class="line">minStack.push(0);</span><br><span class="line">minStack.push(-3);</span><br><span class="line">minStack.getMin();   --&gt; Returns -3.</span><br><span class="line">minStack.pop();</span><br><span class="line">minStack.top();      --&gt; Returns 0.</span><br><span class="line">minStack.getMin();   --&gt; Returns -2.</span><br></pre></td></tr></table></figure><a id="more"></a><p>开始看到这个题目，觉得挺简单的，因为前面才撸过一遍链表的实现，<code>push</code>就是尾插，<code>pop</code> 和<code>top</code> 都是在尾节点的操作（默认链表的头是栈底元素，收到了前面链表的影响）。但是撸完提交发现超时，修改后提交还是超时，才发现题目明确说了是<code>constant time</code>执行上面的方法，下面记录下心酸历程。</p><hr><h3 id="代码实现："><a href="#代码实现：" class="headerlink" title="代码实现："></a>代码实现：</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StackNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, data, next)</span>:</span></span><br><span class="line">        self.data = data</span><br><span class="line">        self.next = next</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinStack</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        initialize your data structure here.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        self.root = <span class="keyword">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type x: int</span></span><br><span class="line"><span class="string">        :rtype: void</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> self.root == <span class="keyword">None</span>:</span><br><span class="line">            self.root = StackNode(x, <span class="keyword">None</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            cursor = self.root</span><br><span class="line">            <span class="keyword">while</span> cursor.next:</span><br><span class="line">                cursor = cursor.next</span><br><span class="line">            cursor.next = StackNode(x, <span class="keyword">None</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :rtype: void</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        cursor = self.root</span><br><span class="line">        <span class="keyword">if</span> cursor.next:</span><br><span class="line">            <span class="keyword">while</span> cursor.next.next:</span><br><span class="line">                cursor = cursor.next</span><br><span class="line">            cursor.next = <span class="keyword">None</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.root = <span class="keyword">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">top</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        cursor = self.root</span><br><span class="line">        <span class="keyword">while</span> cursor.next:</span><br><span class="line">            cursor = cursor.next</span><br><span class="line">        <span class="keyword">return</span> cursor.data</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getMin</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        cursor = self.root</span><br><span class="line">        minNum = cursor.data</span><br><span class="line">        <span class="keyword">while</span> cursor:</span><br><span class="line">            <span class="keyword">if</span> cursor.data &lt; minNum:</span><br><span class="line">                minNum = cursor.data</span><br><span class="line">            cursor = cursor.next</span><br><span class="line">        <span class="keyword">return</span> minNum</span><br></pre></td></tr></table></figure><p><img src="http://m-markdown-image.oss-cn-beijing.aliyuncs.com/2018-12-08-%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-24%2010.53.58.png" alt=""></p><p>这个是深受前面实现单链表的影响，每个步骤都是“亲力亲为”，而且是将栈底元素视为链表的头，于是每次执行 <code>push</code>、<code>pop</code>、<code>top</code> 方法时，要循环移动到栈顶，<code>getMin</code> 也需要循环整个链表，才能找到最小值，那么这 4 个方法的时间复杂度都是 <code>O(n)</code>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StackNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, data, next)</span>:</span></span><br><span class="line">        self.data = data</span><br><span class="line">        self.next = next</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinStack</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        initialize your data structure here.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        self.root = <span class="keyword">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type x: int</span></span><br><span class="line"><span class="string">        :rtype: void</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> self.root == <span class="keyword">None</span>:</span><br><span class="line">            self.root = StackNode(x, <span class="keyword">None</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            temp = self.root</span><br><span class="line">            self.root = StackNode(x, temp)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :rtype: void</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> self.root.next == <span class="keyword">None</span>:</span><br><span class="line">            self.root = <span class="keyword">None</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.root = self.root.next</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">top</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">return</span> self.root.data</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getMin</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        cursor = self.root</span><br><span class="line">        minNum = cursor.data</span><br><span class="line">        <span class="keyword">while</span> cursor:</span><br><span class="line">            <span class="keyword">if</span> cursor.data &lt; minNum:</span><br><span class="line">                minNum = cursor.data</span><br><span class="line">            cursor = cursor.next</span><br><span class="line">        <span class="keyword">return</span> minNum</span><br></pre></td></tr></table></figure><p>第一次修改时我竟然天真的一位将栈元素视为头就好了，于是有了以上修改，将栈顶元素视为头结点后，发现 <code>push</code>、<code>pop</code>、<code>top</code> 的时间复杂度都降为了<code>O(1)</code>，满足了题目要求，但是<code>getMin</code> 仍然需要遍历一遍，还是不满足要求。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinStack</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        initialize your data structure here.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">self.stack = []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">  :type x: int</span></span><br><span class="line"><span class="string">  :rtype: void</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">preMin = self.stack[<span class="number">-1</span>][<span class="number">1</span>] <span class="keyword">if</span> self.stack <span class="keyword">else</span> <span class="number">2147483647</span></span><br><span class="line">        minNum = min(preMin, x)</span><br><span class="line">        self.stack.append((x, minNum))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">  :rtype: void</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">self.stack.pop()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">top</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">  :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line"><span class="keyword">return</span> self.stack[<span class="number">-1</span>][<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getMin</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">  :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line"><span class="keyword">return</span> self.stack[<span class="number">-1</span>][<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">show</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(self.stack)</span><br></pre></td></tr></table></figure><p>最后不得已在网上看了看实现方法，既然要求时间性能，那就只能牺牲空间性能，于是栈的每个元素其实是一个元祖，第一个元素表示真正的值，第二个表示到当前为止最小的值，那么执行上述方法时候时间复杂度都是<code>O(1)</code>。当然，也可以用另外的一个栈来保存最小值，这里为了方便就直接用一个栈。算法还有改进的空间，例如当最小值重复时不需要存入栈以节省空间，具体实现看下面链接。</p><hr><h3 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h3><ul><li><a href="https://leetcode.com/problems/min-stack/" target="_blank" rel="noopener">题目链接</a></li><li><a href="https://blog.csdn.net/coder_orz/article/details/52047023" target="_blank" rel="noopener">155. Min Stack [easy] (Python)</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> LeetCode日记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 栈 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>【easy】Climbing Stairs</title>
      <link href="/LeetCode-070-Climbing%20Stairs.html"/>
      <url>/LeetCode-070-Climbing%20Stairs.html</url>
      
        <content type="html"><![CDATA[<p>You are climbing a stair case. It takes <em>n</em> steps to reach to the top.</p><p>Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?</p><p><strong>Note:</strong> Given <em>n</em> will be a positive integer.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: 2</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: There are two ways to climb to the top.</span><br><span class="line">1. 1 step + 1 step</span><br><span class="line">2. 2 steps</span><br></pre></td></tr></table></figure><a id="more"></a><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input: 3</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: There are three ways to climb to the top.</span><br><span class="line">1. 1 step + 1 step + 1 step</span><br><span class="line">2. 1 step + 2 steps</span><br><span class="line">3. 2 steps + 1 step</span><br></pre></td></tr></table></figure><p>记得爬楼梯的问题在我最早开始学数据结构的时候做过，好像那时候没做出来…这里的爬楼梯好像做了一定的简化，即每次只能爬 1 步或 2 步，比较好处理。</p><hr><h3 id="思路分析："><a href="#思路分析：" class="headerlink" title="思路分析："></a>思路分析：</h3><ul><li><p>首先说说我自己的想法，对应代码块 1.1，辅以图说明：</p><p><img src="http://m-markdown-image.oss-cn-beijing.aliyuncs.com/2018-12-10-IMG_3737.JPG" alt=""></p></li><li><p>递归法，可以发现要爬到第 n 阶，必须是从第 n-1 或 n-2 阶上来的，那么递归式就出来了:$f(n) = f(n-1)+f(n-2)$，代码也很简洁，貌似递归的代码都异常简洁，就是效率太差，见代码块 2.1</p></li><li><p>基于动态规划的思想，自底向上进行求解，具体见代码块 3.1</p></li></ul><hr><h3 id="代码实现："><a href="#代码实现：" class="headerlink" title="代码实现："></a>代码实现：</h3><blockquote><p>1.1</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> scipy.special <span class="keyword">import</span> comb</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">climbStairs</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        a = n // <span class="number">2</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, a+<span class="number">1</span>):</span><br><span class="line">            res += comb(i+(n-i*<span class="number">2</span>), i)</span><br><span class="line">        <span class="keyword">return</span> int(res+<span class="number">1</span>)</span><br></pre></td></tr></table></figure><blockquote><p>2.1</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">climbStairs</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> n &lt;= <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> n</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> self.climbStairs(n<span class="number">-1</span>) + self.climbStairs(n<span class="number">-2</span>)</span><br></pre></td></tr></table></figure><p><img src="http://m-markdown-image.oss-cn-beijing.aliyuncs.com/2018-12-10-%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-10%2009.48.18.png" alt=""></p><p>速度实在太慢，算到 35 就已经超时了。其实分析一下递归的求解过程就知道为什么这么慢了：</p><p><img src="http://m-markdown-image.oss-cn-beijing.aliyuncs.com/2018-12-11-IMG_3739.JPG" alt=""></p><p>可以看到有很多重复计算的值，倒置计算效率低下，虽然代码简洁，但并没有什么卵用。</p><blockquote><p>3.1</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">climbStairs</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        f = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">        <span class="keyword">if</span> n &lt;= <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> f[n]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>, n+<span class="number">1</span>):</span><br><span class="line">                f.append(f[i<span class="number">-1</span>]+ f[i<span class="number">-2</span>])</span><br><span class="line">            <span class="keyword">return</span> f[n]</span><br></pre></td></tr></table></figure><p>关于动态规划的思想前面 <a href="https://smileyx.top/leetcode-053-maximum%20subarray">Maximum Subarray</a> 中也用到过。</p><hr><h3 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h3><ul><li><a href="https://leetcode.com/problems/climbing-stairs/" target="_blank" rel="noopener">题目链接</a></li><li><a href="https://blog.csdn.net/lanchunhui/article/details/51824602" target="_blank" rel="noopener">Python 排列组合的计算</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> LeetCode日记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 动态规划 </tag>
            
            <tag> 递归 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>【easy】Length of Last Word</title>
      <link href="/LeetCode-058-Length%20of%20Last%20Word.html"/>
      <url>/LeetCode-058-Length%20of%20Last%20Word.html</url>
      
        <content type="html"><![CDATA[<p>Given a string <em>s</em> consists of upper/lower-case alphabets and empty space characters <code>&#39; &#39;</code>, return the length of last word in the string.</p><p>If the last word does not exist, return 0.</p><p><strong>Note:</strong> A word is defined as a character sequence consists of non-space characters only.</p><p><strong>Example:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;Hello World&quot;</span><br><span class="line">Output: 5</span><br></pre></td></tr></table></figure><p>乍一看很简单，也确实简单，只不过给的栗子只有一个标准情况，而我考虑问题又不全面，所以并没有一次提交成功，注意如果是<code>&quot;a &quot;</code>，应该返回 1 而不是 0，<code>&quot;a  b  &quot;</code>也是返回 1 ，注意到这些情况后就不难了。</p><a id="more"></a><hr><h3 id="代码实现："><a href="#代码实现：" class="headerlink" title="代码实现："></a>代码实现：</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lengthOfLastWord</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        s = s.rstrip()</span><br><span class="line">        <span class="keyword">if</span> s:</span><br><span class="line">            wordList = s.split(<span class="string">' '</span>)</span><br><span class="line">            print(wordList)</span><br><span class="line">            <span class="keyword">return</span> len(wordList[<span class="number">-1</span>]) <span class="keyword">if</span> wordList[<span class="number">-1</span>] <span class="keyword">else</span> len(wordList[<span class="number">-2</span>])</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br></pre></td></tr></table></figure><hr><h3 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h3><ul><li><a href="https://leetcode.com/problems/length-of-last-word/" target="_blank" rel="noopener">题目链接</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> LeetCode日记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 字符串 </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
