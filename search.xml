<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>【medium】4Sum</title>
      <link href="/LeetCode-018-4Sum.html"/>
      <url>/LeetCode-018-4Sum.html</url>
      
        <content type="html"><![CDATA[<p>Given an array <code>nums</code> of <em>n</em> integers and an integer <code>target</code>, are there elements <em>a</em>, <em>b</em>, <em>c</em>, and <em>d</em> in <code>nums</code> such that <em>a</em> + <em>b</em> + <em>c</em> + <em>d</em> = <code>target</code>? Find all unique quadruplets in the array which gives the sum of <code>target</code>.</p><p><strong>Note:</strong></p><p>The solution set must not contain duplicate quadruplets.</p><p><strong>Example:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Given array nums = [1, 0, -1, 0, -2, 2], and target = 0.</span><br><span class="line"></span><br><span class="line">A solution set is:</span><br><span class="line">[</span><br><span class="line">  [-1,  0, 0, 1],</span><br><span class="line">  [-2, -1, 1, 2],</span><br><span class="line">  [-2,  0, 0, 2]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><a id="more"></a><hr><h3 id="思路分析："><a href="#思路分析：" class="headerlink" title="思路分析："></a>思路分析：</h3><p>- </p>]]></content>
      
      
      <categories>
          
          <category> LeetCode日记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 递归 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>【medium】Letter Combinations of a Phone Number</title>
      <link href="/LeetCode-017-Letter%20Combinations%20of%20a%20Phone%20Number.html"/>
      <url>/LeetCode-017-Letter%20Combinations%20of%20a%20Phone%20Number.html</url>
      
        <content type="html"><![CDATA[<p>Given a string containing digits from <code>2-9</code> inclusive, return all possible letter combinations that the number could represent.</p><p>A mapping of digit to letters (just like on the telephone buttons) is given below. Note that 1 does not map to any letters.</p><p><img src="http://m-markdown-image.oss-cn-beijing.aliyuncs.com/2018-12-24-200px-Telephone-keypad2.svg.png" alt=""></p><p><strong>Example:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;23&quot;</span><br><span class="line">Output: [&quot;ad&quot;, &quot;ae&quot;, &quot;af&quot;, &quot;bd&quot;, &quot;be&quot;, &quot;bf&quot;, &quot;cd&quot;, &quot;ce&quot;, &quot;cf&quot;].</span><br></pre></td></tr></table></figure><p><strong>Note:</strong></p><p>Although the above answer is in lexicographical order, your answer could be in any order you want.</p><a id="more"></a><hr><h3 id="思路分析："><a href="#思路分析：" class="headerlink" title="思路分析："></a>思路分析：</h3><ul><li>迭代法，挨个遍历，列出所有的组合，具体见代码 1.1</li><li>递归法，这里用了一个<code>level</code>变量来表示当前字符串组合的长度，因为其长度不可能大于所给数字<code>digits</code>的长度，所以在递归中首先判断<code>level</code>的值，如果等于<code>digits</code>的长度了，说明已经组合完成，将<code>temp_res</code>加入<code>res</code>，然后<code>return</code>，代码见 2.1</li></ul><hr><h3 id="代码实现："><a href="#代码实现：" class="headerlink" title="代码实现："></a>代码实现：</h3><blockquote><p>1.1 迭代法</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">letterCombinations</span><span class="params">(self, digits)</span>:</span></span><br><span class="line">        digit_letters_map = &#123;<span class="string">'2'</span>: <span class="string">'abc'</span>, <span class="string">'3'</span>: <span class="string">'def'</span>, <span class="string">'4'</span>: <span class="string">'ghi'</span>, <span class="string">'5'</span>: <span class="string">'jkl'</span>,</span><br><span class="line">                             <span class="string">'6'</span>: <span class="string">'mno'</span>, <span class="string">'7'</span>: <span class="string">'pqrs'</span>, <span class="string">'8'</span>: <span class="string">'tuv'</span>, <span class="string">'9'</span>: <span class="string">'wxyz'</span>&#125;</span><br><span class="line">        temp_res = []</span><br><span class="line">        <span class="keyword">for</span> t <span class="keyword">in</span> range(len(digits)):</span><br><span class="line">            letters = digit_letters_map[digits[t]]</span><br><span class="line">            <span class="keyword">for</span> letter <span class="keyword">in</span> letters:</span><br><span class="line">                <span class="keyword">if</span> t == <span class="number">0</span>:</span><br><span class="line">                    temp_res.append(letter)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">for</span> index <span class="keyword">in</span> range(len(temp_res)):</span><br><span class="line">                        <span class="keyword">if</span> len(temp_res[index]) == t:</span><br><span class="line">                            temp_res[index] += letter</span><br><span class="line">                        <span class="keyword">else</span>:</span><br><span class="line">                            temp_res.append(temp_res[index][:<span class="number">-1</span>] + letter)</span><br><span class="line">        <span class="keyword">return</span> list(set(temp_res))</span><br></pre></td></tr></table></figure><p>可以看到我的代码里<code>if</code>判断尤其多，而好的算法好像就很简单，<code>if</code>判断感觉有点打补丁的意思，补丁太多就显得很烂。这几个循环写的时候弄了好久，特别是第三个循环中的内容。</p><blockquote><p>2.1 递归法</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">letterCombinations</span><span class="params">(self, digits)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> len(digits) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        digit_letters_map = &#123;<span class="string">'2'</span>: <span class="string">'abc'</span>, <span class="string">'3'</span>: <span class="string">'def'</span>, <span class="string">'4'</span>: <span class="string">'ghi'</span>, <span class="string">'5'</span>: <span class="string">'jkl'</span>,</span><br><span class="line">                             <span class="string">'6'</span>: <span class="string">'mno'</span>, <span class="string">'7'</span>: <span class="string">'pqrs'</span>, <span class="string">'8'</span>: <span class="string">'tuv'</span>, <span class="string">'9'</span>: <span class="string">'wxyz'</span>&#125;</span><br><span class="line">        res = []</span><br><span class="line">        self.letterCombinationsDFS(digits, digit_letters_map, <span class="number">0</span>, <span class="string">''</span>, res)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">letterCombinationsDFS</span><span class="params">(self, digits, dict, level, temp_res, res)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> level == len(digits):</span><br><span class="line">            res.append(temp_res)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        digit_letters = dict[digits[level]]</span><br><span class="line">        <span class="keyword">for</span> index <span class="keyword">in</span> range(len(digit_letters)):</span><br><span class="line">            self.letterCombinationsDFS(digits, dict, level + <span class="number">1</span>, temp_res + digit_letters[index], res)</span><br></pre></td></tr></table></figure><p>递归法的实现在看答案时还是不好理解，看了好久才算摸到了门道，算是默写出了代码，但明显不是真正掌握，随后复习的时候需要重点看一下。</p><hr><h3 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h3><ul><li><a href="https://leetcode.com/problems/letter-combinations-of-a-phone-number/" target="_blank" rel="noopener">题目链接</a></li><li><a href="http://www.cnblogs.com/grandyang/p/4452220.html" target="_blank" rel="noopener">[LeetCode] Letter Combinations of a Phone Number 电话号码的字母组合</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> LeetCode日记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 递归 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>【medium】3Sum Closest</title>
      <link href="/LeetCode-016-3Sum%20Closest.html"/>
      <url>/LeetCode-016-3Sum%20Closest.html</url>
      
        <content type="html"><![CDATA[<p>Given an array <code>nums</code> of <em>n</em> integers and an integer <code>target</code>, find three integers in <code>nums</code> such that the sum is closest to <code>target</code>. Return the sum of the three integers. You may assume that each input would have exactly one solution.</p><p><strong>Example:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Given array nums = [-1, 2, 1, -4], and target = 1.</span><br><span class="line"></span><br><span class="line">The sum that is closest to the target is 2. (-1 + 2 + 1 = 2).</span><br></pre></td></tr></table></figure><a id="more"></a><hr><h3 id="思路分析："><a href="#思路分析：" class="headerlink" title="思路分析："></a>思路分析：</h3><ul><li>采取和上一题一样的方案，即先排序，然后先取一个数出来，随后用前后指针去遍历，只不过这里不是找具体的数，而是要距离最小，于是引入了一个<code>gap</code>变量来保存距离，具体见代码 1.1</li></ul><hr><h3 id="代码实现："><a href="#代码实现：" class="headerlink" title="代码实现："></a>代码实现：</h3><blockquote><p>1.1</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">threeSumClosest</span><span class="params">(self, nums, target)</span>:</span></span><br><span class="line">        nums.sort()</span><br><span class="line">        picked = set()</span><br><span class="line">        gap = <span class="number">10000</span></span><br><span class="line">        closest_sum = <span class="number">10000</span></span><br><span class="line">        <span class="keyword">for</span> index <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">            <span class="keyword">if</span> nums[index] <span class="keyword">in</span> picked:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            left_index = index + <span class="number">1</span></span><br><span class="line">            right_index = len(nums) - <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> left_index &lt; right_index:</span><br><span class="line">                temp_sum = nums[index] + nums[left_index] + nums[right_index]</span><br><span class="line">                temp_gap = abs(temp_sum - target)</span><br><span class="line">                <span class="keyword">if</span> temp_sum &gt; target:</span><br><span class="line">                    right_index -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">elif</span> temp_sum &lt; target:</span><br><span class="line">                    left_index += <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    gap = temp_gap</span><br><span class="line">                    closest_sum = temp_sum</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                <span class="keyword">if</span> temp_gap &lt; gap:</span><br><span class="line">                    gap = temp_gap</span><br><span class="line">                    closest_sum = temp_sum</span><br><span class="line">            picked.add(nums[index])</span><br><span class="line">        <span class="keyword">return</span> closest_sum</span><br></pre></td></tr></table></figure><p>和上一题的实现很像，只不过在前面的剪枝部分少了一个条件，这里不能碰见正数就<code>break</code>，需要遍历完。另外要注意距离<code>gap</code>要用绝对值。</p><hr><h3 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h3><ul><li><a href="https://leetcode.com/problems/3sum-closest/" target="_blank" rel="noopener">题目链接</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> LeetCode日记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> n-sum 问题 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>【medium】3Sum</title>
      <link href="/LeetCode-015-3Sum.html"/>
      <url>/LeetCode-015-3Sum.html</url>
      
        <content type="html"><![CDATA[<p>Given an array <code>nums</code> of <em>n</em> integers, are there elements <em>a</em>, <em>b</em>, <em>c</em> in <code>nums</code> such that <em>a</em> + <em>b</em> + <em>c</em> = 0? Find all unique triplets in the array which gives the sum of zero.</p><p><strong>Note:</strong></p><p>The solution set must not contain duplicate triplets.</p><p><strong>Example:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Given array nums = [-1, 0, 1, 2, -1, -4],</span><br><span class="line"></span><br><span class="line">A solution set is:</span><br><span class="line">[</span><br><span class="line">  [-1, 0, 1],</span><br><span class="line">  [-1, -1, 2]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><a id="more"></a><hr><h3 id="思路分析："><a href="#思路分析：" class="headerlink" title="思路分析："></a>思路分析：</h3><ul><li>前面做过类似的 2 个数相加，<a href="https://smileyx.top/leetcode-002-add%20two%20numbers">LeetCode-001-Two Sum</a>，这里要更复杂，三个数相加，那么可以先拿出一个数，剩下的两个数利用前面的方法来找，见代码块 1.1</li><li>也是和前面一样，需要先取出一个元素，然后去寻找剩下的 2 个数相加等于<code>target</code>，因为是三数相加等于 0 ，那么<code>target</code>应为前面取出的数的相反数。再操作之前，应该将给的<code>nums</code>排个序，然后利用前后指针的思想，初始化时前指针指向当前取出元素的下一个，后指针指向末尾，因为现在列表是有序的，那么当前后指针元素相加大于<code>target</code>时，很明显应该将后指针向前移动一位（意味着元素变小），小于<code>target</code>时同理将前指针向后移动一位，具体见代码 2.1</li></ul><hr><h3 id="代码实现："><a href="#代码实现：" class="headerlink" title="代码实现："></a>代码实现：</h3><blockquote><p>1.1</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">threeSum</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        temp_res = []</span><br><span class="line">        <span class="keyword">for</span> index <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">            nums_copy = nums[:]</span><br><span class="line">            nums_copy.pop(index)</span><br><span class="line">            sub_list =  self.twoSum(nums_copy, -nums[index])</span><br><span class="line">            <span class="keyword">if</span> sub_list:</span><br><span class="line">                <span class="keyword">for</span> sub <span class="keyword">in</span> sub_list:</span><br><span class="line">                    sub.insert(<span class="number">0</span>, nums[index])</span><br><span class="line">                    sub.sort()</span><br><span class="line">                    temp_res.append(sub)</span><br><span class="line">        temp_res = list(set(str(item) <span class="keyword">for</span> item <span class="keyword">in</span> temp_res))</span><br><span class="line">        res = [eval(item) <span class="keyword">for</span> item <span class="keyword">in</span> temp_res]</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">twoSum</span><span class="params">(self, list, target)</span>:</span></span><br><span class="line">        dict = &#123;&#125;</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> index, value <span class="keyword">in</span> enumerate(list):</span><br><span class="line">            <span class="keyword">if</span> target-value <span class="keyword">in</span> dict.values():</span><br><span class="line">                res.append([target-value, value])</span><br><span class="line">            dict[index] = value</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p>可以看到这段代码的时间复杂度好像是$O(n^{2})$，提交后果然<code>TLE</code>，但既然选择贴上来肯定就是有价值的，可以看到在 13 行做了一个去重的操作，但这个去重卡了好久，开始想的是直接用<code>set</code>来去重，代码就是这样的：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">temp_res = set(temp_res)</span><br></pre></td></tr></table></figure><p>但报错<code>TypeError: unhashable type: &#39;list&#39;</code>，特意去查了什么意思。原来<code>set</code>对传入的参数有要求：<strong>是可迭代类型，迭代的每个元素都是可哈希的。</strong>原来我一直以为传入一个可迭代的对象就好了，受到<code>set([1, 2, 3])</code>的影响，而这里<code>temp_res</code>的格式是<code>[[], [],..]</code>（列表的嵌套），满足了第一个条件：是可迭代对象，但是迭代出来的单个元素还是<code>list</code>，而<code>list</code>是不可哈希的，至此才弄清了出错的原因。<strong>解决方案：将嵌套在里面的<code>list</code>转成字符串（字符串是可哈希的），然后再利用<code>set</code>去重，最后再用<code>eval</code>函数将字符串恢复成列表。</strong></p><p>[注]：<code>list、set、dict</code>是不可哈希的，<code>int、float、str、tuple</code>是可哈希的</p><blockquote><p>2.1</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">threeSum</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        nums.sort()</span><br><span class="line">        picked = set()</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> index <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">            <span class="keyword">if</span> nums[index] &gt; <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">if</span> nums[index] <span class="keyword">in</span> picked:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            left_cursor = index + <span class="number">1</span></span><br><span class="line">            right_cursor = len(nums) - <span class="number">1</span></span><br><span class="line">            target = -nums[index]</span><br><span class="line">            <span class="keyword">while</span> left_cursor &lt; right_cursor:</span><br><span class="line">                <span class="keyword">if</span> nums[left_cursor] + nums[right_cursor] &lt; target:</span><br><span class="line">                    left_cursor += <span class="number">1</span></span><br><span class="line">                <span class="keyword">elif</span> nums[left_cursor] + nums[right_cursor] &gt; target:</span><br><span class="line">                    right_cursor -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    res.append([nums[index], nums[left_cursor], nums[right_cursor]])</span><br><span class="line">                    left_cursor += <span class="number">1</span></span><br><span class="line">                    right_cursor -= <span class="number">1</span></span><br><span class="line">            picked.add(nums[index])</span><br><span class="line">        res = list(set(str(item) <span class="keyword">for</span> item <span class="keyword">in</span> res))</span><br><span class="line">        res = [eval(item) <span class="keyword">for</span> item <span class="keyword">in</span> res]</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p>可以看到我做了两个剪枝优化：</p><p>①第一步取元素的时候并没有遍历完<code>nums</code>，因为要求和等于 0 ，要么三个数都为 0 ，要么就是有正有负，而这时<code>nums</code>是有序的，当我取第一个值都大于 0 时，后面就不用找了，不可能和为 0 了，直接<code>break</code>就好。</p><p>②记录前面已经取出的值，如果如果再碰到这个值可以直接跳过，减少一些重复项。</p><p>开始我以为这里不需要单独的去重了，因为循环中已经避免了。但提交后碰到这么个栗子：<code>nums = [[-2,0,0,2,2]]</code>，还是会出现重复值，还是乖乖的加上了 24、25 两行代码。</p><hr><h3 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h3><ul><li><a href="https://leetcode.com/problems/3sum/" target="_blank" rel="noopener">题目链接</a></li><li><a href="https://segmentfault.com/q/1010000000394830" target="_blank" rel="noopener">segmentfault回答</a></li><li><a href="http://www.chenxm.cc/article/541.html" target="_blank" rel="noopener">python 字典列表/列表套字典 去重重复的字典数据</a></li><li><a href="https://blog.csdn.net/lanchunhui/article/details/50955238" target="_blank" rel="noopener">Python debug——TypeError: unhashable type（list/set/dict）</a></li><li><a href="https://blog.csdn.net/zhanh1218/article/details/37562167" target="_blank" rel="noopener">Python:eval的妙用和滥用</a></li><li><a href="http://www.cnblogs.com/grandyang/p/4481576.html" target="_blank" rel="noopener">[LeetCode] 3Sum 三数之和</a></li><li><a href="https://segmentfault.com/a/1190000003740669" target="_blank" rel="noopener">[Leetcode] 3Sum 4Sum 3Sum Closet 多数和</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> LeetCode日记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> n-sum 问题 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>记一次用Flask搭建简单博客</title>
      <link href="/%E8%AE%B0%E4%B8%80%E6%AC%A1%E7%94%A8Flask%E6%90%AD%E5%BB%BA%E7%AE%80%E5%8D%95%E5%8D%9A%E5%AE%A2.html"/>
      <url>/%E8%AE%B0%E4%B8%80%E6%AC%A1%E7%94%A8Flask%E6%90%AD%E5%BB%BA%E7%AE%80%E5%8D%95%E5%8D%9A%E5%AE%A2.html</url>
      
        <content type="html"><![CDATA[<p><img src="http://m-markdown-image.oss-cn-beijing.aliyuncs.com/2018-12-18-63858f3716f4ddf6047e8921d2d86418.jpg" alt=""></p><a id="more"></a><p>本篇基于这个<a href="https://blog.miguelgrinberg.com/post/the-flask-mega-tutorial-part-i-hello-world" target="_blank" rel="noopener">教程</a>，属于照葫芦画瓢，但我相信会得到一些东西！</p><h3 id="Day-1"><a href="#Day-1" class="headerlink" title="Day 1"></a>Day 1</h3><p>从学到第 3 节才有写本篇的想法，那就从这里开始吧，前 3 节的内容还比较容易，首先就是安装，我是用 <code>conda</code> 创建了另一个<code>python</code>的虚拟环境<code>flaskBlog</code>，在这个环境中安装<code>flask</code>，也是作者推荐的做法。然后创建项目目录，并开启<code>flask</code>服务，于是有了标志的<code>Hello, World</code>页面。</p><p>第 2 节讲的是模板的应用，首先创建基础的模板页面，即所有页面都应该有的元素丢在这里面，有点父类的意思。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    &#123;% if title %&#125;</span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>&#123;&#123; title &#125;&#125; blog<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    &#123;% else %&#125;</span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span> Flask blog<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    &#123;% endif %&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span>&gt;</span>Flask Blog: <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"/index"</span>&gt;</span>Home<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">hr</span>&gt;</span></span><br><span class="line">        &#123;% block content %&#125;&#123;% endblock %&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>重要的就是这个<code>block</code>语句，<code>base.html</code>只写了公共的元素，后面的页面直接继承该模板，然后在对应的<code>block</code>中添加自己特有的元素就好，例如这里的<code>index.html</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;% extends "base.html" %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% block content %&#125;</span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hi, &#123;&#123; user.userName &#125;&#125;!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    &#123;% for post in posts %&#125;</span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; post.author.userName &#125;&#125; says: <span class="tag">&lt;<span class="name">b</span>&gt;</span>&#123;&#123; post.body &#125;&#125;<span class="tag">&lt;/<span class="name">b</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    &#123;% endfor %&#125;</span><br><span class="line">&#123;% endblock %&#125;</span><br></pre></td></tr></table></figure><p>可以看到顶部直接<code>extends</code>，在对应的<code>block</code>中写上欢迎信息，注意上面的<code>block</code>的名字是<code>content</code>，则下面继承时也应该是<code>content</code>，这样如果有多个<code>block</code>，则可以根据名字来对应。</p><p>第 3 节讲到了表单，这里并不是用<code>html</code>原生的表单，而是用的第三方库<code>Flask-WTF</code>，这个库可以用<code>python</code>的<code>class</code>来表示表单，面向对象嘛，具体做法就是：</p><p>①创建<code>forms.py</code>，以后的表单都写在该文件中</p><p>②创建<code>LoginForm class</code>，里面的变量就是登录表单的元素，例如这里我先写了账户、密码、记住我、登录四个元素</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> flask_wtf <span class="keyword">import</span> FlaskForm</span><br><span class="line"><span class="keyword">from</span> wtforms <span class="keyword">import</span> StringField, PasswordField, BooleanField, SubmitField</span><br><span class="line"><span class="keyword">from</span> wtforms.validators <span class="keyword">import</span> DataRequired</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LoginForm</span><span class="params">(FlaskForm)</span>:</span></span><br><span class="line">    userName = StringField(<span class="string">'用户名:'</span>, validators=[DataRequired()])</span><br><span class="line">    userPwd = PasswordField(<span class="string">'密码:'</span>, validators=[DataRequired()])</span><br><span class="line">    rememberMe = BooleanField(<span class="string">'记住我'</span>)</span><br><span class="line">    submit = SubmitField(<span class="string">'登录'</span>)</span><br></pre></td></tr></table></figure><p>③有了逻辑上的登录表单，接下来就是编写登录页面<code>login.html</code>，同样需继承自<code>base.html</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&#123;% extends 'base.html' %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% block content %&#125;</span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>登录<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">""</span> <span class="attr">method</span>=<span class="string">"post"</span> <span class="attr">novalidate</span>&gt;</span></span><br><span class="line">        &#123;&#123; form.hidden_tag() &#125;&#125;</span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">            &#123;&#123; form.userName.label &#125;&#125;<span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">            &#123;&#123; form.userName(size=20) &#125;&#125;<span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">            &#123;% for error in form.userName.errors %&#125;</span><br><span class="line">            <span class="tag">&lt;<span class="name">span</span> <span class="attr">style</span>=<span class="string">"color: red;"</span>&gt;</span>[&#123;&#123; error &#125;&#125;]<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">            &#123;% endfor %&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">            &#123;&#123; form.userPwd.label &#125;&#125;<span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">            &#123;&#123; form.userPwd(size=20) &#125;&#125;<span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">            &#123;% for error in form.userPwd.errors %&#125;</span><br><span class="line">            <span class="tag">&lt;<span class="name">span</span> <span class="attr">style</span>=<span class="string">"color: red"</span>&gt;</span>[&#123;&#123; error &#125;&#125;]<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">            &#123;% endfor %&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">            &#123;&#123; form.rememberMe() &#125;&#125;</span><br><span class="line">            &#123;&#123; form.rememberMe.label &#125;&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; form.submit() &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line">&#123;% endblock %&#125;</span><br></pre></td></tr></table></figure><p>④有了上面两部的基础，剩下的就是配置路由了，当路由为<code>/login</code>时，应当渲染登录页面，并且在点击登录时可以接收到前端提交的数据，但暂时不做处理，直接显示在页面上。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@app.route('/login', methods=['GET','POST'])</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">login</span><span class="params">()</span>:</span></span><br><span class="line">    form = LoginForm()</span><br><span class="line">    <span class="keyword">if</span> form.validate_on_submit():</span><br><span class="line">        flash(<span class="string">'userName is:&#123;&#125;, userPwd is:&#123;&#125;'</span>.</span><br><span class="line">              format(form.userName.data, form.userPwd.data))</span><br><span class="line">        <span class="keyword">return</span> redirect(url_for(<span class="string">'index'</span>))</span><br><span class="line">    <span class="keyword">return</span> render_template(<span class="string">'login.html'</span>, title=<span class="string">'登录'</span>, form=form)</span><br></pre></td></tr></table></figure><p>注意这里的路由函数中多了一个<code>methods</code>参数，并且我把<code>GET</code>和<code>POST</code>都填上去了，目的是为了该路由方法可以处理这两种请求。这里用<code>flash</code>想将数据显示到页面上，那么页面上也要有相应的坑啊，于是需要修改<code>base.html</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"># ...</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        Flask Blog:</span><br><span class="line">        <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"&#123;&#123; url_for('index') &#125;&#125;"</span>&gt;</span>主页<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"&#123;&#123; url_for('login') &#125;&#125;"</span>&gt;</span>登录<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">hr</span>&gt;</span></span><br><span class="line">    &#123;% with messages = get_flashed_messages() %&#125;</span><br><span class="line">        &#123;% if messages %&#125;</span><br><span class="line">            <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">                &#123;% for message in messages %&#125;</span><br><span class="line">                    <span class="tag">&lt;<span class="name">li</span>&gt;</span>&#123;&#123; message &#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">                &#123;% endfor %&#125;</span><br><span class="line">            <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">        &#123;% endif %&#125;</span><br><span class="line">    &#123;% endwith %&#125;</span><br><span class="line">    &#123;% block content %&#125;</span><br><span class="line">    &#123;% endblock %&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><hr><h3 id="Day-2"><a href="#Day-2" class="headerlink" title="Day 2"></a>Day 2</h3><p>今天做了第 4 节的内容，创建数据库，采用的轻量级的<code>SQLite</code>，并使用<code>Flask-SQLAlchemy</code>插件使用面向对象的概念来操作数据库，并添加<code>Flask-Migrate</code>来应对今后有可能的数据迁移，暂时可能只是安装和配置完而已，并没有真正的用到。</p><p><code>ORM</code>还真是第一次了解到，学了几年的面向对象编程，竟然没想到数据库也有面向对象的方式，原来一谈到操作数据库首先冒出来的就是<code>select * from XX</code>，而<code>ORM（Object-relational mapping）</code>可以让我们以操作对象的方式操作数据库，具体介绍可以看：<a href="https://segmentfault.com/a/1190000011642533" target="_blank" rel="noopener">什么是 ORM ？（segmentfault）</a>、<a href="https://stackoverflow.com/questions/1279613/what-is-an-orm-and-where-can-i-learn-more-about-it" target="_blank" rel="noopener">stackoverflow 回答</a></p><p>现在就应该设计数据库的表了，暂时就只需要 2 张表，一张<code>user</code>表和一张<code>post</code>表，表结构如下：</p><p><img src="http://m-markdown-image.oss-cn-beijing.aliyuncs.com/2018-12-19-%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-19%2022.09.47.png" alt=""></p><p><code>post</code>表中用一个外键<code>userId</code>把文章和用户联系起来，一个用户可以写多篇文章，所以他们的关系明显是<code>1:n</code>，既然<code>ORM</code>是面向对象的方式，那么即<strong>意味着一张表就对应着一个类，表中的一条记录就是这个类的一个实体</strong>，所以接下来该创建<code>user</code>类和<code>post</code>类了：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> app <span class="keyword">import</span> db</span><br><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span><span class="params">(db.Model)</span>:</span></span><br><span class="line">    id = db.Column(db.Integer, primary_key=<span class="keyword">True</span>)</span><br><span class="line">    userName = db.Column(db.String(<span class="number">64</span>), index=<span class="keyword">True</span>, unique=<span class="keyword">True</span>)</span><br><span class="line">    userPwd = db.Column(db.String(<span class="number">128</span>))</span><br><span class="line">    phone = db.Column(db.Integer, index=<span class="keyword">True</span>, unique=<span class="keyword">True</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">'&lt;User &#123;&#125;&gt;'</span>.format(self.userName)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Post</span><span class="params">(db.Model)</span>:</span></span><br><span class="line">    id = db.Column(db.Integer, primary_key=<span class="keyword">True</span>)</span><br><span class="line">    body = db.Column(db.String(<span class="number">140</span>))</span><br><span class="line">    timestamp = db.Column(db.DateTime, index=<span class="keyword">True</span>, default=datetime.utcnow)</span><br><span class="line">    userId = db.Column(db.Integer, db.ForeignKey(<span class="string">'user.id'</span>))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">'&lt;Post &#123;&#125;&gt;'</span>.format(self.body)</span><br></pre></td></tr></table></figure><p>这里要说两点：</p><p>①建<code>user</code>表的时候给<code>userName、phone</code>加上了索引，那么索引到底是什么意思呢？<strong>索引就是一种数据结构</strong>，给合适的属性加上索引后，查询会变快。网上有很多的解释文章，这里贴两篇不错的：<a href="https://zhuanlan.zhihu.com/p/23624390" target="_blank" rel="noopener">深入浅出数据库索引原理</a>、<a href="https://blog.csdn.net/weiliangliang111/article/details/51333169" target="_blank" rel="noopener">数据库索引到底是什么，是怎样工作的？</a>、<a href="https://blog.csdn.net/suifeng3051/article/details/52669644" target="_blank" rel="noopener">数据库索引原理及优化</a></p><p>②这里重构了<code>__repr__</code>方法，它的作用就是在<strong>查看其类的实体时更加友好</strong>，可以自定义其显示的内容，而不是默认的显示实体在内存中的地址，具体参看：<a href="https://blog.csdn.net/luckytanggu/article/details/53649156" target="_blank" rel="noopener">Python中<strong>repr</strong>和<strong>str</strong>区别</a></p><hr><h3 id="Day-3"><a href="#Day-3" class="headerlink" title="Day 3"></a>Day 3</h3><p>第 5 节的内容是用户登录，但在处理登录之前先要解决前一节的遗留问题，那就是密码的存储，密码肯定是不能明文存在数据库中的，是需要加密的，这里是调用<code>werkzeug</code>库来进行哈希加密，但它的验证方式有点不同，正常来说验证时的操作是：将用户输入的密码进行哈希加密，然后与数据库存的进行比对。但这个库却提供了一个验证函数<code>check_password_hash(str_hash, str)</code>，因为其加密函数<code>generate_password_hash(str)</code>对同一个字符串两次加密的结果是不同的，所以笔记用它给的验证函数来验证。故现在就需要对前面创建的<code>User Model</code>进行更改：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span><span class="params">(db.Model)</span>:</span></span><br><span class="line">    <span class="comment">#...</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">set_userPwd</span><span class="params">(self, password)</span>:</span></span><br><span class="line">        self.userPwd = generate_password_hash(password)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">check_userPwd</span><span class="params">(self, password)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> check_password_hash(self.userPwd, password)</span><br></pre></td></tr></table></figure><p>连登录都有插件可以用，涨见识了，这里就是用的<code>flask-login</code>插件来完成后面的登录/登出，注册功能。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@app.route('/login', methods=['GET','POST'])</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">login</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">if</span> current_user.is_authenticated:</span><br><span class="line">        <span class="keyword">return</span> redirect(url_for(<span class="string">'index'</span>))</span><br><span class="line">    form = LoginForm()</span><br><span class="line">    <span class="keyword">if</span> form.validate_on_submit():</span><br><span class="line">        user = User.query.filter_by(userName = form.userName.data).first()</span><br><span class="line">        <span class="keyword">if</span> user <span class="keyword">is</span> <span class="keyword">None</span> <span class="keyword">or</span> <span class="keyword">not</span> user.check_userPwd(form.userPwd.data):</span><br><span class="line">            flash(<span class="string">'Invalid userName or userPwd'</span>)</span><br><span class="line">            <span class="keyword">return</span> redirect(url_for(<span class="string">'login'</span>))</span><br><span class="line">        login_user(user, remember=form.rememberMe.data)</span><br><span class="line">        next_page = request.args.get(<span class="string">'next'</span>)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> next_page <span class="keyword">or</span> url_parse(next_page).netloc != <span class="string">''</span>:</span><br><span class="line">            next_page = url_for(<span class="string">'index'</span>)</span><br><span class="line">        <span class="keyword">return</span> redirect(next_page)</span><br><span class="line">    <span class="keyword">return</span> render_template(<span class="string">'login.html'</span>, title=<span class="string">'登录'</span>, form=form)</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route('/logout')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">logout</span><span class="params">()</span>:</span></span><br><span class="line">    logout_user()</span><br><span class="line">    <span class="keyword">return</span> redirect(url_for(<span class="string">'index'</span>))</span><br></pre></td></tr></table></figure><p>这里贴出了处理登录/登出的函数（上面需要<code>import</code>相应的函数，这里没贴），对于登录，可以看到这里首先判断当前用户<code>current_user</code>的状态，如果已经登录，则无需再登录，否则进行后续的查数据库验证。它这个库帮你做好了<code>session</code>的工作。</p><p>后面的注册功能实现和前面流程差不多：</p><p>①写注册页面需要的表单</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RegistrationForm</span><span class="params">(FlaskForm)</span>:</span></span><br><span class="line">    userName = StringField(<span class="string">'用户名'</span>, validators=[DataRequired()])</span><br><span class="line">    phone = StringField(<span class="string">'电话'</span>, validators=[DataRequired()])</span><br><span class="line">    userPwd = PasswordField(<span class="string">'密码'</span>,validators=[DataRequired()])</span><br><span class="line">    userPwd2 = PasswordField(<span class="string">'重复密码'</span>, validators=[DataRequired(), EqualTo(<span class="string">'userPwd'</span>)])</span><br><span class="line">    submit = SubmitField(<span class="string">'注册'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">validate_userName</span><span class="params">(self, userName)</span>:</span></span><br><span class="line">        user = User.query.filter_by(userName = userName.data).first()</span><br><span class="line">        <span class="keyword">if</span> user <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</span><br><span class="line">            <span class="keyword">raise</span> ValidationError(<span class="string">'用户名已存在'</span>)</span><br></pre></td></tr></table></figure><p>②写注册的页面<code>register.html</code></p><p>③配置注册路由</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@app.route('/register', methods=['GET', 'POST'])</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">register</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">if</span> current_user.is_authenticated:</span><br><span class="line">        <span class="keyword">return</span> redirect(url_for(<span class="string">'index'</span>))</span><br><span class="line">    form = RegistrationForm()</span><br><span class="line">    <span class="keyword">if</span> form.validate_on_submit():</span><br><span class="line">        user = User(userName = form.userName.data, phone=form.phone.data)</span><br><span class="line">        user.set_userPwd(form.userPwd.data)</span><br><span class="line">        db.session.add(user)</span><br><span class="line">        db.session.commit()</span><br><span class="line">        flash(<span class="string">'注册成功'</span>)</span><br><span class="line">        <span class="keyword">return</span> redirect(url_for(<span class="string">'login'</span>))</span><br><span class="line">    <span class="keyword">return</span> render_template(<span class="string">'register.html'</span>, title = <span class="string">'注册'</span>,form = form)</span><br></pre></td></tr></table></figure><p>推荐阅读：</p><ul><li><a href="https://mp.weixin.qq.com/s/0dOaIbXTAwSwh8lSj7Ee3w" target="_blank" rel="noopener">一次忘记密码引发的算法思考</a></li><li><a href="https://www.infoq.cn/article/how-to-encrypt-the-user-password-correctly" target="_blank" rel="noopener">如何正确对用户密码进行加密？</a></li></ul><hr><h3 id="Day-4"><a href="#Day-4" class="headerlink" title="Day 4:"></a>Day 4:</h3><p>第 5 节的内容是建立用户的信息页面，并且提供修改的功能。</p><p>在个人信息页面展示了该用户发表的文章，在首页同样也有该文章列表，这时就用了<code>Jinja2</code>的子模板功能，对于组件的格式提供复用的可能，例如这里是定义了一个文章的格式：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span> <span class="attr">valign</span>=<span class="string">"top"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"&#123;&#123; post.author.avatar(36) &#125;&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>&#123;&#123; post.body &#125;&#125;<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在需要的时候直接<code>include</code>就好：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h3</span>&gt;</span>文章列表:<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">&#123;% for post in posts %&#125;</span><br><span class="line">&#123;% include '_post.html' %&#125;</span><br><span class="line">&#123;% endfor %&#125;</span><br></pre></td></tr></table></figure><p>对于用户名和介绍提供了修改的功能，那么就需要修改页面，同前面的步骤一样：</p><p>①写修改页面的表单</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EditProfileForm</span><span class="params">(FlaskForm)</span>:</span></span><br><span class="line">    userName = StringField(<span class="string">'用户名'</span>, validators=[DataRequired()])</span><br><span class="line">    about_me = TextAreaField(<span class="string">'介绍...'</span>, validators=[Length(min=<span class="number">0</span>, max=<span class="number">140</span>)])</span><br><span class="line">    submit = SubmitField(<span class="string">'修改'</span>)</span><br></pre></td></tr></table></figure><p>②写修改的页面<code>edit_profile.html</code></p><p>③配置路由：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@app.route('/edit_profile', methods=['GET', 'POST'])</span></span><br><span class="line"><span class="meta">@login_required</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">edit_profile</span><span class="params">()</span>:</span></span><br><span class="line">    form = EditProfileForm()</span><br><span class="line">    <span class="keyword">if</span> form.validate_on_submit():</span><br><span class="line">        current_user.userName = form.userName.data</span><br><span class="line">        current_user.about_me = form.about_me.data</span><br><span class="line">        db.session.commit()</span><br><span class="line">        flash(<span class="string">'修改成功'</span>)</span><br><span class="line">        <span class="keyword">return</span> redirect(url_for(<span class="string">'edit_profile'</span>))</span><br><span class="line">    <span class="keyword">elif</span> request.method == <span class="string">'GET'</span>:</span><br><span class="line">        form.userName.data = current_user.userName</span><br><span class="line">        form.about_me.data = current_user.about_me</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> render_template(<span class="string">'edit_profile.html'</span>, title=<span class="string">'修改个人信息'</span>, form=form)</span><br></pre></td></tr></table></figure><p>可以看到这个逻辑和前面写过的有点不一样，前面就只是简单接受<code>Post</code>请求发过来的数据就好了，这里多了一个处理<code>Get</code>请求的分支，当用户需要修改信息，第一次跳到这个页面时肯定是通过<code>Get</code>来获取页面，此时应该将用户当前的用户名和简介都预先加载到输入框中。当用户修改完成点击提交时，这时对数据库的操作就一条语句<code>db.session.commit()</code>，在看看前面的注册路由，为什么这里不需要<code>db.session.add()</code>呢？因为前面用到了<code>current_user</code>，那么<code>flask-login</code>库已经在数据库中找到了相应的<code>user</code>并放到了<code>db.session</code>中，这时直接<code>commit()</code>就好，但在注册路由中，并没有使用<code>current_user</code>，只是通过拿到了表单中的数据，此时<code>db.session</code>中没有数据，自然不能直接提交，需要先<code>add</code>后再<code>commit</code>。我们每次操作数据库其实并不是在直接操作的，而是与<code>session</code>打交道，最后通过<code>commit</code>通知数据库自己去执行相应操作。</p><p>最后，提一下时间的存储问题，原来都是直接将当前的系统时间存入数据库，这在国际化时会出问题，因为各地的时间都不一样，所以最好的做法是存<code>UTC</code>时间，在需要转换成当地时间加时差就好了，这点也是看作者提到也才知道，原来都不知道这么一回事儿。<a href="https://zh.wikipedia.org/wiki/%E5%8D%8F%E8%B0%83%E4%B8%96%E7%95%8C%E6%97%B6" target="_blank" rel="noopener">UTC-维基百科</a></p><hr><h3 id="Day-5"><a href="#Day-5" class="headerlink" title="Day 5"></a>Day 5</h3><p>今天做了第 7、8 节的内容，主要包括提供错误页面，例如常用的 404、500 错误，然后就是开始实现用户关注的功能，前面的数据库设计中有一对多关系：一个作者可以写多篇文章，但这里的关注功能设计到多对多的关系，因为一个用户可以关注多个用户，同样会有多个用户关注这一个用户。例如学生老师关系，一个老师可以教多个学生，而一个学生也可以上多个老师的课，那么通常就需要引入另一张表来存学生老师的关联关系：</p><p><img src="http://m-markdown-image.oss-cn-beijing.aliyuncs.com/2018-12-24-%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-24%2011.57.52.png" alt=""></p><p>在这里的用户关注中有一点比较特殊的地方，上面是有两个实体的，即学生实体和老师实体，而在这里是用户关注用户，只有一个用户实体，那么对应的关系表就应该是这样:</p><p><img src="http://m-markdown-image.oss-cn-beijing.aliyuncs.com/2018-12-24-%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-24%2011.14.22.png" alt=""></p><p>关于多对多关系，可以看 <a href="http://blog.51cto.com/rickqin/1333469" target="_blank" rel="noopener">关于多对多关系的一点理解</a></p><p>所以我们现在就要建一张关注者与被关注者的关系表：<code>follower</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">followers = db.Table(<span class="string">'followers'</span>,</span><br><span class="line">                     db.Column(<span class="string">'follower_id'</span>, db.Integer, db.ForeignKey(<span class="string">'user.id'</span>)),</span><br><span class="line">                     db.Column(<span class="string">'followed_id'</span>, db.Integer, db.ForeignKey(<span class="string">'user.id'</span>))</span><br><span class="line">                     )</span><br></pre></td></tr></table></figure><p>注意到这里并没有和前面建<code>user</code>和<code>post</code>表一样用<code>model</code>，因为这张表的字段就是外键，就是为了表示多对多关系而建的一张辅助表。接下来就是给<code>user</code>表添加关系、封装关注和取关的功能、获取关注者和自己的文章列表。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span><span class="params">(UserMixin, db.Model)</span>:</span></span><br><span class="line"><span class="comment">#...</span></span><br><span class="line">    followed = db.relationship(</span><br><span class="line">        <span class="string">'User'</span>, secondary=followers,</span><br><span class="line">        primaryjoin=(followers.c.follower_id == id),</span><br><span class="line">        secondaryjoin=(followers.c.followed_id == id),</span><br><span class="line">        backref=db.backref(<span class="string">'followers'</span>, lazy=<span class="string">'dynamic'</span>),</span><br><span class="line">        lazy=<span class="string">'dynamic'</span></span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">follow</span><span class="params">(self, user)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.is_following(user):</span><br><span class="line">            self.followed.append(user)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">unfollow</span><span class="params">(self, user)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.is_following(user):</span><br><span class="line">            self.followed.remove(user)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">is_following</span><span class="params">(self, user)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.followed.filter(followers.c.followed_id == user.id).count() &gt; <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">followed_posts</span><span class="params">(self)</span>:</span></span><br><span class="line">        followed = Post.query.join(followers, (followers.c.followed_id == Post.userId)). \</span><br><span class="line">            filter(followers.c.follower_id == self.id)</span><br><span class="line">        own = Post.query.filter_by(userId=self.id)</span><br><span class="line">        <span class="keyword">return</span> followed.union(own).order_by(Post.timestamp.desc())</span><br></pre></td></tr></table></figure><p>这里用到了数据库的<code>join、union</code>操作，这以前在我的知识库里都是高级操作。现在借此重新学习下，<strong><code>join</code>操作的本质就是多表的结合重构</strong>，具体还是看网上的教程吧：<a href="https://coolshell.cn/articles/3463.html" target="_blank" rel="noopener">图解SQL的JOIN</a>、<a href="https://mazhuang.org/2017/09/11/joins-in-sql/" target="_blank" rel="noopener">图解 SQL 里的各种 JOIN</a>、<a href="https://zh.wikipedia.org/wiki/%E8%BF%9E%E6%8E%A5_(SQL" target="_blank" rel="noopener">wiki</a>)、<a href="https://segmentfault.com/a/1190000007926959#articleHeader3" target="_blank" rel="noopener">MySQL必知必会:组合查询(union)</a>、<a href="https://blog.csdn.net/ljxfblog/article/details/52066006" target="_blank" rel="noopener">关于SQL中Union和Join的用法</a>，理解后再看这个查询语句就好理解多了。另外本节作者讲的很仔细，复习时一定回去看原文。</p><hr><h3 id="Day-6"><a href="#Day-6" class="headerlink" title="Day 6"></a>Day 6</h3>]]></content>
      
      
      <categories>
          
          <category> 练级之路 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Flask </tag>
            
            <tag> SQLite </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>【medium】Integer to Roman</title>
      <link href="/LeetCode-012-Integer%20to%20Roman.html"/>
      <url>/LeetCode-012-Integer%20to%20Roman.html</url>
      
        <content type="html"><![CDATA[<p>Roman numerals are represented by seven different symbols: <code>I</code>, <code>V</code>, <code>X</code>, <code>L</code>, <code>C</code>, <code>D</code> and <code>M</code>.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Symbol       Value</span><br><span class="line">I             1</span><br><span class="line">V             5</span><br><span class="line">X             10</span><br><span class="line">L             50</span><br><span class="line">C             100</span><br><span class="line">D             500</span><br><span class="line">M             1000</span><br></pre></td></tr></table></figure><a id="more"></a><p>For example, two is written as <code>II</code> in Roman numeral, just two one’s added together. Twelve is written as, <code>XII</code>, which is simply <code>X</code> + <code>II</code>. The number twenty seven is written as <code>XXVII</code>, which is <code>XX</code> + <code>V</code> + <code>II</code>.</p><p>Roman numerals are usually written largest to smallest from left to right. However, the numeral for four is not <code>IIII</code>. Instead, the number four is written as <code>IV</code>. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as <code>IX</code>. There are six instances where subtraction is used:</p><ul><li><code>I</code> can be placed before <code>V</code> (5) and <code>X</code> (10) to make 4 and 9. </li><li><code>X</code> can be placed before <code>L</code> (50) and <code>C</code> (100) to make 40 and 90. </li><li><code>C</code> can be placed before <code>D</code> (500) and <code>M</code> (1000) to make 400 and 900.</li></ul><p>Given an integer, convert it to a roman numeral. Input is guaranteed to be within the range from 1 to 3999.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: 3</span><br><span class="line">Output: &quot;III&quot;</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: 4</span><br><span class="line">Output: &quot;IV&quot;</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: 9</span><br><span class="line">Output: &quot;IX&quot;</span><br></pre></td></tr></table></figure><p><strong>Example 4:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: 58</span><br><span class="line">Output: &quot;LVIII&quot;</span><br><span class="line">Explanation: L = 50, V = 5, III = 3.</span><br></pre></td></tr></table></figure><p><strong>Example 5:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: 1994</span><br><span class="line">Output: &quot;MCMXCIV&quot;</span><br><span class="line">Explanation: M = 1000, CM = 900, XC = 90 and IV = 4.</span><br></pre></td></tr></table></figure><hr><h3 id="思路分析："><a href="#思路分析：" class="headerlink" title="思路分析："></a>思路分析：</h3><ul><li>可以发现罗马数字是将整数的各个位，即个位、十位、百位等分别表示出来并连在一起，那么可以就根据这个规律来操作，现将输入数字的每个位都提取出来，然后用罗马字符表示，最后组合起来，见代码块 1.1</li><li>贪心法，列出非叠加的所有组合，然后每次通过查表来找出当前最大的数，将其对应的罗马字符添加到结果中，减去后再继续查表，重复上述操作。其实最好理解贪心法的例子就是换零钱，例如有 36 块，一般人的换法一定是先拿一张 20 的，还剩 16 ，再拿一张 10 的，还剩 6 ，再拿一张 5 的，还剩 1 ，则最后再拿一张 1 的，所以最终的零钱就是：20+10+5+1。见代码块 2.1</li></ul><hr><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现:"></a>代码实现:</h3><blockquote><p>1.1</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">intToRoman</span><span class="params">(self, num)</span>:</span></span><br><span class="line">        symbolList = [<span class="string">'M'</span>, <span class="string">'D'</span>, <span class="string">'C'</span>, <span class="string">'L'</span>, <span class="string">'X'</span>, <span class="string">'V'</span>, <span class="string">'I'</span>]</span><br><span class="line">        valueList = [<span class="number">1000</span>, <span class="number">500</span>, <span class="number">100</span>, <span class="number">50</span>, <span class="number">10</span>, <span class="number">5</span>, <span class="number">1</span>]</span><br><span class="line">        res = <span class="string">''</span></span><br><span class="line">        <span class="keyword">for</span> index <span class="keyword">in</span> range(<span class="number">0</span>, len(valueList), <span class="number">2</span>):</span><br><span class="line">            x = num // valueList[index]</span><br><span class="line">            <span class="keyword">if</span> x &lt; <span class="number">4</span>:</span><br><span class="line">               <span class="keyword">for</span> i <span class="keyword">in</span> range(x):</span><br><span class="line">                   res += symbolList[index]</span><br><span class="line">            <span class="keyword">elif</span> x == <span class="number">4</span>:</span><br><span class="line">                res += symbolList[index]+symbolList[index<span class="number">-1</span>]</span><br><span class="line">            <span class="keyword">elif</span> x &lt; <span class="number">9</span>:</span><br><span class="line">                res += symbolList[index<span class="number">-1</span>]</span><br><span class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> range(x<span class="number">-5</span>):</span><br><span class="line">                    res += symbolList[index]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                res += symbolList[index]+ symbolList[index<span class="number">-2</span>]</span><br><span class="line">            num %= valueList[index]</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p>可以看到我将每个位上的数字分了 4 种情况：</p><p>①小于 4 时，则是简单的叠加，例如 3 就是三个<code>I</code>叠加， 30 就是三个<code>X</code>叠加， 300 就是三个<code>C</code>叠加，以此类推。</p><p>②等于 4 时，则是相邻两位相加，且小的在前，大的在后，例如 4 就是 1 和 5 的相加<code>IV</code>, 40 就是 10 和 50 的相加<code>XL</code>，那 4000 呢？照理说应该是 1000 和 5000 的相加，但题目这里并没有给 5000对应的罗马数字，而且题目说了输入整数范围是 1-3999。</p><p>③大于 4 且小于 9，则是综合了①和②，先写上当前的罗马数字，再看剩下的需要叠加几次，例如 8 就是先写 5 ，剩下的 3 就还要 3 个 1 来叠加 3 次，即<code>V</code>+<code>I</code>+<code>I</code>+<code>I</code>，以此类推。</p><p>④等于 9 时，其实和②一样，只不过不是相邻两位相加了，而是中间需要隔一个，例如 9 是 1 和 10 的相加<code>IX</code>，90 就是 10 和 100 的相加<code>XC</code></p><p>其实我觉得这段代码最精髓的地方在于开始两个列表的设置，非常方便后面的操作，而不是像我原来在<a href="https://smileyx.top/leetcode-013-roman%20to%20integer">【easy】Roman to Integer</a>中的写成字典的形式。</p><blockquote><p>2.1 贪心法</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">intToRoman</span><span class="params">(self, num)</span>:</span></span><br><span class="line">        symbolList = [<span class="string">'M'</span>, <span class="string">'CM'</span>, <span class="string">'D'</span>, <span class="string">'CD'</span>, <span class="string">'C'</span>, <span class="string">'XC'</span>, <span class="string">'L'</span>, <span class="string">'XL'</span>, <span class="string">'X'</span>, <span class="string">'IX'</span>, <span class="string">'V'</span>, <span class="string">'IV'</span>, <span class="string">'I'</span>]</span><br><span class="line">        valueList = [<span class="number">1000</span>, <span class="number">900</span>, <span class="number">500</span>, <span class="number">400</span>, <span class="number">100</span>, <span class="number">90</span>, <span class="number">50</span>, <span class="number">40</span>, <span class="number">10</span>, <span class="number">9</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">1</span>]</span><br><span class="line">        res = <span class="string">''</span></span><br><span class="line">        <span class="keyword">for</span> index <span class="keyword">in</span> range(len(valueList)):</span><br><span class="line">            <span class="keyword">while</span> num &gt;= valueList[index]:</span><br><span class="line">                res += symbolList[index]</span><br><span class="line">                num -= valueList[index]</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p>基于贪心的代码实现逻辑更简单，我感觉<strong>重点更在于列出所有非叠加的可能</strong>，即列表中的 900、400 等，而不是 300、200 之类的。</p><hr><h3 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h3><ul><li><a href="https://leetcode.com/problems/integer-to-roman/" target="_blank" rel="noopener">题目链接</a></li><li><a href="https://www.cnblogs.com/grandyang/p/4123374.html" target="_blank" rel="noopener">[LeetCode] Integer to Roman 整数转化成罗马数字</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> LeetCode日记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 贪心 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>【medium】Container With Most Water</title>
      <link href="/LeetCode-011-Container%20With%20Most%20Water.html"/>
      <url>/LeetCode-011-Container%20With%20Most%20Water.html</url>
      
        <content type="html"><![CDATA[<p>Given <em>n</em> non-negative integers <em>a1</em>, <em>a2</em>, …, <em>an</em> , where each represents a point at coordinate (<em>i</em>, <em>ai</em>). <em>n</em> vertical lines are drawn such that the two endpoints of line <em>i</em> is at (<em>i</em>, <em>ai</em>) and (<em>i</em>, 0). Find two lines, which together with x-axis forms a container, such that the container contains the most water.</p><p><strong>Note:</strong> You may not slant the container and <em>n</em> is at least 2.</p><p><img src="http://m-markdown-image.oss-cn-beijing.aliyuncs.com/2018-12-17-question_11.jpg" alt=""></p><p>The above vertical lines are represented by array [1,8,6,2,5,4,8,3,7]. In this case, the max area of water (blue section) the container can contain is 49.</p><p><strong>Example:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,8,6,2,5,4,8,3,7]</span><br><span class="line">Output: 49</span><br></pre></td></tr></table></figure><a id="more"></a><hr><h3 id="思路分析："><a href="#思路分析：" class="headerlink" title="思路分析："></a>思路分析：</h3><ul><li><p>暴力法，这又是我首先想到的方法，即两层遍历，找出所有的组合的容量，记录最大的一个返回，可是会报<code>TLE</code>异常，这里也就不贴代码了，说实话有点丢人</p></li><li><p>参考了网上一种$O(n)$的方法，基于贪心的思想。需要前后两个指针，最大容量其实取决于首尾两个边中较短的那个，跟中间边的高度没有任何关系，那么我们默认初始最大容量就是全部，即两个指针分别指向首尾，计算出当前的最大容量，然后将较小的边向中间移动一个（当然是移动指针），看能不能将较短的边换大一点，这样一直继续到前后指针碰头。有大佬指出：</p><blockquote><p>假如 A[0] &lt; A[n-1]，那么对于任意 k (k&lt;n-1)，A[0] 到 A[k] 所装的水一定会小于 A[0]到 A[n-1] 所装的水，所以我们只要关心 A[1] 到 A[n-1] 的最大盛水量就好了。</p></blockquote></li></ul><hr><h3 id="代码实现："><a href="#代码实现：" class="headerlink" title="代码实现："></a>代码实现：</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxArea</span><span class="params">(self, height)</span>:</span></span><br><span class="line">        leftIndex = <span class="number">0</span></span><br><span class="line">        rightIndex = len(height) - <span class="number">1</span></span><br><span class="line">        maxArea = min(height[leftIndex], height[rightIndex]) * (rightIndex - leftIndex)</span><br><span class="line">        <span class="keyword">while</span> leftIndex &lt; rightIndex:</span><br><span class="line">            <span class="keyword">if</span> height[leftIndex] &lt; height[rightIndex]:</span><br><span class="line">                leftIndex += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                rightIndex -= <span class="number">1</span></span><br><span class="line">            area = min(height[leftIndex], height[rightIndex]) * (rightIndex - leftIndex)</span><br><span class="line">            <span class="keyword">if</span> area &gt; maxArea:</span><br><span class="line">                maxArea = area</span><br><span class="line">        <span class="keyword">return</span> maxArea</span><br></pre></td></tr></table></figure><hr><h3 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h3><ul><li><a href="https://leetcode.com/problems/container-with-most-water/" target="_blank" rel="noopener">题目链接</a></li><li><a href="https://yanjia.me/zh/2018/11/13/leetcode-container-with-most-water/" target="_blank" rel="noopener">[Leetcode] Container With Most Water 最大盛水容器</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> LeetCode日记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 贪心 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>【medium】Longest Palindromic Substring</title>
      <link href="/LeetCode-005-Longest%20Palindromic%20Substring.html"/>
      <url>/LeetCode-005-Longest%20Palindromic%20Substring.html</url>
      
        <content type="html"><![CDATA[<p>Given a string <strong>s</strong>, find the longest palindromic substring in <strong>s</strong>. You may assume that the maximum length of <strong>s</strong> is 1000.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;babad&quot;</span><br><span class="line">Output: &quot;bab&quot;</span><br><span class="line">Note: &quot;aba&quot; is also a valid answer.</span><br></pre></td></tr></table></figure><a id="more"></a><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;cbbd&quot;</span><br><span class="line">Output: &quot;bb&quot;</span><br></pre></td></tr></table></figure><p>其实题目表述的不是很清楚，它的要求应该是找到最大的且第一个回文子串，例如字符串为<code>abacdc</code>，它应该返回的是<code>aba</code>，而不是<code>cdc</code>。</p><hr><h3 id="思路分析："><a href="#思路分析：" class="headerlink" title="思路分析："></a>思路分析：</h3><ul><li><p>独家自创法，观察到回文串的首尾字符一定是相同的，所以拿这个特征来作为一个判断标志，前后两个指针，当前后指针所指的元素相等时，则判断前后指针所夹着的是不是回文串。代码见 1.1</p></li><li><p>动态规划，若一个大回文串按比例缩小，仍然是回文串，即<code>abba</code>是回文串，那么收尾同时缩小一个后，<code>bb</code>也是回文串，即可以<strong>将大问题划分为小问题</strong>，同时如果先计算小问题，那么小问题的结果在后面计算大问题时可以直接利用，即<strong>重复利用前面的结果</strong>，这两点恰恰是动态规划思想的核心。那么具体的解决办法就是：</p><ul><li>利用一个二维数组<code>dp[i][j]</code>来存原字符串下标从<code>i</code>到<code>j</code>是否是回文串</li><li>接下来就是遍历，遍历的前 2 趟其实是计算小问题的过程，后面就是直接利用前面的小结果了</li></ul><p>具体看代码 2.1 吧，可能会比文字描述更清楚。</p></li><li><p>中心扩散法，由于回文串的长度可奇可偶，那么当长度为奇数时，中心点就一个值，长度为偶数时，中心点就有两个值，在这两种情况下，由中心点同时向两边扩散，判断是否是回文串，从而找到最大的回文子串。具体做法就是：遍历字符串，遍历到的每个节点都当成中心点，并考虑上面说的奇偶两种情况。代码见 3.1 和 3.2</p></li></ul><hr><h3 id="代码实现："><a href="#代码实现：" class="headerlink" title="代码实现："></a>代码实现：</h3><blockquote><p>1.1 独家自创</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestPalindrome</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        j = <span class="number">0</span>   <span class="comment">#①</span></span><br><span class="line">        res = <span class="string">''</span></span><br><span class="line">        sLen = len(s)</span><br><span class="line">        maxLen = len(res)</span><br><span class="line">        <span class="keyword">while</span> i &lt; sLen - maxLen:    <span class="comment">#②</span></span><br><span class="line">            <span class="keyword">while</span> j &lt; sLen:</span><br><span class="line">                <span class="keyword">if</span> s[i] == s[j]:</span><br><span class="line">                    <span class="keyword">if</span> s[i:j + <span class="number">1</span>] == s[i:j + <span class="number">1</span>][::<span class="number">-1</span>]:  <span class="comment">#③</span></span><br><span class="line">                        <span class="comment"># if len(s[i:j + 1]) &gt; maxLen:  #④</span></span><br><span class="line">                        res = s[i:j + <span class="number">1</span>]</span><br><span class="line">                        maxLen = len(res)</span><br><span class="line">                    j += <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    j += <span class="number">1</span></span><br><span class="line">            i = i + <span class="number">1</span></span><br><span class="line">            j = i + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p>代码中标注了需要注意的几个点：</p><p>①<code>j</code>为什么不初始化为 1 ，因为当字符串的长度为 1 时，最长回文子串就是它自己，而若<code>j = 1</code>则默认回文子串的长度从 2 开始。</p><p>②这里的循环条件为什么是<code>i &lt; sLen - maxLen</code>，因为这里是找最大的回文子串，而不是所有的，故前指针<code>i</code>无需遍历到最后，例如字符串：<code>bananas</code>，当<code>i = 1</code>时找到最大回文子串为<code>anana</code>，长度为 5 ，那么<code>i</code>就无需继续向后遍历了，因为后面只有 5 个元素了，即使是回文子串，其长度也不会比 5 大了，所以这时退出循环即可。而至于为什么是<code>&lt;</code>，而不是我开始写的<code>&lt;=</code>，可以结合④运行并单步调试，看看哪里会出问题。</p><p>③这里就是判断前后指针所夹的是不是回文子串，即正着和反着是不是相等。开始对切片的翻转操作是这样写的：<code>s[i:j+1:-1]</code>，但是这样得到的是空字符串，网上也都没有谈到过这个问题，于是翻书。才知道如果步进是负的话，前面的范围也要反过来。因为标准的切片形式为<code>X[i:j:k]</code>，始终都是以<code>i+k</code>前进的，所以当<code>k</code>是负时，应该把<code>j</code>和<code>i</code>调换位置，写成<code>X[j:i:k]</code>才能得到正确的结果。当然，也可以跟上面代码一样，切片和翻转分开来。</p><blockquote><p>2.1 动态规划</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestPalindrome</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        res = <span class="string">''</span></span><br><span class="line">        sLen = len(s)</span><br><span class="line">        maxLen = <span class="number">0</span></span><br><span class="line">        dp = [[<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(sLen)] <span class="keyword">for</span> j <span class="keyword">in</span> range(sLen)]</span><br><span class="line">        <span class="keyword">for</span> gap <span class="keyword">in</span> range(sLen):</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(sLen - gap):</span><br><span class="line">                <span class="keyword">if</span> gap == <span class="number">0</span>:</span><br><span class="line">                    dp[i][i + gap] = <span class="number">1</span></span><br><span class="line">                <span class="keyword">elif</span> gap == <span class="number">1</span>:</span><br><span class="line">                    dp[i][i + gap] = <span class="number">1</span> <span class="keyword">if</span> s[i] == s[i + gap] <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">if</span> s[i] == s[i + gap]:</span><br><span class="line">                        dp[i][i + gap] = <span class="number">1</span> <span class="keyword">if</span> dp[i + <span class="number">1</span>][i + gap - <span class="number">1</span>] <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        dp[i][i + gap] = <span class="number">0</span></span><br><span class="line">                <span class="keyword">if</span> dp[i][i + gap] <span class="keyword">and</span> gap &gt; maxLen - <span class="number">1</span>:</span><br><span class="line">                    maxLen = gap + <span class="number">1</span></span><br><span class="line">                    res = s[i:i + gap + <span class="number">1</span>]</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p>由于动态规划是一个自底向上的过程，那么它就必须遍历完才知道结果，我感觉不太适合这个题目（要求找最大，并不是所有），时间、空间效率都很差，提交有可能超时，另开辟了 $n^{2}$ 的空间。另外在<code>python</code>中用二维数组还是第一次（<code>python</code>中没有数组，只有列表，所以这里只能在列表中嵌套列表来表示二维数组，也可以调用<code>numpy</code>来创建）</p><blockquote><p>3.1 中心扩散法</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestPalindrome</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> len(s) &lt; <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> s</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            res = <span class="string">''</span></span><br><span class="line">            maxLen = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> centerIndex <span class="keyword">in</span> range(len(s)):</span><br><span class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>):</span><br><span class="line">                    leftIndex = centerIndex</span><br><span class="line">                    rightIndex = centerIndex+i</span><br><span class="line">                    <span class="keyword">if</span> rightIndex == len(s):<span class="comment">#①</span></span><br><span class="line">                        <span class="keyword">break</span></span><br><span class="line">                    <span class="keyword">while</span> s[leftIndex] == s[rightIndex] <span class="keyword">and</span> leftIndex &gt;= <span class="number">0</span> <span class="keyword">and</span> rightIndex &lt; len(s):</span><br><span class="line">                        leftIndex -= <span class="number">1</span></span><br><span class="line">                        rightIndex += <span class="number">1</span></span><br><span class="line">                        <span class="keyword">if</span> rightIndex == len(s):<span class="comment">#②</span></span><br><span class="line">                            <span class="keyword">break</span></span><br><span class="line">                    <span class="keyword">if</span> len(s[leftIndex+<span class="number">1</span>:rightIndex]) &gt; maxLen:</span><br><span class="line">                        res = s[leftIndex+<span class="number">1</span>:rightIndex]</span><br><span class="line">                        maxLen = len(res)</span><br><span class="line">            <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p>这段代码就是在一个函数内完成所有功能，有些杂乱，但好歹能正确跑出结果。其中第二层循环是计算的奇偶两种情况：当长度为奇数时，<code>leftIndex</code>和<code>rightIndex</code>应该相同，指向唯一一个中心点；当长度为偶数时，<code>rightIndex</code>应该比<code>leftIndex</code>大 1 ，表示中心点由 2 个元素组成。然后分别从<code>leftIndex</code>和<code>rightIndex</code>开始向两边扩散。开始写完后，总是报下标越界错误，调试半天加了①②的判断后才行。</p><blockquote><p>3.2 中心扩散法</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestPalindrome</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> len(s) &lt; <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> s</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            res = <span class="string">''</span></span><br><span class="line">            <span class="keyword">for</span> centerIndex <span class="keyword">in</span> range(len(s)):</span><br><span class="line">                subS_1 = self.spreadFromCenter(s, centerIndex, <span class="number">0</span>)</span><br><span class="line">                subS_2 = self.spreadFromCenter(s, centerIndex, <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">if</span> len(subS_1) &gt; len(res):</span><br><span class="line">                    res = subS_1</span><br><span class="line">                <span class="keyword">if</span> len(subS_2) &gt; len(res):</span><br><span class="line">                    res = subS_2</span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">spreadFromCenter</span><span class="params">(self, s, centerIndex, gap)</span>:</span></span><br><span class="line">        leftIndex = centerIndex</span><br><span class="line">        rightIndex = centerIndex + gap</span><br><span class="line">        temp = <span class="string">''</span></span><br><span class="line">        <span class="keyword">while</span> leftIndex &gt;= <span class="number">0</span> <span class="keyword">and</span> rightIndex &lt; len(s) <span class="keyword">and</span> s[leftIndex] == s[rightIndex]:</span><br><span class="line">            temp = s[leftIndex:rightIndex + <span class="number">1</span>]</span><br><span class="line">            leftIndex -= <span class="number">1</span></span><br><span class="line">            rightIndex += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> temp</span><br></pre></td></tr></table></figure><p>前面 3.1 的代码可读性不好，逻辑也混乱，于是有了这个修改版。将寻找回文子串的功能提取了出来，逻辑判断也更加清晰。具体在：</p><p>①<code>spreadFromCenter</code>方法接受的<code>gap</code>参数表明了奇偶情况，奇数则<code>leftIndex == rightIndex</code>，偶数则<code>rightIndex = leftIndex+1</code>，在函数内部只管向两边扩散并提取回文串。</p><p>②不需要<code>maxLen</code>这个多余变量，因为已经有了<code>res</code>，需要时直接<code>len(res)</code>就行</p><p>③去掉了多余的判断，在 3.1 中两次判断<code>rightIndex</code>是否越界。其实如果<code>while</code>语句的条件顺序对，则根本不需要上面的判断。在 3.1 中我是这样写的：<code>while s[leftIndex] == s[rightIndex] and leftIndex &gt;= 0 and rightIndex &lt; len(s):</code>，问题出在哪里呢？我把<code>s[leftIndex] == s[rightIndex]</code>的条件摆在第一个，而把防止越界的条件<code>leftIndex &gt;= 0</code>、<code>rightIndex &lt; len(s)</code>放在后面，那么循环中<code>rightIndex</code> 向后移动时，再进循环就可能下标越界。所以在这里，我先判断是否存在越界的可能，再判断其值是否相等。可见当有多个判断条件时，摆放顺序还是挺重要的，原来都没太注意这点。</p><hr><h3 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h3><ul><li><a href="https://leetcode.com/problems/longest-palindromic-substring/" target="_blank" rel="noopener">题目链接</a></li><li><a href="https://segmentfault.com/a/1190000002991199#articleHeader10" target="_blank" rel="noopener">最长回文子串-SegmentFault</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> LeetCode日记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 字符串 </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>【easy】Merge Sorted Array</title>
      <link href="/LeetCode-088-Merge%20Sorted%20Array.html"/>
      <url>/LeetCode-088-Merge%20Sorted%20Array.html</url>
      
        <content type="html"><![CDATA[<p>Given two sorted integer arrays <em>nums1</em> and <em>nums2</em>, merge <em>nums2</em> into <em>nums1</em> as one sorted array.</p><p><strong>Note:</strong></p><ul><li>The number of elements initialized in <em>nums1</em> and <em>nums2</em> are <em>m</em> and <em>n</em> respectively.</li><li>You may assume that <em>nums1</em> has enough space (size that is greater or equal to <em>m</em> + <em>n</em>) to hold additional elements from <em>nums2</em>.</li></ul><p><strong>Example:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">nums1 = [1,2,3,0,0,0], m = 3</span><br><span class="line">nums2 = [2,5,6],       n = 3</span><br><span class="line"></span><br><span class="line">Output: [1,2,2,3,5,6]</span><br></pre></td></tr></table></figure><a id="more"></a><hr><h3 id="思路分析："><a href="#思路分析：" class="headerlink" title="思路分析："></a>思路分析：</h3><ul><li>因为题目说<code>nums1</code>的长度是够的，例子也说明了这个问题，后面都是用 0 补位。那么最无脑的方法就是将<code>nums2</code>添加到<code>nums1</code>数字的后面，组成一个列表，然后进行排序。代码见 1.1</li><li>因为给的列表都是已经排好序的，那么就可以<strong>从后向前</strong>比较，较大的放到<code>nums1[i+j+1]</code>的位置上，可以发现还是比较好操作的，但是从前向后比较的话，就有点不好操作了。代码见 2.1</li></ul><hr><h3 id="代码实现："><a href="#代码实现：" class="headerlink" title="代码实现："></a>代码实现：</h3><blockquote><p>1.1</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">merge</span><span class="params">(self, nums1, m, nums2, n)</span>:</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(m, m + n):</span><br><span class="line">            nums1[i] = nums2[m + n - i - <span class="number">1</span>]</span><br><span class="line">        nums1.sort()</span><br><span class="line">        print(nums1)</span><br></pre></td></tr></table></figure><blockquote><p>2.1</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">merge</span><span class="params">(self, nums1, m, nums2, n)</span>:</span></span><br><span class="line">        i = m<span class="number">-1</span></span><br><span class="line">        j = n<span class="number">-1</span></span><br><span class="line">        <span class="keyword">while</span> i &gt;= <span class="number">0</span> <span class="keyword">and</span> j &gt;= <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">if</span> nums1[i] &gt; nums2[j]:</span><br><span class="line">                nums1[i+j+<span class="number">1</span>] = nums1[i]</span><br><span class="line">                i -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                nums1[i+j+<span class="number">1</span>] = nums2[j]</span><br><span class="line">                j -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> i &lt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">for</span> t <span class="keyword">in</span> range(<span class="number">0</span>, j+<span class="number">1</span>):</span><br><span class="line">                nums1[t] = nums2[t]</span><br></pre></td></tr></table></figure><hr><h3 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h3><ul><li><a href="https://leetcode.com/problems/merge-sorted-array/" target="_blank" rel="noopener">题目链接</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> LeetCode日记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>【easy】Remove Duplicates from Sorted List</title>
      <link href="/LeetCode-83-Remove%20Duplicates%20from%20Sorted%20List.html"/>
      <url>/LeetCode-83-Remove%20Duplicates%20from%20Sorted%20List.html</url>
      
        <content type="html"><![CDATA[<p>Given a sorted linked list, delete all duplicates such that each element appear only <em>once</em>.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: 1-&gt;1-&gt;2</span><br><span class="line">Output: 1-&gt;2</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: 1-&gt;1-&gt;2-&gt;3-&gt;3</span><br><span class="line">Output: 1-&gt;2-&gt;3</span><br></pre></td></tr></table></figure><p>又是链表去重的问题，前面做过的，只不过前面操作的的是<code>list</code>结构的，这里是它定义的链表结构（哎，我也不知道要怎么说了）</p><a id="more"></a><hr><h3 id="思路分析："><a href="#思路分析：" class="headerlink" title="思路分析："></a>思路分析：</h3><ul><li>和前面 <a href="https://smileyx.top/leetcode-026-remove%20duplicates%20from%20sorted%20array">Remove Duplicates from Sorted Array</a> 的思路是一样的，即采用快慢指针来解决，具体看前面的吧，还有图，这里就不重复了，直接贴代码。</li></ul><hr><h3 id="代码实现："><a href="#代码实现：" class="headerlink" title="代码实现："></a>代码实现：</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deleteDuplicates</span><span class="params">(self, head)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type head: ListNode</span></span><br><span class="line"><span class="string">        :rtype: ListNode</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> head:</span><br><span class="line">            pre = head</span><br><span class="line">            cursor = head.next</span><br><span class="line">            <span class="keyword">while</span> cursor:</span><br><span class="line">                <span class="keyword">if</span> pre.val == cursor.val:</span><br><span class="line">                    cursor = cursor.next</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    pre.next = cursor</span><br><span class="line">                    pre = cursor</span><br><span class="line">                    cursor = cursor.next</span><br><span class="line">            pre.next = <span class="keyword">None</span></span><br><span class="line">            <span class="keyword">return</span> head</span><br></pre></td></tr></table></figure><p>和前面的代码很像，只不过要注意在循环结束后，在<code>pre</code>指针的位置进行截断。</p><hr><h3 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h3><ul><li><a href="https://leetcode.com/problems/remove-duplicates-from-sorted-list/" target="_blank" rel="noopener">题目链接</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> LeetCode日记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>【easy】Two Sum</title>
      <link href="/LeetCode-001-Two%20Sum.html"/>
      <url>/LeetCode-001-Two%20Sum.html</url>
      
        <content type="html"><![CDATA[<p>Given an array of integers, return <strong>indices</strong> of the two numbers such that they add up to a specific target.</p><p>You may assume that each input would have <strong>exactly</strong> one solution, and you may not use the <em>same</em> element twice.</p><p><strong>Example:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Given nums = [2, 7, 11, 15], target = 9,</span><br><span class="line"></span><br><span class="line">Because nums[0] + nums[1] = 2 + 7 = 9,</span><br><span class="line">return [0, 1].</span><br></pre></td></tr></table></figure><a id="more"></a><hr><h3 id="思路分析："><a href="#思路分析：" class="headerlink" title="思路分析："></a>思路分析：</h3><ul><li><p>暴力方法，即用双层循环，枚举所有的组合，判断是否相加等于<code>target</code> ，对应代码块 1.1</p></li><li><p>只用一层循环，判断<code>target</code>减去取出的数是否在剩下的<code>list</code>中，这里用了 2 种写法，分别对应代码块 2.1 和 2.2</p></li></ul><hr><h3 id="代码实现："><a href="#代码实现：" class="headerlink" title="代码实现："></a>代码实现：</h3><blockquote><p>1.1</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">twoSum</span><span class="params">(self, nums, target)</span>:</span></span><br><span class="line">        <span class="keyword">for</span> i, valueX <span class="keyword">in</span> enumerate(nums):</span><br><span class="line">            <span class="keyword">for</span> j, valueY <span class="keyword">in</span> enumerate(nums[i+<span class="number">1</span>:]):</span><br><span class="line">                <span class="keyword">if</span> valueX + valueY == target:</span><br><span class="line">                    <span class="keyword">return</span> [i, i+j+<span class="number">1</span>]</span><br></pre></td></tr></table></figure><p>由于用了双层循环，时间复杂度达到了平方级别，所以耗时太多，在<code>LeetCode</code>上通不过测试。</p><p><img src="http://m-markdown-image.oss-cn-beijing.aliyuncs.com/2018-12-08-%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-12%2014.43.25.png" alt=""></p><blockquote><p>2.1</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">twoSum</span><span class="params">(self, nums, target)</span>:</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">            <span class="keyword">if</span> (target-nums[i]) <span class="keyword">in</span> nums[i+<span class="number">1</span>:]:</span><br><span class="line">                <span class="keyword">return</span> [i, nums[i+<span class="number">1</span>:].index(target-nums[i]) + (i+<span class="number">1</span>)]</span><br></pre></td></tr></table></figure><p>这里虽然只用了一层循环，但可能由于是用了<code>in</code>句或者<code>index()</code>方法的原因，耗时也很多，具体原因见后面总结。</p><p><img src="http://m-markdown-image.oss-cn-beijing.aliyuncs.com/2018-12-08-%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-12%2014.57.44.png" alt=""></p><blockquote><p>2.2</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">twoSum</span><span class="params">(self, nums, target)</span>:</span></span><br><span class="line">        hash_map = dict()</span><br><span class="line">        <span class="keyword">for</span> i, value <span class="keyword">in</span> enumerate(nums):</span><br><span class="line">            <span class="keyword">if</span> (target-value) <span class="keyword">in</span> hash_map:</span><br><span class="line">                <span class="keyword">return</span> [i, hash_map[target-value]]</span><br><span class="line">            hash_map[target-value] = i</span><br></pre></td></tr></table></figure><p>这里的方法速度就明显比前面的快，具体原因见下面总结</p><p><img src="http://m-markdown-image.oss-cn-beijing.aliyuncs.com/2018-12-08-%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-12%2015.22.51.png" alt=""></p><hr><h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><p>从 2.1 和 2.2 来看，同样只有一层循环，为什么速度差距这么大，原因并不是开始认为的<code>in</code>语句和<code>index()</code>方法的问题，本质原因其实是在 2.1 中，是在<code>list</code>中查找，而在 2.2 中，则是在<code>dict</code>中查找，而<strong>在<code>python</code>中<code>list</code>的存储结构就是线性表</strong>，可知查询复杂度很高，<strong>而<code>dict</code>的存储结构则是<code>hash</code>表</strong>，可知查询复杂度较低。</p><hr><h3 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h3><ul><li><p><a href="https://leetcode.com/problems/two-sum/" target="_blank" rel="noopener">题目链接</a></p></li><li><p><a href="https://blog.csdn.net/wzgbm/article/details/54691615" target="_blank" rel="noopener">python中in在list和dict中查找效率比较 - CSDN博客</a></p></li><li><a href="https://blog.csdn.net/jmh1996/article/details/78481365" target="_blank" rel="noopener">Python 中list, set, dict的大规模查找效率 - CSDN博客</a></li><li><a href="https://www.ibm.com/developerworks/cn/linux/l-cn-python-optim/index.html" target="_blank" rel="noopener">Python 代码性能优化技巧</a> </li><li><a href="https://blog.csdn.net/xiaoping8411/article/details/7706376" target="_blank" rel="noopener">查找算法之哈希查找 - CSDN博客</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> LeetCode日记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> n-sum 问题 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>【medium】Add Two Numbers</title>
      <link href="/LeetCode-002-Add%20Two%20Numbers.html"/>
      <url>/LeetCode-002-Add%20Two%20Numbers.html</url>
      
        <content type="html"><![CDATA[<p>You are given two <strong>non-empty</strong> linked lists representing two non-negative integers. The digits are stored in <strong>reverse order</strong> and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.</p><p>You may assume the two numbers do not contain any leading zero, except the number 0 itself.</p><p><strong>Example:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: (2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)</span><br><span class="line">Output: 7 -&gt; 0 -&gt; 8</span><br><span class="line">Explanation: 342 + 465 = 807.</span><br></pre></td></tr></table></figure><a id="more"></a><p>这里需要注意的就是给出的链表都是倒序的，即表头就是个位，表尾才是最高位，这极大方便了我们计算。（刚开始在这里弄了好久，以为是正序，那就还要对位后再相加，最后才发现是反的，相当于从个位到高位已经对好了）</p><hr><h3 id="思路分析："><a href="#思路分析：" class="headerlink" title="思路分析："></a>思路分析：</h3><ul><li><p>我最开始想到的就是<strong>按位相加，然后向前进位</strong>，就和我们手算一样的流程，但落实到代码上就歇菜了，于是在看了网上的大堆资料后，写了了残废版 1.1 ，最终版 1.2 ，关于代码的具体分析见下面代码实现</p></li><li><p>首先将两个链表的数据一一取出来加入对应的字符串，然后转换成<code>int</code>类型相加，最后再用结果生成对应的链表，对应代码块 2.1</p></li></ul><hr><h3 id="代码实现："><a href="#代码实现：" class="headerlink" title="代码实现："></a>代码实现：</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addTwoNumbers</span><span class="params">(self, l1, l2)</span>:</span></span><br><span class="line">        head = ListNode(<span class="number">0</span>)</span><br><span class="line">        head.next = l1</span><br><span class="line">        carry = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> l1 <span class="keyword">or</span> l2 <span class="keyword">or</span> carry != <span class="number">0</span>:</span><br><span class="line">            v1 = l1.val <span class="keyword">if</span> l1 <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">            v2 = l2.val <span class="keyword">if</span> l2 <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">            add = v1 + v2 + carry</span><br><span class="line">            <span class="keyword">if</span> add &gt;= <span class="number">10</span>:</span><br><span class="line">                carry = <span class="number">1</span></span><br><span class="line">                add -= <span class="number">10</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                carry = <span class="number">0</span></span><br><span class="line">            l1.val = add</span><br><span class="line">            l1 = l1.next</span><br><span class="line">            l2 = l2.next</span><br><span class="line">        <span class="keyword">return</span> head.next</span><br></pre></td></tr></table></figure><p>可以看到给的初始测试数据是能通过的，但后面就通不过了。</p><p><img src="http://m-markdown-image.oss-cn-beijing.aliyuncs.com/2018-12-08-%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-13%2021.41.26.png" alt=""></p><p><img src="http://m-markdown-image.oss-cn-beijing.aliyuncs.com/2018-12-08-%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-13%2021.42.09.png" alt=""></p><p>分析下问题出在哪里：</p><ul><li>这里我是直接用<code>L1</code>来存最后的结果，当<code>L1</code> 的长度大于或等于<code>L2</code>的长度，且最高位没有继续向前进位的情况下，该方法是可行的，也就解释了为什么第一个测试数据能通过，而后面出错的测试数据则是在最高位产生了进位，而代码并没有在进位时产生一个新的节点来存数据。</li></ul><p>解决方法：</p><ul><li>如果还是要用现存的列表来存结果，那么首先就需要判断 L1 和 L2 的长度， 选择较长的那个链表来存数据，那么前面就不会存在无节点存数据的问题，需要注意的是如果最高位存在进位，仍然要申请一个新节点来存。</li><li>上面这种方法有点过于复杂，既然有可能也要申请新节点，那么为什么不直接新建一个链表来存数据呢，于是有了下面的代码块。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addTwoNumbers</span><span class="params">(self, l1, l2)</span>:</span></span><br><span class="line">        head = result = ListNode(<span class="number">0</span>)<span class="comment">#①</span></span><br><span class="line">        carry = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> l1 <span class="keyword">or</span> l2 <span class="keyword">or</span> carry != <span class="number">0</span>:</span><br><span class="line">            v1 = l1.val <span class="keyword">if</span> l1 <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">            v2 = l2.val <span class="keyword">if</span> l2 <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">            add = v1 + v2 + carry</span><br><span class="line">            <span class="keyword">if</span> add &gt;= <span class="number">10</span>:</span><br><span class="line">                carry = <span class="number">1</span></span><br><span class="line">                add -= <span class="number">10</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                carry = <span class="number">0</span></span><br><span class="line">            result.next = ListNode(add)<span class="comment">#②</span></span><br><span class="line">            result = result.next<span class="comment">#③</span></span><br><span class="line">            <span class="keyword">if</span> l1:</span><br><span class="line">                l1 = l1.next</span><br><span class="line">            <span class="keyword">if</span> l2:</span><br><span class="line">                l2 = l2.next</span><br><span class="line">        <span class="keyword">return</span> head.next</span><br></pre></td></tr></table></figure><p>写这段代码时，关于结果链表各个节点的连接纠结了好久，下面画了一个图来帮助理解上面代码的 3 个关键点，对应于代码中注释的 ① ② ③：</p><p><img src="http://m-markdown-image.oss-cn-beijing.aliyuncs.com/2018-12-08-IMG_3709.JPG" alt=""></p><p>这里的<code>result</code>可以相当于游标，是跟着新节点走的</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addTwoNumbers</span><span class="params">(self, l1, l2)</span>:</span></span><br><span class="line">        l1_str = l2_str = <span class="string">''</span></span><br><span class="line">        head = result = ListNode(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">while</span> l1 <span class="keyword">or</span> l2:</span><br><span class="line">            <span class="keyword">if</span> l1:</span><br><span class="line">                l1_str += str(l1.val)</span><br><span class="line">            <span class="keyword">if</span> l2:</span><br><span class="line">                l2_str += str(l2.val)</span><br><span class="line">            <span class="keyword">if</span> l1:</span><br><span class="line">                l1 = l1.next</span><br><span class="line">            <span class="keyword">if</span> l2:</span><br><span class="line">                l2 = l2.next</span><br><span class="line">        sum = int(l1_str[::<span class="number">-1</span>]) + int(l2_str[::<span class="number">-1</span>])</span><br><span class="line">        sum_str = str(sum)[::<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> value <span class="keyword">in</span> sum_str:</span><br><span class="line">            result.next = ListNode(int(value))</span><br><span class="line">            result = result.next</span><br><span class="line">        <span class="keyword">return</span> head.next</span><br></pre></td></tr></table></figure><p>另外鉴于我对数据结构的掌握实在太差，永远只停留在表面上的了解，一落实到代码实现就GG，于是打算在刷<code>LeetCode</code>的同时，对基础的数据结构的实现也做下练习：<code>Python实现单链表</code></p><hr><h3 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h3><ul><li><a href="https://leetcode.com/problems/add-two-numbers/" target="_blank" rel="noopener">题目链接</a></li><li><a href="https://www.jianshu.com/p/5d8f13225adf" target="_blank" rel="noopener">LeetCode题解2：Add two numbers - 简书</a></li><li><a href="https://www.jianshu.com/p/15079795f604?utm_campaign=maleskine&amp;utm_content=note&amp;utm_medium=seo_notes&amp;utm_source=recommendation" target="_blank" rel="noopener">LeetCode 解题报告 - 2. Add Two Numbers - 简书</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> LeetCode日记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>【easy】Reverse Integer</title>
      <link href="/LeetCode-007-Reverse%20Integer.html"/>
      <url>/LeetCode-007-Reverse%20Integer.html</url>
      
        <content type="html"><![CDATA[<p>Given a 32-bit signed integer, reverse digits of an integer.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: 123</span><br><span class="line">Output: 321</span><br></pre></td></tr></table></figure><a id="more"></a><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: -123</span><br><span class="line">Output: -321</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: 120</span><br><span class="line">Output: 21</span><br></pre></td></tr></table></figure><p><strong>Note:</strong><br>Assume we are dealing with an environment which could only store integers within the 32-bit signed integer range: [−231,  231 − 1]. For the purpose of this problem, assume that your function returns 0 when the reversed integer overflows.</p><hr><h3 id="思路整理："><a href="#思路整理：" class="headerlink" title="思路整理："></a>思路整理：</h3><ul><li><p>我首先想到的是将数字去除符号后转换成字符串，然后利用切片来翻转字符串，去掉开头连续的 0（如果有的话），最后补上符号位转换成数字类型返回。见代码块 1.1 </p></li><li><p>通过不断除 10 取余的方法来讲数字倒置，然后将倒置的数字乘 10 的相应次方来得到最后的答案。见代码块 2.1</p></li></ul><hr><h3 id="代码实现："><a href="#代码实现：" class="headerlink" title="代码实现："></a>代码实现：</h3><blockquote><p>1.1</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverse</span><span class="params">(self, x)</span>:</span></span><br><span class="line">isNegative = <span class="keyword">False</span> <span class="keyword">if</span> x&gt;=<span class="number">0</span> <span class="keyword">else</span> <span class="keyword">True</span></span><br><span class="line">        reverseStr = str(-x)[::<span class="number">-1</span>] <span class="keyword">if</span> isNegative <span class="keyword">else</span> str(x)[::<span class="number">-1</span>]</span><br><span class="line">        flag = <span class="number">0</span></span><br><span class="line">        result = <span class="string">''</span></span><br><span class="line">        <span class="keyword">for</span> value <span class="keyword">in</span> reverseStr:</span><br><span class="line">            <span class="keyword">if</span> value != <span class="number">0</span>:</span><br><span class="line">                flag = <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">if</span> flag:</span><br><span class="line">                result += value</span><br><span class="line">        <span class="keyword">if</span> int(result) &lt; (<span class="number">2</span>**<span class="number">31</span>)<span class="number">-1</span>:</span><br><span class="line">            <span class="keyword">return</span> -int(result) <span class="keyword">if</span> isNegative <span class="keyword">else</span> int(result)</span><br></pre></td></tr></table></figure><p>写完后看了看别人的代码，发现用<code>int</code>将字符串转换成数字类型时，它能自动去掉前面连续的 0 ，再看看我的代码，简直蠢！处理了半天前面的 0 ，修改见 1.2</p><blockquote><p>1.2</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverse</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type x: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        reverseStr = str(-x)[::<span class="number">-1</span>] <span class="keyword">if</span> x&lt;<span class="number">0</span> <span class="keyword">else</span> str(x)[::<span class="number">-1</span>]</span><br><span class="line">        <span class="keyword">if</span> int(reverseStr) &lt; (<span class="number">2</span>**<span class="number">31</span>)<span class="number">-1</span>:</span><br><span class="line">            <span class="keyword">return</span> -int(reverseStr) <span class="keyword">if</span> x&lt;<span class="number">0</span> <span class="keyword">else</span> int(reverseStr)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br></pre></td></tr></table></figure><blockquote><p>2.1</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverse</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">:type x: int</span></span><br><span class="line"><span class="string">:rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        a = x <span class="keyword">if</span> x &gt; <span class="number">0</span> <span class="keyword">else</span> -x</span><br><span class="line">        b = <span class="number">0</span></span><br><span class="line">        temp = []</span><br><span class="line">        <span class="keyword">while</span> a != <span class="number">0</span>:</span><br><span class="line">            b = a % <span class="number">10</span></span><br><span class="line">            a //= <span class="number">10</span></span><br><span class="line">            temp.append(b)</span><br><span class="line">        tempLength = len(temp)</span><br><span class="line">        reverseNum = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(tempLength):</span><br><span class="line">            reverseNum += temp[i]*(<span class="number">10</span>**(tempLength-i<span class="number">-1</span>))</span><br><span class="line">        <span class="keyword">if</span> reverseNum &lt; -(<span class="number">2</span>**<span class="number">31</span>) <span class="keyword">or</span> reverseNum &gt; (<span class="number">2</span>**<span class="number">31</span>)<span class="number">-1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> reverseNum <span class="keyword">if</span> x&gt;<span class="number">0</span> <span class="keyword">else</span> -reverseNum</span><br></pre></td></tr></table></figure><p>将计算过程画出来如下：</p><p><img src="http://m-markdown-image.oss-cn-beijing.aliyuncs.com/2018-12-08-IMG_3723.JPG" alt=""></p><hr><h3 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h3><ul><li><a href="https://leetcode.com/problems/reverse-integer/" target="_blank" rel="noopener">题目链接</a></li><li><a href="https://blog.csdn.net/huzq1976/article/details/51581330" target="_blank" rel="noopener">python中的除法，取整和求模 - CSDN博客</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> LeetCode日记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>【easy】Longest Substring Without Repeating Characters</title>
      <link href="/LeetCode-009-Palindrome%20Number.html"/>
      <url>/LeetCode-009-Palindrome%20Number.html</url>
      
        <content type="html"><![CDATA[<p>Determine whether an integer is a palindrome. An integer is a palindrome when it reads the same backward as forward.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: 121</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure><a id="more"></a><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: -121</span><br><span class="line">Output: false</span><br><span class="line">Explanation: From left to right, it reads -121. From right to left, it becomes 121-. Therefore it is not a palindrome.</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: 10</span><br><span class="line">Output: false</span><br><span class="line">Explanation: Reads 01 from right to left. Therefore it is not a palindrome.</span><br></pre></td></tr></table></figure><p><strong>Follow up:</strong></p><p>Coud you solve it without converting the integer to a string?</p><p>本题比较简单，可以直接套用<code>Reverse Integer</code>里面的第二种方法，就直接贴代码吧</p><hr><h3 id="代码实现："><a href="#代码实现：" class="headerlink" title="代码实现："></a>代码实现：</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isPalindrome</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">  :type x: int</span></span><br><span class="line"><span class="string">  :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line"><span class="keyword">if</span> x &lt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            a = x</span><br><span class="line">            b, reverse = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">            temp = []</span><br><span class="line">            <span class="keyword">while</span> a != <span class="number">0</span>:</span><br><span class="line">                b = a % <span class="number">10</span></span><br><span class="line">                a //= <span class="number">10</span></span><br><span class="line">                temp.append(b)</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(len(temp)):</span><br><span class="line">                reverse += temp[i]*(<span class="number">10</span>**(len(temp)-i<span class="number">-1</span>))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">True</span> <span class="keyword">if</span> reverse == x <span class="keyword">else</span> <span class="keyword">False</span></span><br></pre></td></tr></table></figure><hr><h3 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h3><ul><li><a href="https://leetcode.com/problems/palindrome-number/" target="_blank" rel="noopener">题目链接</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> LeetCode日记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>【easy】Roman to Integer</title>
      <link href="/LeetCode-013-Roman%20to%20Integer.html"/>
      <url>/LeetCode-013-Roman%20to%20Integer.html</url>
      
        <content type="html"><![CDATA[<p>Roman numerals are represented by seven different symbols: <code>I</code>, <code>V</code>, <code>X</code>, <code>L</code>, <code>C</code>, <code>D</code> and <code>M</code>.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Symbol       Value</span><br><span class="line">I             1</span><br><span class="line">V             5</span><br><span class="line">X             10</span><br><span class="line">L             50</span><br><span class="line">C             100</span><br><span class="line">D             500</span><br><span class="line">M             1000</span><br></pre></td></tr></table></figure><a id="more"></a><p>For example, two is written as <code>II</code> in Roman numeral, just two one’s added together. Twelve is written as, <code>XII</code>, which is simply <code>X</code> + <code>II</code>. The number twenty seven is written as <code>XXVII</code>, which is <code>XX</code> + <code>V</code> + <code>II</code>.</p><p>Roman numerals are usually written largest to smallest from left to right. However, the numeral for four is not <code>IIII</code>. Instead, the number four is written as <code>IV</code>. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as <code>IX</code>. There are six instances where subtraction is used:</p><ul><li><code>I</code> can be placed before <code>V</code> (5) and <code>X</code> (10) to make 4 and 9. </li><li><code>X</code> can be placed before <code>L</code> (50) and <code>C</code> (100) to make 40 and 90. </li><li><code>C</code> can be placed before <code>D</code> (500) and <code>M</code> (1000) to make 400 and 900.</li></ul><p>Given a roman numeral, convert it to an integer. Input is guaranteed to be within the range from 1 to 3999.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;III&quot;</span><br><span class="line">Output: 3</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;IV&quot;</span><br><span class="line">Output: 4</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;IX&quot;</span><br><span class="line">Output: 9</span><br></pre></td></tr></table></figure><p><strong>Example 4:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;LVIII&quot;</span><br><span class="line">Output: 58</span><br><span class="line">Explanation: L = 50, V= 5, III = 3.</span><br></pre></td></tr></table></figure><p><strong>Example 5:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;MCMXCIV&quot;</span><br><span class="line">Output: 1994</span><br><span class="line">Explanation: M = 1000, CM = 900, XC = 90 and IV = 4.</span><br></pre></td></tr></table></figure><p>题目好长，其实主要就是要理解罗马数字规则，理解了规则还是很好写出来的，题目没说要做错误判断，即测试的数据都是正确的罗马数字，所以后面的代码也没对罗马数字的正确与否做判断，默认正确的情况下进行处理。</p><hr><h3 id="代码实现："><a href="#代码实现：" class="headerlink" title="代码实现："></a>代码实现：</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">romanToInt</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        dict = &#123;<span class="string">'I'</span>: <span class="number">1</span>, <span class="string">'V'</span>: <span class="number">5</span>, <span class="string">'X'</span>: <span class="number">10</span>, <span class="string">'L'</span>: <span class="number">50</span>, <span class="string">'C'</span>: <span class="number">100</span>, <span class="string">'D'</span>: <span class="number">500</span>, <span class="string">'M'</span>: <span class="number">1000</span>&#125;</span><br><span class="line">        length, sum, cursor = len(s), <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> cursor &lt; length:</span><br><span class="line">            <span class="keyword">if</span> cursor == length - <span class="number">1</span>:</span><br><span class="line">                sum += dict[s[cursor]]</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                flag = dict[s[cursor + <span class="number">1</span>]] // dict[s[cursor]]</span><br><span class="line">                <span class="keyword">if</span> flag &lt;= <span class="number">1</span>:</span><br><span class="line">                    sum += dict[s[cursor]]</span><br><span class="line">                    cursor += <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    sum += (dict[s[cursor + <span class="number">1</span>]] - dict[s[cursor]])</span><br><span class="line">                    cursor += <span class="number">2</span></span><br><span class="line">        <span class="keyword">return</span> sum</span><br></pre></td></tr></table></figure><hr><h3 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h3><ul><li><a href="https://leetcode.com/problems/roman-to-integer/" target="_blank" rel="noopener">题目链接</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> LeetCode日记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>【easy】Longest Common Prefix</title>
      <link href="/LeetCode-014-Longest%20Common%20Prefix.html"/>
      <url>/LeetCode-014-Longest%20Common%20Prefix.html</url>
      
        <content type="html"><![CDATA[<p>Write a function to find the longest common prefix string amongst an array of strings.</p><p>If there is no common prefix, return an empty string <code>&quot;&quot;</code>.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [&quot;flower&quot;,&quot;flow&quot;,&quot;flight&quot;]</span><br><span class="line">Output: &quot;fl&quot;</span><br></pre></td></tr></table></figure><a id="more"></a><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [&quot;dog&quot;,&quot;racecar&quot;,&quot;car&quot;]</span><br><span class="line">Output: &quot;&quot;</span><br><span class="line">Explanation: There is no common prefix among the input strings.</span><br></pre></td></tr></table></figure><hr><h3 id="思路分析："><a href="#思路分析：" class="headerlink" title="思路分析："></a>思路分析：</h3><ul><li>审题真的很重要，开始花了大量时间，结果写成了获得最长公共子串，提交总失败，后来又看了看题目，才发现是最长公共前缀，不过还好，有了前面的思考容量，公共前缀很好写了。我的想法是首先找出序列中最短的字符串，由这个字符串下手，从<strong>大到小进行切片</strong>，并与其它字符串的前缀进行比较。这时如果成功找到第一个前缀，即可退出循环，因为是从大到小进行的切片。详细还是见代码块 1.1<br>[注]：最长公共子串也放到代码块 1.2 了（这个竟花了大半天，哎，菜是原罪）</li></ul><hr><h3 id="代码实现："><a href="#代码实现：" class="headerlink" title="代码实现："></a>代码实现：</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestCommonPrefix</span><span class="params">(self, strs)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">  :type***strs: List[str]</span></span><br><span class="line"><span class="string">  :rtype***: str</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line"><span class="keyword">if</span> strs:</span><br><span class="line">            <span class="comment">#首先找到列表中最短的字符串及其长度</span></span><br><span class="line">            shortStr = strs[<span class="number">0</span>]</span><br><span class="line">            shortLength = len(strs[<span class="number">0</span>])</span><br><span class="line">            <span class="keyword">for</span> s <span class="keyword">in</span> strs[<span class="number">1</span>:]:</span><br><span class="line">                <span class="keyword">if</span> len(s) &lt; shortLength:</span><br><span class="line">                    shortStr = s</span><br><span class="line">            cursor = shortLength</span><br><span class="line">            strs.remove(shortStr)</span><br><span class="line">            flag = <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> cursor &gt; <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">for</span> s <span class="keyword">in</span> strs:</span><br><span class="line">  <span class="comment">#注意，这里是找公共前缀，那么该字符串必然是其他字符串的前缀</span></span><br><span class="line">  <span class="comment">#而不能简单的用 not in s 来判断</span></span><br><span class="line">                    <span class="keyword">if</span> shortStr[:cursor] != s[:cursor]:</span><br><span class="line">                        flag = <span class="number">0</span></span><br><span class="line">                        <span class="keyword">break</span></span><br><span class="line">                <span class="keyword">if</span> flag:</span><br><span class="line">                    <span class="keyword">return</span> shortStr[:cursor]</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    cursor -= <span class="number">1</span></span><br><span class="line">                    flag = <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> <span class="string">''</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">''</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestCommonPrefix</span><span class="params">(self, strs)</span>:</span></span><br><span class="line">  <span class="keyword">if</span> strs:</span><br><span class="line">            shortStr = strs[<span class="number">0</span>]</span><br><span class="line">            shortLength = len(strs[<span class="number">0</span>])</span><br><span class="line">            <span class="keyword">for</span> s <span class="keyword">in</span> strs[<span class="number">1</span>:]:</span><br><span class="line">                <span class="keyword">if</span> len(s) &lt; shortLength:</span><br><span class="line">                    shortStr = s</span><br><span class="line">                    shortLength = len(s)</span><br><span class="line">            cursor = <span class="number">0</span></span><br><span class="line">            gap = shortLength</span><br><span class="line">            flag = <span class="number">1</span></span><br><span class="line">            <span class="comment">#注意list的remove方法删除特定元素后，并无返回值</span></span><br><span class="line">            <span class="comment">#执行完毕后list的相应元素已经被删除了</span></span><br><span class="line">            strs.remove(shortStr)</span><br><span class="line">            <span class="keyword">while</span> gap &gt; <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">if</span> cursor + gap &gt; shortLength:</span><br><span class="line">                    gap -= <span class="number">1</span></span><br><span class="line">                    cursor = <span class="number">0</span></span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">for</span> s <span class="keyword">in</span> strs:</span><br><span class="line">                        <span class="keyword">if</span> shortStr[cursor:cursor + gap] <span class="keyword">not</span> <span class="keyword">in</span> s:</span><br><span class="line">                            flag = <span class="number">0</span></span><br><span class="line">                            <span class="keyword">break</span></span><br><span class="line">                    <span class="keyword">if</span> flag:</span><br><span class="line">                        <span class="keyword">return</span> shortStr[cursor:cursor + gap]</span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        cursor += <span class="number">1</span></span><br><span class="line">                        flag = <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> <span class="string">''</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">''</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    sol = Solution()</span><br><span class="line">    print(sol.longestCommonPrefix([<span class="string">"dog"</span>,<span class="string">"racogecar"</span>,<span class="string">"cogar"</span>]))</span><br><span class="line">    print(sol.longestCommonPrefix([<span class="string">"dog"</span>,<span class="string">"racggecar"</span>,<span class="string">"cogar"</span>]))</span><br></pre></td></tr></table></figure><p><img src="http://m-markdown-image.oss-cn-beijing.aliyuncs.com/2018-12-08-%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-21%2016.58.37.png" alt=""></p><p>简单测试了一下应该是没有问题的。当时在写的时候循环判断那里折腾了好久，比如：</p><ul><li>忘记加 continue 语句</li><li>在当前循环中将标志位<code>flag</code>设为 0 后，开始新循环后并没有将<code>flag</code>恢复成 1</li></ul>]]></content>
      
      
      <categories>
          
          <category> LeetCode日记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 字符串公共前缀 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>【easy】Valid Parentheses</title>
      <link href="/LeetCode-020-Valid%20Parentheses.html"/>
      <url>/LeetCode-020-Valid%20Parentheses.html</url>
      
        <content type="html"><![CDATA[<p>Given a string containing just the characters <code>&#39;(&#39;</code>, <code>&#39;)&#39;</code>, <code>&#39;{&#39;</code>, <code>&#39;}&#39;</code>, <code>&#39;[&#39;</code> and <code>&#39;]&#39;</code>, determine if the input string is valid.</p><p>An input string is valid if:</p><ol><li>Open brackets must be closed by the same type of brackets.</li><li>Open brackets must be closed in the correct order.</li></ol><p>Note that an empty string is also considered valid.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;()&quot;</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure><a id="more"></a><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;()[]&#123;&#125;&quot;</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;(]&quot;</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure><p><strong>Example 4:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;([)]&quot;</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure><p><strong>Example 5:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;&#123;[]&#125;&quot;</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure><hr><h3 id="思路分析："><a href="#思路分析：" class="headerlink" title="思路分析："></a>思路分析：</h3><ul><li>因为就是单单判断括号匹配，没有加入运算，所以思路很简单，遍历字符串，若是左括号，则进栈，否则判断栈顶元素是否与之匹配，若匹配则让栈顶元素出栈并继续循环，若不匹配直接返回<code>False</code>退出循环。但是需要注意的是最后循环结束后，若栈中还剩元素，则还是需要返回<code>False</code></li></ul><hr><h3 id="代码实现："><a href="#代码实现：" class="headerlink" title="代码实现："></a>代码实现：</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isValid</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">  :type***s: str</span></span><br><span class="line"><span class="string">  :rtype***: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line"><span class="keyword">if</span> len(s) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            matchs = &#123;<span class="string">'('</span>: <span class="string">')'</span>, <span class="string">'['</span>: <span class="string">']'</span>, <span class="string">'&#123;'</span>: <span class="string">'&#125;'</span>&#125;</span><br><span class="line">            stack = []</span><br><span class="line">            <span class="keyword">for</span> s <span class="keyword">in</span> s:</span><br><span class="line">                <span class="keyword">if</span> s <span class="keyword">in</span> matchs:</span><br><span class="line">                    stack.append(s)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">if</span> stack:</span><br><span class="line">                        <span class="keyword">if</span> matchs.get(stack[len(stack)<span class="number">-1</span>]) == s:</span><br><span class="line">                            stack.pop()</span><br><span class="line">                        <span class="keyword">else</span>:</span><br><span class="line">                            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span> <span class="keyword">if</span> stack <span class="keyword">else</span> <span class="keyword">True</span></span><br></pre></td></tr></table></figure><p>开始提交时总错误，还是考虑问题不够全面，只考虑了正常情况。另外，字典的遍历在前面<code>读取 txt 内容，写入 xls 文件</code>中写过了。在写这个题的时候就有写一个简单的栈的想法，刚好在<code>LeetCode</code>上找到了这种题，那下篇就撸个简单的栈吧。</p><hr><h3 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h3><ul><li><a href="https://leetcode.com/problems/valid-parentheses/" target="_blank" rel="noopener">题目链接</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> LeetCode日记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 栈 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>【easy】Merge Two Sorted Lists</title>
      <link href="/LeetCode-021-Merge%20Two%20Sorted%20Lists.html"/>
      <url>/LeetCode-021-Merge%20Two%20Sorted%20Lists.html</url>
      
        <content type="html"><![CDATA[<p>Merge two sorted linked lists and return it as a new list. The new list should be made by splicing together the nodes of the first two lists.</p><p><strong>Example:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: 1-&gt;2-&gt;4, 1-&gt;3-&gt;4</span><br><span class="line">Output: 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4</span><br></pre></td></tr></table></figure><p>题目就是要合并2个有序的列表，方法也就是同时遍历2个列表，比较元素并把较小的添加到结果链表中。</p><a id="more"></a><hr><h3 id="代码实现："><a href="#代码实现：" class="headerlink" title="代码实现："></a>代码实现：</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mergeTwoLists</span><span class="params">(self, l1, l2)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type l1: ListNode</span></span><br><span class="line"><span class="string">        :type l2: ListNode</span></span><br><span class="line"><span class="string">        :rtype: ListNode</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        head = cursor = ListNode(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">while</span> l1 <span class="keyword">and</span> l2:</span><br><span class="line">            <span class="keyword">if</span> l1.val &lt;= l2.val:</span><br><span class="line">                cursor.next = ListNode(l1.val)</span><br><span class="line">                l1 = l1.next</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                cursor.next = ListNode(l2.val)</span><br><span class="line">                l2 = l2.next</span><br><span class="line">            cursor = cursor.next</span><br><span class="line">        <span class="keyword">while</span> l1:</span><br><span class="line">            cursor.next = ListNode(l1.val)</span><br><span class="line">            l1 = l1.next</span><br><span class="line">            cursor = cursor.next</span><br><span class="line">        <span class="keyword">while</span> l2:</span><br><span class="line">            cursor.next = ListNode(l2.val)</span><br><span class="line">            l2 = l2.next</span><br><span class="line">            cursor = cursor.next</span><br><span class="line">        <span class="keyword">return</span> head.next</span><br></pre></td></tr></table></figure><p>这里有点蠢的就是当有一个链表遍历结束后，我竟然还对另外的链表继续遍历！！直接将另外的<br>链表给<code>cursor</code>就好了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mergeTwoLists</span><span class="params">(self, l1, l2)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type l1: ListNode</span></span><br><span class="line"><span class="string">        :type l2: ListNode</span></span><br><span class="line"><span class="string">        :rtype: ListNode</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        head = cursor = ListNode(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">while</span> l1 <span class="keyword">and</span> l2:</span><br><span class="line">            <span class="keyword">if</span> l1.val &lt;= l2.val:</span><br><span class="line">                cursor.next = ListNode(l1.val)</span><br><span class="line">                l1 = l1.next</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                cursor.next = ListNode(l2.val)</span><br><span class="line">                l2 = l2.next</span><br><span class="line">            cursor = cursor.next</span><br><span class="line">        cursor.next = l1 <span class="keyword">if</span> l1 <span class="keyword">else</span> l2</span><br><span class="line">        <span class="keyword">return</span> head.next</span><br></pre></td></tr></table></figure><hr><h3 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h3><ul><li><a href="https://leetcode.com/problems/merge-two-sorted-lists/" target="_blank" rel="noopener">题目链接</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> LeetCode日记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>【easy】Remove Duplicates from Sorted Array</title>
      <link href="/LeetCode-026-Remove%20Duplicates%20from%20Sorted%20Array.html"/>
      <url>/LeetCode-026-Remove%20Duplicates%20from%20Sorted%20Array.html</url>
      
        <content type="html"><![CDATA[<p>Given a sorted array <em>nums</em>, remove the duplicates <a href="https://en.wikipedia.org/wiki/In-place_algorithm" target="_blank" rel="noopener"><strong>in-place</strong></a> such that each element appear only <em>once</em> and return the new length.</p><p>Do not allocate extra space for another array, you must do this by <strong>modifying the input array in-place</strong> with O(1) extra memory.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Given nums = [1,1,2],</span><br><span class="line"></span><br><span class="line">Your function should return length = 2, with the first two elements of nums being 1 and 2 respectively.</span><br><span class="line"></span><br><span class="line">It doesn&apos;t matter what you leave beyond the returned length.</span><br></pre></td></tr></table></figure><a id="more"></a><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Given nums = [0,0,1,1,1,2,2,3,3,4],</span><br><span class="line"></span><br><span class="line">Your function should return length = 5, with the first five elements of nums being modified to 0, 1, 2, 3, and 4 respectively.</span><br><span class="line"></span><br><span class="line">It doesn&apos;t matter what values are set beyond the returned length.</span><br></pre></td></tr></table></figure><p>题目要求的是原地操作，即不能开辟新空间</p><hr><h3 id="思路分析："><a href="#思路分析：" class="headerlink" title="思路分析："></a>思路分析：</h3><ul><li><p>用快慢指针的思想，针对本题，初始化令慢指针指向第一个元素，令快指针指向第二个元素：</p><p>若快慢指针所指向的2个值不相等：慢指针先前进一步，将当前指向的元素修改为快指针所指的元素，然后快指针再前进一步</p><p>若相等：则快慢指针都向前走一步就好</p><p>最后当快指针走到末尾时退出循环，文字表述实在太蛋疼，画张图吧（注意图上红色的地方，表示着对原列表的修改。）：</p><p><img src="http://m-markdown-image.oss-cn-beijing.aliyuncs.com/2018-12-10-IMG_3738.JPG" alt=""></p></li></ul><hr><h3 id="代码实现："><a href="#代码实现：" class="headerlink" title="代码实现："></a>代码实现：</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeDuplicates</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        i, j = <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">        length = len(nums)</span><br><span class="line">        <span class="keyword">if</span> length &lt; <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> len(nums)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">while</span> j &lt; length:</span><br><span class="line">                <span class="keyword">if</span> nums[i] == nums[j]:</span><br><span class="line">                    j += <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    i += <span class="number">1</span></span><br><span class="line">                    nums[i] = nums[j]</span><br><span class="line">                    j += <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> i+<span class="number">1</span></span><br></pre></td></tr></table></figure><hr><h3 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h3><ul><li><a href="https://leetcode.com/problems/remove-duplicates-from-sorted-array/" target="_blank" rel="noopener">题目链接</a></li><li><a href="https://medium.com/@urdreamliu/26-%E5%9C%96%E8%A7%A3-remove-duplicates-from-sorted-array-cbee5b2d4df8" target="_blank" rel="noopener">26.圖解Remove Duplicates from Sorted Array</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> LeetCode日记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>【easy】Remove Element</title>
      <link href="/LeetCode-027-Remove%20Element.html"/>
      <url>/LeetCode-027-Remove%20Element.html</url>
      
        <content type="html"><![CDATA[<p>Given an array <em>nums</em> and a value <em>val</em>, remove all instances of that value <a href="https://en.wikipedia.org/wiki/In-place_algorithm" target="_blank" rel="noopener"><strong>in-place</strong></a> and return the new length.</p><p>Do not allocate extra space for another array, you must do this by <strong>modifying the input array in-place</strong> with O(1) extra memory.</p><p>The order of elements can be changed. It doesn’t matter what you leave beyond the new length.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Given nums = [3,2,2,3], val = 3,</span><br><span class="line"></span><br><span class="line">Your function should return length = 2, with the first two elements of nums being 2.</span><br><span class="line"></span><br><span class="line">It doesn&apos;t matter what you leave beyond the returned length.</span><br></pre></td></tr></table></figure><a id="more"></a><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Given nums = [0,1,2,2,3,0,4,2], val = 2,</span><br><span class="line"></span><br><span class="line">Your function should return length = 5, with the first five elements of nums containing 0, 1, 3, 0, and 4.</span><br><span class="line"></span><br><span class="line">Note that the order of those five elements can be arbitrary.</span><br><span class="line"></span><br><span class="line">It doesn&apos;t matter what values are set beyond the returned length.</span><br></pre></td></tr></table></figure><p>注意这里题目的要求，只能对原列表进行操作，而不能创建新的列表</p><hr><h3 id="思路分析："><a href="#思路分析：" class="headerlink" title="思路分析："></a>思路分析：</h3><ul><li><p>这题的思路和上一题<code>Remove Duplicates from Sorted Array</code>的思路很像，都是利用了快慢指针来处理，首先快慢指针初始化都指向第一个元素，比较快指针所指向的值与给定要删除元素的关系：<br>​    若不等：则判断快慢指针是否指向同一位置：<br>​        若不是，则需将快指针所指的元素赋给慢指针所指的位置，再将快慢指针都走一步<br>​    若相等：则只走快指针<br>画个图帮助理解：</p><p><img src="http://m-markdown-image.oss-cn-beijing.aliyuncs.com/2018-12-08-IMG_3724.JPG" alt=""></p></li></ul><hr><h3 id="代码实现："><a href="#代码实现：" class="headerlink" title="代码实现："></a>代码实现：</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeElement</span><span class="params">(self, nums, val)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">  :type nums: List[int]</span></span><br><span class="line"><span class="string">  :type val: int</span></span><br><span class="line"><span class="string">  :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">  i = j = <span class="number">0</span></span><br><span class="line">        length = len(nums)</span><br><span class="line">        <span class="keyword">while</span> j &lt; length:</span><br><span class="line">            <span class="keyword">if</span> nums[j] == val:</span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> i != j:</span><br><span class="line">                    nums[i] = nums[j]</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> i</span><br></pre></td></tr></table></figure><hr><h3 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h3><ul><li><a href="https://leetcode.com/problems/remove-element/" target="_blank" rel="noopener">题目链接</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> LeetCode日记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>【easy】Implement strStr()</title>
      <link href="/LeetCode-028-Implement%20strStr().html"/>
      <url>/LeetCode-028-Implement%20strStr().html</url>
      
        <content type="html"><![CDATA[<p>Implement <a href="http://www.cplusplus.com/reference/cstring/strstr/" target="_blank" rel="noopener">strStr()</a>.</p><p>Return the index of the first occurrence of needle in haystack, or <strong>-1</strong> if needle is not part of haystack.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: haystack = &quot;hello&quot;, needle = &quot;ll&quot;</span><br><span class="line">Output: 2</span><br></pre></td></tr></table></figure><a id="more"></a><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: haystack = &quot;aaaaa&quot;, needle = &quot;bba&quot;</span><br><span class="line">Output: -1</span><br></pre></td></tr></table></figure><p>本题很简单，就是简单的遍历<code>haystack</code> ，根据<code>needle</code>的长度切片比较，若相同则直接返回此时的<code>index</code>，若遍历结束则说明没有找到，返回 -1</p><hr><h3 id="代码实现："><a href="#代码实现：" class="headerlink" title="代码实现："></a>代码实现：</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">strStr</span><span class="params">(self, haystack, needle)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type haystack: str</span></span><br><span class="line"><span class="string">        :type needle: str</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        minLen = len(needle)</span><br><span class="line">        maxLen = len(haystack)</span><br><span class="line">        index = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> index &lt;= maxLen-minLen:</span><br><span class="line">            <span class="keyword">if</span> haystack[index:index+minLen] == needle:</span><br><span class="line">                <span class="keyword">return</span> index</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                index +=<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure><hr><h3 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h3><ul><li><a href="https://leetcode.com/problems/implement-strstr/" target="_blank" rel="noopener">题目链接</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> LeetCode日记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 字符串 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>【medium】Longest Substring Without Repeating Characters</title>
      <link href="/LeetCode-003-Longest%20Substring%20Without%20Repeating%20Characters.html"/>
      <url>/LeetCode-003-Longest%20Substring%20Without%20Repeating%20Characters.html</url>
      
        <content type="html"><![CDATA[<p>Given a string, find the length of the <strong>longest substring</strong> without repeating characters.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;abcabcbb&quot;</span><br><span class="line">Output: 3 </span><br><span class="line">Explanation: The answer is &quot;abc&quot;, with the length of 3.</span><br></pre></td></tr></table></figure><a id="more"></a><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;bbbbb&quot;</span><br><span class="line">Output: 1</span><br><span class="line">Explanation: The answer is &quot;b&quot;, with the length of 1.</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;pwwkew&quot;</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: The answer is &quot;wke&quot;, with the length of 3. </span><br><span class="line">             Note that the answer must be a substring, &quot;pwke&quot; is a subsequence and not a substring.</span><br></pre></td></tr></table></figure><p>首先解读一下题目，要求字符串的最长无重复子串的长度，而不是求无重复子序列（子串要连续，而子序列可以不连续）</p><hr><h3 id="思路分析："><a href="#思路分析：" class="headerlink" title="思路分析："></a>思路分析：</h3><p>本题属于中等难度，我没有想出方法来解决，也没必要死耗，于是打算中等难度的题目先看网上的解决方案，然后理解其思想，自己演算，自己撸码。</p><ul><li>用滑动窗口来解决，即设左右 2 个指针，维持一个窗口，保证窗口内的元素无重复，其实就是前面的快慢指针思想。还要有一个 hashmap 来存窗口内元素和下标的映射关系，方便移动左右指针。从头遍历字符串：<br>若元素不在哈希表内，则直接加入哈希表（移动右指针），即扩大窗口<br>若在哈希表内：<br>​    若该元素在哈希表中对应的下标小于左指针，什么操作都没有<br>​    否则，移动左指针，即缩小窗口<br>​    添加该元素及其下标到哈希表中<br>记录当前窗口大小，判断是否更新结果</li></ul><p><img src="http://m-markdown-image.oss-cn-beijing.aliyuncs.com/2018-12-08-IMG_3726.JPG" alt=""></p><hr><h3 id="代码实现："><a href="#代码实现：" class="headerlink" title="代码实现："></a>代码实现：</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">  :type s: str</span></span><br><span class="line"><span class="string">  :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">hashMap = dict()</span><br><span class="line">        left, right = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        length = len(s)</span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> right &lt; length:</span><br><span class="line">            <span class="keyword">if</span> hashMap:</span><br><span class="line">                <span class="keyword">if</span> s[right] <span class="keyword">in</span> hashMap:</span><br><span class="line">                    <span class="comment">#这种情况第一次写的时候没有考虑，例如 ‘abba’</span></span><br><span class="line">                    <span class="keyword">if</span> left &lt;= hashMap[s[right]]:</span><br><span class="line">                        left = hashMap[s[right]] + <span class="number">1</span></span><br><span class="line">                hashMap[s[right]] = right</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                hashMap[s[left]] = left</span><br><span class="line">                res = <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> (right-left) &gt; res<span class="number">-1</span>:</span><br><span class="line">                res = right-left+<span class="number">1</span></span><br><span class="line">            right += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><hr><h3 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h3><ul><li><a href="https://leetcode.com/problems/longest-substring-without-repeating-characters/" target="_blank" rel="noopener">题目链接</a></li><li><a href="http://www.cnblogs.com/grandyang/p/4480780.html" target="_blank" rel="noopener">LeetCode Longest Substring Without Repeating Characters 最长无重复字符的子串 - Grandyang - 博客园</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> LeetCode日记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 字符串 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>【easy】Search Insert Position</title>
      <link href="/LeetCode-035-Search%20Insert%20Position.html"/>
      <url>/LeetCode-035-Search%20Insert%20Position.html</url>
      
        <content type="html"><![CDATA[<p>Given a sorted array and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order.</p><p>You may assume no duplicates in the array.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,3,5,6], 5</span><br><span class="line">Output: 2</span><br></pre></td></tr></table></figure><a id="more"></a><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,3,5,6], 2</span><br><span class="line">Output: 1</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,3,5,6], 7</span><br><span class="line">Output: 4</span><br></pre></td></tr></table></figure><p><strong>Example 4:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,3,5,6], 0</span><br><span class="line">Output: 0</span><br></pre></td></tr></table></figure><hr><h3 id="思路分析："><a href="#思路分析：" class="headerlink" title="思路分析："></a>思路分析：</h3><ul><li>很容易想到的就是遍历查找，代码很简单，让程序去跑吧，代码见 1.1</li><li>由于题目给的是已经排好序的，所以可以尝试一下折半查找，代码见 2.1</li></ul><hr><h3 id="代码实现："><a href="#代码实现：" class="headerlink" title="代码实现："></a>代码实现：</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">searchInsert</span><span class="params">(self, nums, target)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :type target: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        length = len(nums)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(length):</span><br><span class="line">            <span class="keyword">if</span> nums[i] &gt;= target:</span><br><span class="line">                <span class="keyword">return</span> i</span><br><span class="line">        <span class="keyword">return</span> length</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">searchInsert</span><span class="params">(self, nums, target)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :type target: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        start, end = <span class="number">0</span>, len(nums) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> start &lt; end:</span><br><span class="line">            mid = (start + end) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> nums[mid] &gt; target:</span><br><span class="line">                end = mid - <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> nums[mid] &lt; target:</span><br><span class="line">                start = mid + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> mid</span><br><span class="line">        <span class="comment">#循环结束后start==end</span></span><br><span class="line">        <span class="keyword">if</span> nums[start] &gt;= target:</span><br><span class="line">            <span class="keyword">return</span> start</span><br><span class="line">        <span class="keyword">elif</span> nums[start] &lt; target:</span><br><span class="line">            <span class="keyword">return</span> start + <span class="number">1</span></span><br></pre></td></tr></table></figure><p>但是就提交后的运行时间来看，并没有太大的差距，没有道理啊。于是自行验证，整理代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> time, decimal</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">searchInsert_1</span><span class="params">(self, nums, target)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">  :type nums: List[int]</span></span><br><span class="line"><span class="string">  :type target: int</span></span><br><span class="line"><span class="string">  :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">length = len(nums)</span><br><span class="line">        sum = <span class="number">0</span></span><br><span class="line">        startTime = time.time()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(length):</span><br><span class="line">            sum += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> nums[i] &gt;= target:</span><br><span class="line">                <span class="keyword">return</span> i, sum, time.time() - startTime</span><br><span class="line">        <span class="keyword">return</span> length, sum, time.time() - startTime</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">searchInsert_2</span><span class="params">(self, nums, target)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">  :type nums: List[int]</span></span><br><span class="line"><span class="string">  :type target: int</span></span><br><span class="line"><span class="string">  :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">start, end = <span class="number">0</span>, len(nums) - <span class="number">1</span></span><br><span class="line">        sum = <span class="number">0</span></span><br><span class="line">        startTime = time.time()</span><br><span class="line">        <span class="keyword">while</span> start &lt; end:</span><br><span class="line">            sum += <span class="number">1</span></span><br><span class="line">            mid = (start + end) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> nums[mid] &gt; target:</span><br><span class="line">                end = mid - <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> nums[mid] &lt; target:</span><br><span class="line">                start = mid + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> mid, sum, time.time() - startTime</span><br><span class="line">        <span class="keyword">if</span> nums[start] &gt;= target:</span><br><span class="line">            <span class="keyword">return</span> start, sum, time.time() - startTime</span><br><span class="line">        <span class="keyword">elif</span> nums[start] &lt; target:</span><br><span class="line">            <span class="keyword">return</span> start + <span class="number">1</span>, sum, time.time() - startTime</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    list = np.random.randint(<span class="number">0</span>, <span class="number">1000000</span>, <span class="number">1000000</span>)</span><br><span class="line">    list.sort()</span><br><span class="line">    sol = Solution()</span><br><span class="line">    pos_1, times_1, time_1 = sol.searchInsert_1(list, <span class="number">1999999</span>)</span><br><span class="line">    pos_2, times_2, time_2 = sol.searchInsert_2(list, <span class="number">1999999</span>)</span><br><span class="line">    print(<span class="string">'遍历：位置&#123;&#125;, 查找&#123;&#125;次，用时&#123;&#125;s'</span>.format(pos_1, times_1, time_1))</span><br><span class="line">    print(<span class="string">'折半：位置&#123;&#125;, 查找&#123;&#125;次，用时&#123;&#125;s'</span>.format(pos_2, times_2, decimal.Decimal.from_float(time_2)))</span><br></pre></td></tr></table></figure><p><img src="http://m-markdown-image.oss-cn-beijing.aliyuncs.com/2018-12-08-%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-03%2014.31.04.png" alt=""><br>这里测试的数据集是随机产生的100w整数列表，而且考虑最差的情况，即 target 在最后，那么差距就很明显了，遍历的话要遍历完，而折半只需查找19次，用时也远远比遍历少。关于折半查找的平均时间复杂度为 log(n)</p><hr><h3 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h3><ul><li><a href="https://leetcode.com/problems/search-insert-position/" target="_blank" rel="noopener">题目链接</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> LeetCode日记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 链表 </tag>
            
            <tag> 二分查找 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>【easy】Maximum Subarray</title>
      <link href="/LeetCode-053-Maximum%20Subarray.html"/>
      <url>/LeetCode-053-Maximum%20Subarray.html</url>
      
        <content type="html"><![CDATA[<p>Given an integer array <code>nums</code>, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum.</p><p><strong>Example:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [-2,1,-3,4,-1,2,1,-5,4],</span><br><span class="line">Output: 6</span><br><span class="line">Explanation: [4,-1,2,1] has the largest sum = 6.</span><br></pre></td></tr></table></figure><p>本题是一个求最大子序列和的问题，虽标注为 easy 难度，可是真不简单啊，上网一搜才发现是个经典题。</p><a id="more"></a><hr><h3 id="思路分析："><a href="#思路分析：" class="headerlink" title="思路分析："></a>思路分析：</h3><ul><li><p>暴力方法，我好像也只能想出这种思考容量小的方法了，哎。三重循环，想想就可怕。</p><p>第一层：维护一个窗口的大小，从 0 到数组的长度；</p><p>第二层：确定窗口的起始位置，即从 0 到数组的长度-窗口大小；</p><p>第三层：遍历窗口内的元素并相加，判断是否为最大和。</p></li><li><p>Kadane算法思想（通俗版）:如果从头遍历整个列表，那么每个元素就只有 2 个选择：</p><p>​    1.加入前面的子序列</p><p>​    2.自己另起炉灶，成为另一个子序列的头元素</p><p>那么它将如何选择呢？这时候就要做一个判断：若我加入后，咱们序列的总和比我还小，那我还加入你们干嘛，拖我后退嘛，我要自己另起一个子序列。而若我加入后，咱们序列的总和比我大了，那还说什么呢？赶紧加入啊，大佬带带我。另外维护一个全局的最大和就行了。</p></li></ul><p>[注]：看网上很多说这里的第二种思路就是动态规划（动态规划原来学过，但现在仅存的映像是见过这 4 个字，赶紧偷偷去查下），<strong>动态规划的核心思想就是记住已经求过的解</strong>，详细的可以看下面贴的链接。</p><hr><h3 id="代码实现："><a href="#代码实现：" class="headerlink" title="代码实现："></a>代码实现：</h3><figure class="highlight python"><figcaption><span>1.1</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxSubArray</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        wsize = <span class="number">0</span></span><br><span class="line">        maxSum = nums[<span class="number">0</span>]</span><br><span class="line">        length = len(nums)</span><br><span class="line">        temp = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> wsize &lt; length:</span><br><span class="line">            <span class="keyword">for</span> start <span class="keyword">in</span> range(length - wsize):</span><br><span class="line">                <span class="keyword">for</span> value <span class="keyword">in</span> nums[start:start + wsize + <span class="number">1</span>]:</span><br><span class="line">                    temp += value</span><br><span class="line">                    maxSum = max(temp, maxSum)</span><br><span class="line">                temp = <span class="number">0</span></span><br><span class="line">            wsize += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> maxSum</span><br></pre></td></tr></table></figure><p><img src="http://m-markdown-image.oss-cn-beijing.aliyuncs.com/2018-12-04-%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-04%2014.04.15.png" alt=""></p><p>果不其然超时了，我拿这里测试用例在自己电脑上也跑了大几秒，以后这种 3 重循环的代码还是别写了，太丢人</p><figure class="highlight python"><figcaption><span>2.1</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxSubArray</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        tempSum, maxSum = nums[<span class="number">0</span>], nums[<span class="number">0</span>]</span><br><span class="line">        length = len(nums)</span><br><span class="line">        <span class="keyword">for</span> value <span class="keyword">in</span> nums[<span class="number">1</span>:]:</span><br><span class="line">            tempSum = max(value, value + tempSum)</span><br><span class="line">            maxSum = max(tempSum, maxSum)</span><br><span class="line">        <span class="keyword">return</span> maxSum</span><br></pre></td></tr></table></figure><p>明显优雅了很多，也同样在电脑上跑了一下测试用例，嗖的一下就出来了，瞬间感觉我就是个小学生！我也要变强！充钱行吗？</p><hr><h3 id="推荐阅读："><a href="#推荐阅读：" class="headerlink" title="推荐阅读："></a>推荐阅读：</h3><ul><li><p><a href="https://leetcode.com/problems/maximum-subarray/" target="_blank" rel="noopener">题目链接</a></p></li><li><p><a href="https://en.wikipedia.org/wiki/Maximum_subarray_problem" target="_blank" rel="noopener">Maximum subarray problem</a></p></li><li><a href="https://blog.csdn.net/u013309870/article/details/75193592" target="_blank" rel="noopener">算法-动态规划 Dynamic Programming–从菜鸟到老鸟</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> LeetCode日记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 动态规划 </tag>
            
            <tag> 最大子序列 </tag>
            
            <tag> 经典题 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>给图片添加数字（python）</title>
      <link href="/%E7%BB%99%E5%9B%BE%E7%89%87%E6%B7%BB%E5%8A%A0%E6%95%B0%E5%AD%97%EF%BC%88python%EF%BC%89.html"/>
      <url>/%E7%BB%99%E5%9B%BE%E7%89%87%E6%B7%BB%E5%8A%A0%E6%95%B0%E5%AD%97%EF%BC%88python%EF%BC%89.html</url>
      
        <content type="html"><![CDATA[<h3 id="给图片添加数字（类似消息提醒）"><a href="#给图片添加数字（类似消息提醒）" class="headerlink" title="给图片添加数字（类似消息提醒）"></a>给图片添加数字（类似消息提醒）</h3><p>将你的 QQ 头像（或者微博头像）右上角加上红色的数字，类似于微信未读信息数量那种提示效果。 类似于图中效果:</p><p><img src="http://m-markdown-image.oss-cn-beijing.aliyuncs.com/18-10-9/19658527.jpg" alt=""></p><a id="more"></a><hr><p><strong>思路：</strong>要实现该效果，可以用图片处理库<code>Pillow</code>库，具体用到了其中的<code>Image Module</code>、<code>ImageDraw Module</code>、<code>ImageFont Module</code>、<code>ImageColor Module</code>，下面上具体代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#引入需要的Module</span></span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image, ImageDraw, ImageColor, ImageFont</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">addToPic</span><span class="params">(img)</span>:</span></span><br><span class="line">    <span class="comment">#创建一个Draw对象</span></span><br><span class="line">    draw = ImageDraw.Draw(img)</span><br><span class="line">    <span class="comment">#创建一个字体,从系统中选择一个字体,并设置大小</span></span><br><span class="line">    mFont = ImageFont.truetype(<span class="string">'C:/windows/fonts/Arial.ttf'</span>, size = <span class="number">30</span>)</span><br><span class="line">    <span class="comment">#确定字的颜色</span></span><br><span class="line">    mColor = ImageColor.colormap.get(<span class="string">'red'</span>)</span><br><span class="line">    width, height = img.size</span><br><span class="line">    <span class="comment">#在图片上写入相应内容</span></span><br><span class="line">    draw.text((width<span class="number">-70</span>, <span class="number">0</span>), <span class="string">'hello'</span>, font=mFont, fill=mColor)</span><br><span class="line">    <span class="comment">#最后可以直接显示，或者保存</span></span><br><span class="line">    img.show()</span><br><span class="line">    img.save(<span class="string">'result.jpg'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    image = Image.open(<span class="string">'D:/浏览器下载/test.jpg'</span>)</span><br><span class="line">    addToPic(image)</span><br></pre></td></tr></table></figure><p>效果图：</p><p><img src="http://m-markdown-image.oss-cn-beijing.aliyuncs.com/18-10-9/2045502.jpg" alt=""></p><hr><h4 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h4><ul><li><p><strong>关于ImageDraw.Draw():</strong></p><p><img src="http://m-markdown-image.oss-cn-beijing.aliyuncs.com/18-10-9/77695505.jpg" alt=""></p></li><li><p><strong>关于ImageDraw.Draw.text():</strong></p><p><img src="http://m-markdown-image.oss-cn-beijing.aliyuncs.com/18-10-9/71277801.jpg" alt=""></p></li><li><p><strong>关于<code>if __name__ == &#39;__main__</code>:</strong><br>  简单粗暴的理解就是如果自己直接运行该模块，<code>__name__</code>变量的值就是<code>__main__</code>，若该模块是外部通过<code>import</code>来运行，则此时<code>__name__</code>的值就是该模块的名字，我这个文件名叫<code>test.py</code>,那么此时<code>__name__</code>就是<code>test</code></p></li><li><p>这里是在图片上写入字符串，可以用于消息提示，利用这个库同样可以做为图片添加水印，这时就是2张图片的叠加，具体方法。。。。懒癌发作</p></li></ul><hr><h4 id="拓展阅读："><a href="#拓展阅读：" class="headerlink" title="拓展阅读："></a>拓展阅读：</h4><ul><li><a href="https://pillow.readthedocs.io/en/5.3.x/" target="_blank" rel="noopener">图片处理库Pillow的官方文档</a></li><li><a href="https://www.zhihu.com/question/49136398" target="_blank" rel="noopener">知乎上关于<code>if __name__ == &#39;__main__&#39;</code>的理解，都是人才</a></li><li><a href="https://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/001431845183474e20ee7e7828b47f7b7607f2dc1e90dbb000" target="_blank" rel="noopener">廖雪峰关于<code>if __name__ == &#39;__main__&#39;</code>的理解，正常版本</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> python练习册 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> pillow库 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>读取txt内容，写入xls文件（python）</title>
      <link href="/%E8%AF%BB%E5%8F%96%20txt%20%E5%86%85%E5%AE%B9%EF%BC%8C%E5%86%99%E5%85%A5%20xls%20%E6%96%87%E4%BB%B6%EF%BC%88python%EF%BC%89.html"/>
      <url>/%E8%AF%BB%E5%8F%96%20txt%20%E5%86%85%E5%AE%B9%EF%BC%8C%E5%86%99%E5%85%A5%20xls%20%E6%96%87%E4%BB%B6%EF%BC%88python%EF%BC%89.html</url>
      
        <content type="html"><![CDATA[<p>纯文本文件 student.txt为学生信息, 里面的内容（包括花括号）如下所示，将其内容写到student.xls文件中。</p><p><img src="http://m-markdown-image.oss-cn-beijing.aliyuncs.com/python%E7%BB%83%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87/1539738853%281%29.jpg" alt=""></p><p><img src="http://m-markdown-image.oss-cn-beijing.aliyuncs.com/python%E7%BB%83%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87/1539738986%281%29.jpg" alt=""></p><a id="more"></a><p><strong>思路：</strong>观察到<code>txt</code>文件中的数据是结构化数据，于是用<code>json.loads()</code>方法将其转换成<code>python</code>的数据类型，然后利用第三方库<code>xlwt</code>向<code>.xls</code>文件中写入数据，代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> xlwt</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">txt2xls</span><span class="params">(txtPath)</span>:</span></span><br><span class="line">    <span class="keyword">with</span> open(txtPath) <span class="keyword">as</span> f:</span><br><span class="line">        wb = xlwt.Workbook()</span><br><span class="line">        ws = wb.add_sheet(<span class="string">'student'</span>)</span><br><span class="line">        mJson = json.loads(f.read())</span><br><span class="line">        print(type(mJson))</span><br><span class="line">        row = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> key,values <span class="keyword">in</span> mJson.items():</span><br><span class="line">            col = <span class="number">0</span></span><br><span class="line">            print(key, values)</span><br><span class="line">            ws.write(row, col, key)</span><br><span class="line">            <span class="keyword">for</span> value <span class="keyword">in</span> values:</span><br><span class="line">                col += <span class="number">1</span></span><br><span class="line">                ws.write(row, col, value)</span><br><span class="line">            row += <span class="number">1</span></span><br><span class="line">    wb.save(<span class="string">'C:/Users/尹鑫/Desktop/student.xls'</span>)</span><br><span class="line">    print(<span class="string">'写入成功！'</span>)</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    txt2xls(<span class="string">'C:/Users/尹鑫/Desktop/student.txt'</span>)</span><br></pre></td></tr></table></figure><p><img src="http://m-markdown-image.oss-cn-beijing.aliyuncs.com/python%E7%BB%83%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87/1539765310%281%29.jpg" alt=""></p><p><img src="http://m-markdown-image.oss-cn-beijing.aliyuncs.com/python%E7%BB%83%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87/1539765345%281%29.jpg" alt=""></p><hr><h4 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h4><ul><li><p><strong>关于首次接触的<code>json</code>库：</strong></p><p><code>json</code>库最常用的方法就<code>4</code>个：<code>json.dumps()</code>、<code>json.dump()</code>、<code>json.loads()</code>、<code>json.load()</code>。官方文档放到下面的拓展阅读里了。后面带<code>s</code>的<code>2</code>个方法<code>dumps()</code>和<code>loads()</code>是操作的“对象”的，而不带<code>s</code>的<code>2</code>个方法则是操作文件的。小例子看下：</p><ul><li><p><strong><code>dumps()</code>是将<code>python</code>对象转换为<code>json</code>字符串</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    dic = &#123;<span class="string">'姓名'</span>: <span class="string">'张三'</span>, <span class="string">'年龄'</span>: <span class="number">20</span>, <span class="string">'课程'</span>: [<span class="string">'英语'</span>, <span class="string">'数学'</span>]&#125;</span><br><span class="line">    print(type(dic))</span><br><span class="line">    jsonStr = json.dumps(dic)</span><br><span class="line">    print(type(jsonStr))</span><br><span class="line">    print(jsonStr)</span><br></pre></td></tr></table></figure><p><img src="http://m-markdown-image.oss-cn-beijing.aliyuncs.com/18-10-13/1539773007%281%29.png" alt=""></p><p>发现这里的中文不知道变成了什么鬼，其实是编码的问题，因为官方说了：</p><p><img src="http://m-markdown-image.oss-cn-beijing.aliyuncs.com/python%E7%BB%83%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87/1539773613%281%29.jpg" alt=""></p><p>所以在调用<code>dumps()</code>时明确的设置<code>ensure_ascii</code>为<code>False</code>就好了：<code>jsonStr = json.dumps(dic, ensure_ascii=False)</code>，这样输出就和输入一样了：</p><p><img src="http://m-markdown-image.oss-cn-beijing.aliyuncs.com/python%E7%BB%83%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87/1539773797%281%29.jpg" alt=""></p></li><li><p><strong><code>loads()</code>和上面<code>dumps()</code>的功能是反着的，它是将<code>json</code>格式的字符串转换为<code>python</code>对象</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    jsonStr = <span class="string">'&#123;"姓名": "张三", "年龄": 20, "课程": ["英语", "数学"]&#125;'</span></span><br><span class="line">    print(type(jsonStr))</span><br><span class="line">    pythonObj = json.loads(jsonStr)</span><br><span class="line">    print(type(pythonObj))</span><br><span class="line">    print(pythonObj)</span><br></pre></td></tr></table></figure><p><img src="http://m-markdown-image.oss-cn-beijing.aliyuncs.com/python%E7%BB%83%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87/1539774195%281%29.jpg" alt=""></p><p>注意<code>json</code>字符串中的字符串必须是用<code>&quot;&quot;</code>包起来的，不能是<code>&#39;&#39;</code>。在本题中，我是用该方法把从<code>txt</code>文件中读出来的<code>json</code>字符串转换成<code>python</code>对象，这里是转换成了字典<code>dict</code>，然后遍历字典向<code>.xls</code>文件中插入数据。</p></li><li><p><strong><code>dump()</code>是将<code>python</code>对象写入<code>json</code>文件</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    dic = &#123;<span class="string">'姓名'</span>: <span class="string">'张三'</span>, <span class="string">'年龄'</span>: <span class="number">20</span>, <span class="string">'课程'</span>: [<span class="string">'英语'</span>, <span class="string">'数学'</span>]&#125;</span><br><span class="line">    <span class="keyword">with</span> open(<span class="string">'C:/Users/尹鑫/Desktop/result.json'</span>, <span class="string">'w'</span>, encoding=<span class="string">'utf-8'</span>) <span class="keyword">as</span> f:</span><br><span class="line">        json.dump(dic, f, ensure_ascii=<span class="keyword">False</span>)</span><br></pre></td></tr></table></figure><p><img src="http://m-markdown-image.oss-cn-beijing.aliyuncs.com/python%E7%BB%83%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87/1539777298%281%29.jpg" alt=""></p><p>这里打开文件时要指出<code>encoding = &#39;utf-8&#39;</code>，并且下面调用<code>dump()</code>时也要明确<code>ensure_ascii = False</code>，这样中文才能正常显示。</p></li><li><p><strong><code>load()</code>则和上面<code>dump()</code>的功能是反着的，它是加载<code>json</code>文件，返回<code>python</code>对象</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="keyword">with</span> open(<span class="string">'C:/Users/尹鑫/Desktop/result.json'</span>, <span class="string">'r'</span>, encoding=<span class="string">'utf-8'</span>) <span class="keyword">as</span> f:</span><br><span class="line">        dic = json.load(f)</span><br><span class="line">        print(type(dic))</span><br><span class="line">        print(dic)</span><br></pre></td></tr></table></figure><p><img src="http://m-markdown-image.oss-cn-beijing.aliyuncs.com/python%E7%BB%83%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87/1539777902%281%29.jpg" alt=""></p></li></ul></li><li><p><strong>关于<code>python</code>操作<code>Excel</code>文件：</strong></p><p>这里用的是比较老的<code>xlwt</code>库，用来向<code>Excel</code>文件中写入数据，而且只支持<code>.xls</code>格式，并不支持新的<code>xlsx</code>格式。不管了，这里先用这个库实现功能把，以后需要用到其他库再去看。</p><p>常用的方法就<code>3</code>个：<code>Workbook.add_sheet()</code>、<code>Workbook.save()</code>、<code>Worksheet.write()</code>。官方解释我放下面了，这里就简单的说下。一般的使用步骤为：</p><ul><li>首先调用<code>Workbook()</code>生成<code>workbook</code>对象。</li><li>接着调用<code>workbook</code>对象的<code>add_sheet(sheetname)</code>方法，产生<code>worksheet</code>对象。</li><li>最后调用<code>worksheet</code>对象的<code>write(row, col, value)</code>方法写入数据。</li></ul><p>[注]：这里几个方法的参数我并不是严格按照官方文档来写的，一般这么用就可以了，详细的可以看下面贴的官方文档。</p><p>其实和<code>xlwt</code>对应的<code>xlrd</code>库是负责读取<code>Excel</code>文件的，但在本题中没有用到，我也就暂时不去研究了。</p></li><li><p><strong>关于字典<code>dict</code>的遍历：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#仅仅取出key</span></span><br><span class="line"><span class="keyword">for</span> key <span class="keyword">in</span> dic:<span class="keyword">for</span> key <span class="keyword">in</span> dic.keys():</span><br><span class="line"><span class="comment">#仅仅取出value</span></span><br><span class="line"><span class="keyword">for</span> value <span class="keyword">in</span> dic.values():</span><br><span class="line"><span class="comment">#取出key，value对</span></span><br><span class="line"><span class="keyword">for</span> key,value <span class="keyword">in</span> dic.items():</span><br></pre></td></tr></table></figure></li><li><p><strong>注意<code>python</code>并没有自加的操作：</strong></p><p>原来写变量的自加操作写习惯了，写在<code>python</code>中竟然报错了，查了下，大致是在<code>python</code>中，数值型和字符串是一样的，属于不可变类型，即不能在原处进行修改，详细的解释可以看下面的拓展阅读。</p></li></ul><hr><h4 id="小小拓展一下："><a href="#小小拓展一下：" class="headerlink" title="小小拓展一下："></a>小小拓展一下：</h4><ul><li><p><strong>若<code>txt</code>文件中的数据换成了下面的格式，同样将其写入<code>Excel</code>文件</strong></p><p><img src="http://m-markdown-image.oss-cn-beijing.aliyuncs.com/python%E7%BB%83%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87/1539844736%281%29.jpg" alt=""></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> xlwt</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">txt2xls</span><span class="params">(txtPath)</span>:</span></span><br><span class="line">    <span class="keyword">with</span> open(txtPath, <span class="string">'r'</span>) <span class="keyword">as</span> f:</span><br><span class="line">        wb = xlwt.Workbook()</span><br><span class="line">        ws = wb.add_sheet(<span class="string">'student'</span>)</span><br><span class="line">        dic = json.loads(f.read())</span><br><span class="line">        row = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> key, value <span class="keyword">in</span> dic.items():</span><br><span class="line">            col = <span class="number">0</span></span><br><span class="line">            ws.write(row, col, key)</span><br><span class="line">            col += <span class="number">1</span></span><br><span class="line">            ws.write(row, col, value)</span><br><span class="line">            col = <span class="number">0</span></span><br><span class="line">            row += <span class="number">1</span></span><br><span class="line">        wb.save(<span class="string">'C:/Users/尹鑫/Desktop/student.xls'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    txt2xls(<span class="string">'C:/Users/尹鑫/Desktop/student.txt'</span>)</span><br></pre></td></tr></table></figure><p><img src="http://m-markdown-image.oss-cn-beijing.aliyuncs.com/python%E7%BB%83%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87/1539845560%281%29.jpg" alt=""></p></li><li><p><strong>若<code>txt</code>文件中的数据换成了下面的格式，同样将其写入<code>Excel</code>文件</strong></p><p><img src="http://m-markdown-image.oss-cn-beijing.aliyuncs.com/python%E7%BB%83%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87/1539845669%281%29.jpg" alt=""></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> xlwt</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">txt2xls</span><span class="params">(txtPath)</span>:</span></span><br><span class="line">    <span class="keyword">with</span> open(txtPath, <span class="string">'r'</span>) <span class="keyword">as</span> f:</span><br><span class="line">        wb = xlwt.Workbook()</span><br><span class="line">        ws = wb.add_sheet(<span class="string">'student'</span>)</span><br><span class="line">        dataList = json.loads(f.read())</span><br><span class="line">        row = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> subList <span class="keyword">in</span> dataList:</span><br><span class="line">            col = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> value <span class="keyword">in</span> subList:</span><br><span class="line">                ws.write(row, col, value)</span><br><span class="line">                col += <span class="number">1</span></span><br><span class="line">            row += <span class="number">1</span></span><br><span class="line">        wb.save(<span class="string">'C:/Users/尹鑫/Desktop/student.xls'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    txt2xls(<span class="string">'C:/Users/尹鑫/Desktop/student.txt'</span>)</span><br></pre></td></tr></table></figure><p><img src="http://m-markdown-image.oss-cn-beijing.aliyuncs.com/python%E7%BB%83%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87/1539846519%281%29.jpg" alt=""></p></li></ul><hr><h4 id="拓展阅读："><a href="#拓展阅读：" class="headerlink" title="拓展阅读："></a>拓展阅读：</h4><ul><li><a href="https://docs.python.org/3.6/library/json.html?highlight=json#module-json" target="_blank" rel="noopener"><code>Json</code>库的官方文档</a></li><li><a href="https://www.jianshu.com/p/a08012f576b7" target="_blank" rel="noopener"><code>Json</code> 模块<code>dumps()</code>、<code>dump()</code>、<code>loads()</code>、<code>load()</code>的使用-简书</a></li><li><a href="https://xlwt.readthedocs.io/en/latest/api.html" target="_blank" rel="noopener"><code>xlwt</code>库官方文档</a></li><li><a href="https://www.zhihu.com/question/20913064" target="_blank" rel="noopener"><code>python</code>为什么没有自增运算符-知乎</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> python练习册 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 文件读写 </tag>
            
            <tag> xlwt库 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>【easy】Min Stack</title>
      <link href="/LeetCode-155-Min%20Stack.html"/>
      <url>/LeetCode-155-Min%20Stack.html</url>
      
        <content type="html"><![CDATA[<p>Design a stack that supports push, pop, top, and retrieving the minimum element in constant time.</p><ul><li>push(x) – Push element x onto stack.</li><li>pop() – Removes the element on top of the stack.</li><li>top() – Get the top element.</li><li>getMin() – Retrieve the minimum element in the stack.</li></ul><p><strong>Example:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">MinStack minStack = new MinStack();</span><br><span class="line">minStack.push(-2);</span><br><span class="line">minStack.push(0);</span><br><span class="line">minStack.push(-3);</span><br><span class="line">minStack.getMin();   --&gt; Returns -3.</span><br><span class="line">minStack.pop();</span><br><span class="line">minStack.top();      --&gt; Returns 0.</span><br><span class="line">minStack.getMin();   --&gt; Returns -2.</span><br></pre></td></tr></table></figure><a id="more"></a><p>开始看到这个题目，觉得挺简单的，因为前面才撸过一遍链表的实现，<code>push</code>就是尾插，<code>pop</code> 和<code>top</code> 都是在尾节点的操作（默认链表的头是栈底元素，收到了前面链表的影响）。但是撸完提交发现超时，修改后提交还是超时，才发现题目明确说了是<code>constant time</code>执行上面的方法，下面记录下心酸历程。</p><hr><h3 id="代码实现："><a href="#代码实现：" class="headerlink" title="代码实现："></a>代码实现：</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StackNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, data, next)</span>:</span></span><br><span class="line">        self.data = data</span><br><span class="line">        self.next = next</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinStack</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        initialize your data structure here.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        self.root = <span class="keyword">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type x: int</span></span><br><span class="line"><span class="string">        :rtype: void</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> self.root == <span class="keyword">None</span>:</span><br><span class="line">            self.root = StackNode(x, <span class="keyword">None</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            cursor = self.root</span><br><span class="line">            <span class="keyword">while</span> cursor.next:</span><br><span class="line">                cursor = cursor.next</span><br><span class="line">            cursor.next = StackNode(x, <span class="keyword">None</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :rtype: void</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        cursor = self.root</span><br><span class="line">        <span class="keyword">if</span> cursor.next:</span><br><span class="line">            <span class="keyword">while</span> cursor.next.next:</span><br><span class="line">                cursor = cursor.next</span><br><span class="line">            cursor.next = <span class="keyword">None</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.root = <span class="keyword">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">top</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        cursor = self.root</span><br><span class="line">        <span class="keyword">while</span> cursor.next:</span><br><span class="line">            cursor = cursor.next</span><br><span class="line">        <span class="keyword">return</span> cursor.data</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getMin</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        cursor = self.root</span><br><span class="line">        minNum = cursor.data</span><br><span class="line">        <span class="keyword">while</span> cursor:</span><br><span class="line">            <span class="keyword">if</span> cursor.data &lt; minNum:</span><br><span class="line">                minNum = cursor.data</span><br><span class="line">            cursor = cursor.next</span><br><span class="line">        <span class="keyword">return</span> minNum</span><br></pre></td></tr></table></figure><p><img src="http://m-markdown-image.oss-cn-beijing.aliyuncs.com/2018-12-08-%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-24%2010.53.58.png" alt=""></p><p>这个是深受前面实现单链表的影响，每个步骤都是“亲力亲为”，而且是将栈底元素视为链表的头，于是每次执行 <code>push</code>、<code>pop</code>、<code>top</code> 方法时，要循环移动到栈顶，<code>getMin</code> 也需要循环整个链表，才能找到最小值，那么这 4 个方法的时间复杂度都是 <code>O(n)</code>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StackNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, data, next)</span>:</span></span><br><span class="line">        self.data = data</span><br><span class="line">        self.next = next</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinStack</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        initialize your data structure here.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        self.root = <span class="keyword">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type x: int</span></span><br><span class="line"><span class="string">        :rtype: void</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> self.root == <span class="keyword">None</span>:</span><br><span class="line">            self.root = StackNode(x, <span class="keyword">None</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            temp = self.root</span><br><span class="line">            self.root = StackNode(x, temp)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :rtype: void</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> self.root.next == <span class="keyword">None</span>:</span><br><span class="line">            self.root = <span class="keyword">None</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.root = self.root.next</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">top</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">return</span> self.root.data</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getMin</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        cursor = self.root</span><br><span class="line">        minNum = cursor.data</span><br><span class="line">        <span class="keyword">while</span> cursor:</span><br><span class="line">            <span class="keyword">if</span> cursor.data &lt; minNum:</span><br><span class="line">                minNum = cursor.data</span><br><span class="line">            cursor = cursor.next</span><br><span class="line">        <span class="keyword">return</span> minNum</span><br></pre></td></tr></table></figure><p>第一次修改时我竟然天真的一位将栈元素视为头就好了，于是有了以上修改，将栈顶元素视为头结点后，发现 <code>push</code>、<code>pop</code>、<code>top</code> 的时间复杂度都降为了<code>O(1)</code>，满足了题目要求，但是<code>getMin</code> 仍然需要遍历一遍，还是不满足要求。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinStack</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        initialize your data structure here.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">self.stack = []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">  :type x: int</span></span><br><span class="line"><span class="string">  :rtype: void</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">preMin = self.stack[<span class="number">-1</span>][<span class="number">1</span>] <span class="keyword">if</span> self.stack <span class="keyword">else</span> <span class="number">2147483647</span></span><br><span class="line">        minNum = min(preMin, x)</span><br><span class="line">        self.stack.append((x, minNum))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">  :rtype: void</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">self.stack.pop()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">top</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">  :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line"><span class="keyword">return</span> self.stack[<span class="number">-1</span>][<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getMin</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">  :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line"><span class="keyword">return</span> self.stack[<span class="number">-1</span>][<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">show</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(self.stack)</span><br></pre></td></tr></table></figure><p>最后不得已在网上看了看实现方法，既然要求时间性能，那就只能牺牲空间性能，于是栈的每个元素其实是一个元祖，第一个元素表示真正的值，第二个表示到当前为止最小的值，那么执行上述方法时候时间复杂度都是<code>O(1)</code>。当然，也可以用另外的一个栈来保存最小值，这里为了方便就直接用一个栈。算法还有改进的空间，例如当最小值重复时不需要存入栈以节省空间，具体实现看下面链接。</p><hr><h3 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h3><ul><li><a href="https://leetcode.com/problems/min-stack/" target="_blank" rel="noopener">题目链接</a></li><li><a href="https://blog.csdn.net/coder_orz/article/details/52047023" target="_blank" rel="noopener">155. Min Stack [easy] (Python)</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> LeetCode日记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 栈 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>【easy】Sqrt(x)</title>
      <link href="/LeetCode-069-Sqrt(x).html"/>
      <url>/LeetCode-069-Sqrt(x).html</url>
      
        <content type="html"><![CDATA[<p>Implement <code>int sqrt(int x)</code>.</p><p>Compute and return the square root of <em>x</em>, where <em>x</em> is guaranteed to be a non-negative integer.</p><p>Since the return type is an integer, the decimal digits are truncated and only the integer part of the result is returned.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: 4</span><br><span class="line">Output: 2</span><br></pre></td></tr></table></figure><a id="more"></a><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: 8</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: The square root of 8 is 2.82842..., and since </span><br><span class="line">             the decimal part is truncated, 2 is returned.</span><br></pre></td></tr></table></figure><hr><h3 id="思路分析："><a href="#思路分析：" class="headerlink" title="思路分析："></a>思路分析：</h3><ul><li>原先想的是从 0 开始挨个儿遍历，然后找到其平方最接近且不超过<code>x</code>的数，但经过前面题目的洗礼，像暴力遍历的方法只能想一想而已，千万别去实现，太蠢了。那么这里就用二分查找吧，而且在网上恰巧看到说一个正数<code>x</code>的平方根不会大于$\frac{1}{2}x+1$，那么初始的左右边界就确定了，下面循环判断就好了，具体见代码。</li></ul><p>[注]：其实网上对这题的思路还有一个什么牛顿迭代法，是一个基于迭代的方法，我不太喜欢，就不去实现了。</p><hr><h3 id="代码实现："><a href="#代码实现：" class="headerlink" title="代码实现："></a>代码实现：</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mySqrt</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type x: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        right = (x // <span class="number">2</span>) + <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> left &lt; right:</span><br><span class="line">            mid = (left + right) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> pow(mid, <span class="number">2</span>) &lt; x:</span><br><span class="line">                left = mid+<span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> pow(mid, <span class="number">2</span>) &gt; x:</span><br><span class="line">                right = mid<span class="number">-1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> mid</span><br><span class="line">        <span class="keyword">if</span> pow(left, <span class="number">2</span>) &gt; x:</span><br><span class="line">            <span class="keyword">return</span> left<span class="number">-1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> left</span><br></pre></td></tr></table></figure><p>循环结束后这里的判断很重要，开始我就是直接返回<code>left</code>的值，发现有些情况没有考虑到。</p><hr><h3 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h3><ul><li><a href="https://leetcode.com/problems/sqrtx/" target="_blank" rel="noopener">题目链接</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> LeetCode日记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 二分查找 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>生成验证码（python）</title>
      <link href="/%E7%94%9F%E6%88%90%E9%AA%8C%E8%AF%81%E7%A0%81%EF%BC%88python%EF%BC%89.html"/>
      <url>/%E7%94%9F%E6%88%90%E9%AA%8C%E8%AF%81%E7%A0%81%EF%BC%88python%EF%BC%89.html</url>
      
        <content type="html"><![CDATA[<p>使用 Python 生成类似于下图中的字母验证码图片：</p><p><img src="http://m-markdown-image.oss-cn-beijing.aliyuncs.com/python%E7%BB%83%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87/aVhbegV.jpg" alt=""></p><p><strong>思路：</strong>这里又要用到前面用到的<code>Pillow</code>库。要实现这个验证码，我觉得应该分下面几步：</p><ol><li>首先要生成这样一个长宽确定的画布</li><li>将随机生成的字母画在画布上</li><li>给画布添加噪点</li><li>最后模糊处理一下</li></ol><a id="more"></a><p>具体代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random, string</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image, ImageFont, ImageColor, ImageDraw, ImageFilter</span><br><span class="line"></span><br><span class="line"><span class="comment">#随机生成字母，包括大小写</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">randChar</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">return</span> random.choice(string.ascii_letters)</span><br><span class="line"><span class="comment">#随机生成颜色</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">randColor_deep</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">return</span> (random.randint(<span class="number">127</span>, <span class="number">255</span>), random.randint(<span class="number">127</span>, <span class="number">255</span>), random.randint(<span class="number">127</span>, <span class="number">255</span>))</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">randColor_low</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">return</span> (random.randint(<span class="number">32</span>, <span class="number">127</span>), random.randint(<span class="number">32</span>, <span class="number">127</span>), random.randint(<span class="number">32</span>, <span class="number">127</span>))</span><br><span class="line"><span class="comment">#生成验证码图片</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">newPic</span><span class="params">()</span>:</span></span><br><span class="line">    width, height = <span class="number">320</span>, <span class="number">80</span></span><br><span class="line">    image = Image.new(<span class="string">'RGB'</span>, (width, height))</span><br><span class="line">    <span class="comment">#创建一个draw对象</span></span><br><span class="line">    draw = ImageDraw.Draw(image)</span><br><span class="line">    <span class="comment">#设置验证码的字体</span></span><br><span class="line">    mFont = ImageFont.truetype(<span class="string">'C:/windows/fonts/Arial.ttf'</span>, size=<span class="number">30</span>)</span><br><span class="line">    <span class="comment">#为图片添加噪点</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(width):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(height):</span><br><span class="line">            draw.point((i, j), randColor_low())</span><br><span class="line">    <span class="comment"># 利用draw对象在画布上写随机生成的字母</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">4</span>):</span><br><span class="line">        draw.text((<span class="number">40</span>+<span class="number">80</span>*i, <span class="number">25</span>), randChar(), randColor_deep(), mFont)</span><br><span class="line">    <span class="comment">#把图片模糊处理</span></span><br><span class="line">    image = image.filter(ImageFilter.BLUR)</span><br><span class="line">    image.show()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    newPic()</span><br></pre></td></tr></table></figure><p>结果：</p><p><img src="http://m-markdown-image.oss-cn-beijing.aliyuncs.com/python%E7%BB%83%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87/1539506842%281%29.jpg" alt=""></p><hr><h4 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h4><ul><li><p><strong>关于随机生成字母和颜色中用到的<code>choice()</code>和<code>randint()</code>方法：</strong></p><p><img src="http://m-markdown-image.oss-cn-beijing.aliyuncs.com/python%E7%BB%83%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87/1539510115%281%29.jpg" alt=""></p><p><img src="http://m-markdown-image.oss-cn-beijing.aliyuncs.com/python%E7%BB%83%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87/1539510149%281%29.jpg" alt=""></p><p><code>choice(seq)</code>是从传入的<code>seq</code>序列中随机选出一个，这里我传入的是<code>string</code>模块下的<code>ascii_letters</code>常量,这个常量是所有英文字母的大小写。<code>randint(a, b)</code>则是会返回一个随机值，该随机值在<code>(a, b)</code>范围内。</p></li><li><p><strong>关于<code>Image</code>类中的<code>new()</code>方法：</strong></p><p><img src="http://m-markdown-image.oss-cn-beijing.aliyuncs.com/python%E7%BB%83%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87/1539510901%281%29.jpg" alt=""></p><p>它有<code>3</code>个参数，前两个<code>mode</code>和<code>size</code>参数是必须的，<code>mode</code>表示生成图片的模型，用的比较多的就<code>RGB</code>和<code>RGBA</code>，后者在前面的基础上加了一个透明度。<code>size</code>是一个tuple元组，表示图片的长宽。第三个<code>color</code>参数可有可无，如果没给，则默认产生黑色的图片。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    width, height = <span class="number">320</span>, <span class="number">80</span></span><br><span class="line">    image = Image.new(<span class="string">'RGB'</span>, (width, height))</span><br><span class="line">    image.show()</span><br></pre></td></tr></table></figure><p><img src="http://m-markdown-image.oss-cn-beijing.aliyuncs.com/python%E7%BB%83%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87/1539567019%281%29.jpg" alt=""></p><p>该方法返回的是一个<code>Image</code>对象，后面<code>ImageDraw.Draw(image)</code>接收的刚好是<code>Image</code>对象。关于这里用到的<code>ImageDraw</code>的<code>Draw()</code>、<code>text()</code>，在前面<code>python练习-1</code>中写了，这里就不多bb了。</p></li><li><p><strong>在图片上如何产生噪点：</strong></p><p>这里我是在图片上的每个像素点都随机涂上较浅的颜色，从上面代码可以看出我是循环遍历像素点的，最后调用<code>ImageDraw</code>对象的<code>point()</code>方法给每个点涂上颜色。</p><p><img src="http://m-markdown-image.oss-cn-beijing.aliyuncs.com/python%E7%BB%83%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87/1539568555%281%29.jpg" alt=""></p><p>看了看网上的方法，发现另一种产生噪点的方式，就是随机选取图片中的像素点涂上颜色：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image, ImageDraw</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">randColor</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">return</span> (random.randint(<span class="number">32</span>, <span class="number">127</span>), random.randint(<span class="number">32</span>, <span class="number">127</span>), random.randint(<span class="number">32</span>, <span class="number">127</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    width, height = <span class="number">320</span>, <span class="number">80</span></span><br><span class="line">    image = Image.new(<span class="string">'RGB'</span>, (width, height))</span><br><span class="line">    draw = ImageDraw.Draw(image)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10000</span>):</span><br><span class="line">        draw.point((random.randint(<span class="number">0</span>, <span class="number">320</span>), random.randint(<span class="number">0</span>, <span class="number">80</span>)), randColor())</span><br><span class="line">    image.show()</span><br></pre></td></tr></table></figure><p><img src="http://m-markdown-image.oss-cn-beijing.aliyuncs.com/python%E7%BB%83%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87/1539569399%281%29.jpg" alt=""></p></li></ul><hr><h4 id="小小的拓展一下："><a href="#小小的拓展一下：" class="headerlink" title="小小的拓展一下："></a>小小的拓展一下：</h4><ul><li>上面产生的是纯字母的验证码，这里要产生字母和数字混合的验证码，放代码：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random, string</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image, ImageDraw, ImageColor, ImageFont, ImageFilter</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">randColor_low</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">return</span> (random.randint(<span class="number">32</span>, <span class="number">127</span>), random.randint(<span class="number">32</span>, <span class="number">127</span>), random.randint(<span class="number">32</span>, <span class="number">127</span>))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">randColor_deep</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">return</span> (random.randint(<span class="number">128</span>, <span class="number">255</span>), random.randint(<span class="number">128</span>, <span class="number">255</span>), random.randint(<span class="number">128</span>, <span class="number">255</span>))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">randChar</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">return</span> random.choice(string.ascii_letters)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">randNum</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">return</span> random.choice(string.digits)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">newPic</span><span class="params">()</span>:</span></span><br><span class="line">    width, height = <span class="number">320</span>, <span class="number">80</span></span><br><span class="line">    image = Image.new(<span class="string">'RGB'</span>, (width, height), randColor_low())</span><br><span class="line">    mFont = ImageFont.truetype(<span class="string">'C:/windows/fonts/Arial.ttf'</span>, size=<span class="number">30</span>)</span><br><span class="line">    draw = ImageDraw.Draw(image)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">4</span>):</span><br><span class="line">        flag = random.randint(<span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">if</span> flag:</span><br><span class="line">            text = randChar()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            text = randNum()</span><br><span class="line">        draw.text((<span class="number">40</span>+<span class="number">80</span>*i, <span class="number">30</span>), text, randColor_deep(), mFont)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10000</span>):</span><br><span class="line">        draw.point((random.randint(<span class="number">0</span>, <span class="number">320</span>), random.randint(<span class="number">0</span>, <span class="number">80</span>)), randColor_low())</span><br><span class="line">    image = image.filter(ImageFilter.BLUR)</span><br><span class="line">    image.show()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    newPic()</span><br></pre></td></tr></table></figure><p><img src="http://m-markdown-image.oss-cn-beijing.aliyuncs.com/python%E7%BB%83%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87/1539572195%281%29.jpg" alt=""></p><p>其实可以继续拓展下去，例如将字符旋转一定角度，但，到此为止吧，stop it</p>]]></content>
      
      
      <categories>
          
          <category> python练习册 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> pillow库 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>【easy】Add Binary</title>
      <link href="/LeetCode-067-Add%20Binary.html"/>
      <url>/LeetCode-067-Add%20Binary.html</url>
      
        <content type="html"><![CDATA[<p>Given two binary strings, return their sum (also a binary string).</p><p>The input strings are both <strong>non-empty</strong> and contains only characters <code>1</code> or <code>0</code>.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: a = &quot;11&quot;, b = &quot;1&quot;</span><br><span class="line">Output: &quot;100&quot;</span><br></pre></td></tr></table></figure><a id="more"></a><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: a = &quot;1010&quot;, b = &quot;1011&quot;</span><br><span class="line">Output: &quot;10101&quot;</span><br></pre></td></tr></table></figure><p>开始做题之前，我们先弄清题目的意思，<code>Binary</code>是啥意思？（偷偷查一下）原来是二进制，那么题目就是要求做二进制的加法。</p><hr><h3 id="思路分析："><a href="#思路分析：" class="headerlink" title="思路分析："></a>思路分析：</h3><ul><li>首先来个讨巧的方式，即用<code>python</code>中的进制转换，直接转换为 10 进制相加，然后返回二进制的结果，虽然能出结果，但我想这不是出题人的目的。</li><li>跟 066 题又很像，即按位相加，外加一个进位标志，具体看代码吧，不多bb。</li></ul><hr><h3 id="代码实现："><a href="#代码实现：" class="headerlink" title="代码实现："></a>代码实现：</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addBinary</span><span class="params">(self, a, b)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type a: str</span></span><br><span class="line"><span class="string">        :type b: str</span></span><br><span class="line"><span class="string">        :rtype: str</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        temp = int(a, <span class="number">2</span>) + int(b, <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> bin(temp)[<span class="number">2</span>:]</span><br></pre></td></tr></table></figure><p>解释下这里为什么要对结果字符串进行切片，是因为<code>bin()</code>函数返回的字符串的前 2 位表示进制，即是<code>0b</code>，所以要去除。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addBinary</span><span class="params">(self, a, b)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type a: str</span></span><br><span class="line"><span class="string">        :type b: str</span></span><br><span class="line"><span class="string">        :rtype: str</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        a = a[::<span class="number">-1</span>]</span><br><span class="line">        b = b[::<span class="number">-1</span>]</span><br><span class="line">        flag, cursor = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        a_len, b_len = len(a), len(b)</span><br><span class="line">        res = <span class="string">''</span></span><br><span class="line">        <span class="keyword">while</span> cursor &lt; max(a_len, b_len) <span class="keyword">or</span> flag:</span><br><span class="line">            a_value = int(a[cursor]) <span class="keyword">if</span> cursor &lt; a_len <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">            b_value = int(b[cursor]) <span class="keyword">if</span> cursor &lt; b_len <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">            temp = a_value + b_value + flag</span><br><span class="line">            <span class="keyword">if</span> temp &lt; <span class="number">2</span>:</span><br><span class="line">                flag = <span class="number">0</span></span><br><span class="line">                res += str(temp)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                flag = <span class="number">1</span></span><br><span class="line">                res += str(temp<span class="number">-2</span>)</span><br><span class="line">            cursor += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res[::<span class="number">-1</span>]</span><br></pre></td></tr></table></figure><p>这里说一下我写的时候踩的坑：</p><ul><li>对字符串使用了<code>reverse()</code>方法，由于上一题给的是列表，倒转列表用到了这个方法，然后我想字符串也是可迭代对象，应该也是可以用这个方法的，结果报错，于是只能倒着切片。</li><li>第 22 行这里我开始是直接加的 0 ，没有考虑到 <code>temp</code>为 3 的情况，考虑问题不够全面啊！</li></ul><hr><h3 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h3><ul><li><p><a href="https://leetcode.com/problems/add-binary/" target="_blank" rel="noopener">题目链接</a></p></li><li><p><a href="https://www.jianshu.com/p/452bd7ce9056" target="_blank" rel="noopener">Python进制快速转换</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> LeetCode日记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 字符串 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>【easy】Climbing Stairs</title>
      <link href="/LeetCode-070-Climbing%20Stairs.html"/>
      <url>/LeetCode-070-Climbing%20Stairs.html</url>
      
        <content type="html"><![CDATA[<p>You are climbing a stair case. It takes <em>n</em> steps to reach to the top.</p><p>Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?</p><p><strong>Note:</strong> Given <em>n</em> will be a positive integer.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: 2</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: There are two ways to climb to the top.</span><br><span class="line">1. 1 step + 1 step</span><br><span class="line">2. 2 steps</span><br></pre></td></tr></table></figure><a id="more"></a><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input: 3</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: There are three ways to climb to the top.</span><br><span class="line">1. 1 step + 1 step + 1 step</span><br><span class="line">2. 1 step + 2 steps</span><br><span class="line">3. 2 steps + 1 step</span><br></pre></td></tr></table></figure><p>记得爬楼梯的问题在我最早开始学数据结构的时候做过，好像那时候没做出来…这里的爬楼梯好像做了一定的简化，即每次只能爬 1 步或 2 步，比较好处理。</p><hr><h3 id="思路分析："><a href="#思路分析：" class="headerlink" title="思路分析："></a>思路分析：</h3><ul><li><p>首先说说我自己的想法，对应代码块 1.1，辅以图说明：</p><p><img src="http://m-markdown-image.oss-cn-beijing.aliyuncs.com/2018-12-10-IMG_3737.JPG" alt=""></p></li><li><p>递归法，可以发现要爬到第 n 阶，必须是从第 n-1 或 n-2 阶上来的，那么递归式就出来了:$f(n) = f(n-1)+f(n-2)$，代码也很简洁，貌似递归的代码都异常简洁，就是效率太差，见代码块 2.1</p></li><li><p>基于动态规划的思想，自底向上进行求解，具体见代码块 3.1</p></li></ul><hr><h3 id="代码实现："><a href="#代码实现：" class="headerlink" title="代码实现："></a>代码实现：</h3><blockquote><p>1.1</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> scipy.special <span class="keyword">import</span> comb</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">climbStairs</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        a = n // <span class="number">2</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, a+<span class="number">1</span>):</span><br><span class="line">            res += comb(i+(n-i*<span class="number">2</span>), i)</span><br><span class="line">        <span class="keyword">return</span> int(res+<span class="number">1</span>)</span><br></pre></td></tr></table></figure><blockquote><p>2.1</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">climbStairs</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> n &lt;= <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> n</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> self.climbStairs(n<span class="number">-1</span>) + self.climbStairs(n<span class="number">-2</span>)</span><br></pre></td></tr></table></figure><p><img src="http://m-markdown-image.oss-cn-beijing.aliyuncs.com/2018-12-10-%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-10%2009.48.18.png" alt=""></p><p>速度实在太慢，算到 35 就已经超时了。其实分析一下递归的求解过程就知道为什么这么慢了：</p><p><img src="http://m-markdown-image.oss-cn-beijing.aliyuncs.com/2018-12-11-IMG_3739.JPG" alt=""></p><p>可以看到有很多重复计算的值，倒置计算效率低下，虽然代码简洁，但并没有什么卵用。</p><blockquote><p>3.1</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">climbStairs</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        f = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">        <span class="keyword">if</span> n &lt;= <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> f[n]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>, n+<span class="number">1</span>):</span><br><span class="line">                f.append(f[i<span class="number">-1</span>]+ f[i<span class="number">-2</span>])</span><br><span class="line">            <span class="keyword">return</span> f[n]</span><br></pre></td></tr></table></figure><p>关于动态规划的思想前面 <a href="https://smileyx.top/leetcode-053-maximum%20subarray">Maximum Subarray</a> 中也用到过。</p><hr><h3 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h3><ul><li><a href="https://leetcode.com/problems/climbing-stairs/" target="_blank" rel="noopener">题目链接</a></li><li><a href="https://blog.csdn.net/lanchunhui/article/details/51824602" target="_blank" rel="noopener">Python 排列组合的计算</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> LeetCode日记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 递归 </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>敏感词替换（python）</title>
      <link href="/%E6%95%8F%E6%84%9F%E8%AF%8D%E6%9B%BF%E6%8D%A2%EF%BC%88python%EF%BC%89.html"/>
      <url>/%E6%95%8F%E6%84%9F%E8%AF%8D%E6%9B%BF%E6%8D%A2%EF%BC%88python%EF%BC%89.html</url>
      
        <content type="html"><![CDATA[<p>敏感词文本文件<code>filtered_words.txt</code>，里面的内容为以下内容，当用户输入敏感词语时，用<code>x</code>替换，例如当用户输入<code>北京是个好城市</code>，则变成<code>xx是个好城市</code>。<img src="http://m-markdown-image.oss-cn-beijing.aliyuncs.com/python%E7%BB%83%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87/1539572786%281%29.jpg" alt=""></p><a id="more"></a><p><strong>思路：</strong>首先读取文件，将敏感词放到一个列表中，然后获取用户输入，遍历敏感词列表，判断敏感词是否在输入的句子中，若有敏感词，则调用<code>str.replace()</code>进行替换，上代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">filterWords</span><span class="params">(filePath)</span>:</span></span><br><span class="line">    wordList = []</span><br><span class="line">    <span class="keyword">with</span> open(filePath) <span class="keyword">as</span> f:</span><br><span class="line">        <span class="keyword">for</span> line <span class="keyword">in</span> f.readlines():</span><br><span class="line">            line = line.rstrip(<span class="string">'\n'</span>)</span><br><span class="line">            <span class="keyword">if</span> line <span class="keyword">not</span> <span class="keyword">in</span> wordList:</span><br><span class="line">                wordList.append(line)</span><br><span class="line">    inputText = input()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(wordList)):</span><br><span class="line">        <span class="keyword">if</span> wordList[i] <span class="keyword">in</span> inputText:</span><br><span class="line">            inputText = inputText.replace(wordList[i], <span class="string">'xx'</span>)</span><br><span class="line">    print(inputText)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    filterWords(<span class="string">'C:/Users/尹鑫/Desktop/test.txt'</span>)</span><br></pre></td></tr></table></figure><p><img src="http://m-markdown-image.oss-cn-beijing.aliyuncs.com/python%E7%BB%83%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87/1539695971%281%29.jpg" alt=""></p><hr><h4 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h4><ul><li><p>新东西不多，大多函数前面几个练习中都用过，这里就写一下新用的<code>str.replace()</code>方法：</p><p><img src="http://m-markdown-image.oss-cn-beijing.aliyuncs.com/python%E7%BB%83%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87/1539696208%281%29.jpg" alt=""></p><p>它就是一个字符串替换方法，参数<code>old</code>表示你要替换的字符串，而<code>new</code>则是你要拿什么替换，很明显，这里我要用<code>xx</code>替换敏感词。</p></li><li><p>关于<code>input()</code>方法：</p><p>在<code>python2</code>中还有<code>input()</code>和<code>raw_input()</code>之分，但在<code>python3</code>中，只有<code>input()</code>方法了，而<code>input()</code>返回的一定是字符串类型<code>str</code>，我这里只用接收一个输入数据，直接用就好了，若需要接收多个数据，则利用<code>str.split()</code>分解一下就好了，简书上已经有人整理好了，直接去看他的。</p></li></ul><hr><h4 id="拓展阅读："><a href="#拓展阅读：" class="headerlink" title="拓展阅读："></a>拓展阅读：</h4><ul><li><a href="https://www.jianshu.com/p/2ebed22d3497" target="_blank" rel="noopener">简书上关于<code>input()</code>的总结</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> python练习册 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 文件读写 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>统计某个目录下txt文件中频率最高的词（python）</title>
      <link href="/%E7%BB%9F%E8%AE%A1%E6%9F%90%E4%B8%AA%E7%9B%AE%E5%BD%95%E4%B8%8Btxt%E6%96%87%E4%BB%B6%E4%B8%AD%E9%A2%91%E7%8E%87%E6%9C%80%E9%AB%98%E7%9A%84%E8%AF%8D%EF%BC%88python%EF%BC%89.html"/>
      <url>/%E7%BB%9F%E8%AE%A1%E6%9F%90%E4%B8%AA%E7%9B%AE%E5%BD%95%E4%B8%8Btxt%E6%96%87%E4%BB%B6%E4%B8%AD%E9%A2%91%E7%8E%87%E6%9C%80%E9%AB%98%E7%9A%84%E8%AF%8D%EF%BC%88python%EF%BC%89.html</url>
      
        <content type="html"><![CDATA[<p>你有一个目录，放了你一个月的日记，都是 txt，为了避免分词的问题，假设内容都是英文，请统计出你认为每篇日记最重要的词。</p><p><strong>思路：</strong>首先遍历该目录下所有的文件，判断是否为<code>.txt</code>格式，如果是则遍历文件内容，利用前面<code>python练习-2</code>中的方法得到出现频次最高的单词（暂定认为出现最多==最重要），最后将数据整理到字典<code>dic</code>中并打印出来。<a id="more"></a>具体代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Counter</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">countWords</span><span class="params">(path)</span>:</span></span><br><span class="line">    resultDic = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> file <span class="keyword">in</span> os.listdir(path):</span><br><span class="line">        <span class="keyword">if</span> os.path.splitext(file)[<span class="number">1</span>] == <span class="string">'.txt'</span>:</span><br><span class="line">            <span class="keyword">with</span> open(path + <span class="string">'/'</span> +file, <span class="string">'r'</span>) <span class="keyword">as</span> singleFile:</span><br><span class="line">                singleFileDic = &#123;&#125;</span><br><span class="line">                <span class="keyword">for</span> line <span class="keyword">in</span> singleFile.readlines():</span><br><span class="line">                    line = re.sub(<span class="string">r'[.?!,""“”/]'</span>, <span class="string">' '</span>, line)</span><br><span class="line">                    <span class="keyword">for</span> word <span class="keyword">in</span> line.lower().split():</span><br><span class="line">                        <span class="keyword">if</span> word <span class="keyword">not</span> <span class="keyword">in</span> singleFileDic:</span><br><span class="line">                            singleFileDic[word] = <span class="number">1</span></span><br><span class="line">                        <span class="keyword">else</span>:</span><br><span class="line">                            singleFileDic[word] += <span class="number">1</span></span><br><span class="line">                importantWord = Counter(singleFileDic).most_common(<span class="number">1</span>)</span><br><span class="line">                resultDic[file] = importantWord[<span class="number">0</span>][<span class="number">0</span>] + <span class="string">'-'</span> + str(importantWord[<span class="number">0</span>][<span class="number">1</span>])</span><br><span class="line">    <span class="keyword">for</span> key,value <span class="keyword">in</span> resultDic.items():</span><br><span class="line">        print(key, value)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    countWords(<span class="string">'C:/Users/尹鑫/Desktop/test'</span>)</span><br></pre></td></tr></table></figure><p>结果：（3个文件竟然都是<code>the</code>最多，，没想到，，，，）</p><p><img src="http://m-markdown-image.oss-cn-beijing.aliyuncs.com/18-10-12/1539312156%281%29.jpg" alt=""></p><hr><h4 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h4><ul><li><p><strong>关于<code>os.listdir(path)</code>函数：</strong></p><p>这个函数的功能很简单，就是返回一个列表，列表的内容就是<code>path</code>路径下所有文件和文件夹的名字，而且文件的名字是带扩展名的，为后面判断扩展名提供了方便。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">countWords</span><span class="params">(path)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> file <span class="keyword">in</span> os.listdir(path):</span><br><span class="line">        print(file)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    countWords(<span class="string">'C:/Users/尹鑫/Desktop/test'</span>)</span><br></pre></td></tr></table></figure><p><img src="http://m-markdown-image.oss-cn-beijing.aliyuncs.com/18-10-12/1539314899%281%29.jpg" alt=""></p></li><li><p><strong>关于<code>os.path.splitext(path)</code>函数：</strong></p><p>官方的解释是这样的，它要传入一个文件的路径，然后返回该文件的文件名和扩展名的元组tuple.<img src="http://m-markdown-image.oss-cn-beijing.aliyuncs.com/18-10-12/1539313951%281%29.jpg" alt=""></p><p>可是我觉得这和文件路径没有半毛钱关系，它好像是根据截取文件名的最后一个<code>.</code>来认定扩展名的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    print(os.path.splitext(<span class="string">'test'</span>))</span><br><span class="line">    print(os.path.splitext(<span class="string">'test.txt'</span>))</span><br><span class="line">    print(os.path.splitext(<span class="string">'test.txt.jpg'</span>))</span><br></pre></td></tr></table></figure><p><img src="http://m-markdown-image.oss-cn-beijing.aliyuncs.com/18-10-12/1539318459%281%29.jpg" alt=""></p></li><li><p>这个题目对比前面练习2的，相当于只增加了读取文件夹，遍历文件夹内的文件，对符合<code>.txt</code>后缀的文件进行读取统计，主要是了解下上面2个函数的功能。</p></li></ul><hr><h4 id="拓展阅读："><a href="#拓展阅读：" class="headerlink" title="拓展阅读："></a>拓展阅读：</h4><ul><li><a href="https://docs.python.org/3/library/os.path.html" target="_blank" rel="noopener">官方对于<code>os.path</code>下方法的解释</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> python练习册 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 文件读写 </tag>
            
            <tag> 正则表达式 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>统计代码行数（python）</title>
      <link href="/%E7%BB%9F%E8%AE%A1%E4%BB%A3%E7%A0%81%E8%A1%8C%E6%95%B0%EF%BC%88python%EF%BC%89.html"/>
      <url>/%E7%BB%9F%E8%AE%A1%E4%BB%A3%E7%A0%81%E8%A1%8C%E6%95%B0%EF%BC%88python%EF%BC%89.html</url>
      
        <content type="html"><![CDATA[<p>有个目录，里面是你自己写过的程序，统计一下你写过多少行代码。包括空行和注释，但是要分别列出来。</p><p><strong>思路：</strong>首先基础肯定是文件读写，然后将每行左边的空格全部删掉，变成每行都是顶头的，方便后面判断该行属于什么（注释、代码还是空行）<a id="more"></a>，上代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">count</span><span class="params">(path)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> file <span class="keyword">in</span> os.listdir(path):</span><br><span class="line">        <span class="keyword">with</span> open(path + <span class="string">'/'</span> + file) <span class="keyword">as</span> f:</span><br><span class="line">            codeLine, blankLine, noteLine, start, end = <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> lineNum, lineText <span class="keyword">in</span> enumerate(f.readlines()):</span><br><span class="line">                <span class="comment"># print(lineNum, lineText)</span></span><br><span class="line">                lineText = lineText.lstrip()</span><br><span class="line">                <span class="comment">#注释方式1：#</span></span><br><span class="line">                <span class="keyword">if</span> lineText[<span class="number">0</span>:<span class="number">1</span>] == <span class="string">'#'</span>:</span><br><span class="line">                    noteLine += <span class="number">1</span></span><br><span class="line">                <span class="comment">#注释方式2：'''</span></span><br><span class="line">                <span class="keyword">elif</span> lineText[<span class="number">0</span>:<span class="number">3</span>] == <span class="string">"'''"</span>:</span><br><span class="line">                    <span class="keyword">if</span> start == <span class="number">0</span>:</span><br><span class="line">                        start = lineNum</span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        end = lineNum</span><br><span class="line">                        noteLine += end - start - <span class="number">1</span></span><br><span class="line">                        start = <span class="number">0</span></span><br><span class="line">                <span class="comment">#注释方式3："""</span></span><br><span class="line">                <span class="keyword">elif</span> lineText[<span class="number">0</span>:<span class="number">3</span>] == <span class="string">'"""'</span>:</span><br><span class="line">                    <span class="keyword">if</span> start == <span class="number">0</span>:</span><br><span class="line">                        start = lineNum</span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        end = lineNum</span><br><span class="line">                        noteLine += end - start - <span class="number">1</span></span><br><span class="line">                        start = <span class="number">0</span></span><br><span class="line">                <span class="comment">#空行</span></span><br><span class="line">                <span class="keyword">elif</span> <span class="keyword">not</span> lineText:</span><br><span class="line">                    blankLine += <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    codeLine += <span class="number">1</span></span><br><span class="line">            print(<span class="string">'在&#123;&#125;中：代码共：&#123;&#125;行，注释共：&#123;&#125;行，空行共：&#123;&#125;行'</span>.</span><br><span class="line">                  format(file, codeLine, noteLine, blankLine))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    count(<span class="string">r'C:/Users/尹鑫/Desktop/test'</span>)</span><br></pre></td></tr></table></figure><p><img src="http://m-markdown-image.oss-cn-beijing.aliyuncs.com/18-10-13/1539433373%281%29.jpg" alt=""></p><p>测试用的<code>test1.py</code>和<code>test2.py</code>内容是一样的，仅在<code>test2.py</code>中加了:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">yx测试</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure><p>所以结果明显正确！hah</p><hr><h4 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h4><ul><li><p><strong>关于上面用到的<code>enumerate()</code>函数：</strong></p><p>首先看看官方爸爸是怎么说的：</p><p><img src="http://m-markdown-image.oss-cn-beijing.aliyuncs.com/18-10-13/1539433827%281%29.jpg" alt=""> </p></li><li><p><strong>关于字符串处理函数<code>lstrip()</code>、<code>strip()</code>、<code>rstrip()</code>:</strong></p><p>官方说法：</p><p><img src="http://m-markdown-image.oss-cn-beijing.aliyuncs.com/18-10-13/1.jpg" alt=""></p><p><img src="http://m-markdown-image.oss-cn-beijing.aliyuncs.com/18-10-13/2.jpg" alt=""></p><p><img src="http://m-markdown-image.oss-cn-beijing.aliyuncs.com/18-10-13/3.jpg" alt=""></p><p>这<code>3</code>个函数的功能都是一样的，只不过作用的位置不一样。就拿<code>strip([chars])</code>来说，它是去掉字符串首尾的特定字符，具体哪些字符，由参数<code>chars</code>给出，如果没有传<code>chars</code>参数，则默认去掉空格（这里就用它去掉空格）</p></li><li><p><strong>如何在字符串中嵌入<code>&#39;</code>和<code>&quot;</code>：</strong></p><p>这里我需要判断每行是否有<code>&#39;&#39;&#39;</code>或<code>&quot;&quot;&quot;</code>，进而判断改行是不是注释语句，而直接这样：<code>&#39;&#39;&#39;&#39;&#39;</code>或<code>&quot;&quot;&quot;&quot;&quot;</code>是不行的。在网上看了看，解决这个问题的方法大致有2种。第一种就是用<code>\</code>来表示转义，那么代码就变成了：<code>&#39;\&#39;\&#39;\&#39;&#39;</code>，看着很不舒服。第二种就是这里用到的方法：用双引号把单引号包起来和用单引号把双引号包起来。于是以后这样的句子就很好表示了：<code>&quot;I&#39;m yx&quot;</code>，<code>&#39;she said &quot;Hello World&quot;&#39;</code></p></li><li><p><strong>如何判断空行：</strong></p><p>原来我是想通过<code>if lineText[0:1] == &#39;/n&#39;</code>来判断是否是空行，但发现并不行，在网上找了找，发现直接<code>if lineText</code>就好了，如果是空行，返回<code>False</code>，不是空行，则返回<code>True</code></p></li><li><p><strong>字符串的格式化函数<code>format()</code>：</strong></p><p>官方好像说的不是人话，反正现在我还看不懂，不过也贴出来吧：</p><p><img src="http://m-markdown-image.oss-cn-beijing.aliyuncs.com/18-10-13/1539486087%281%29.jpg" alt=""></p><p>在原来写c的时候，每次<code>print</code>都要用<code>%d、%s.....</code>来占位，反人类的操作。<code>python2.6</code>以后就有了<code>format()</code>函数，可以统一用<code>{}</code>来占位，用起来会上瘾。例子我直接搬个网上的，很好理解。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;<span class="string">"&#123;&#125; &#123;&#125;"</span>.format(<span class="string">"hello"</span>, <span class="string">"world"</span>)    <span class="comment"># 不设置指定位置，按默认顺序</span></span><br><span class="line"><span class="string">'hello world'</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">"&#123;0&#125; &#123;1&#125;"</span>.format(<span class="string">"hello"</span>, <span class="string">"world"</span>)  <span class="comment"># 设置指定位置</span></span><br><span class="line"><span class="string">'hello world'</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">"&#123;1&#125; &#123;0&#125; &#123;1&#125;"</span>.format(<span class="string">"hello"</span>, <span class="string">"world"</span>)  <span class="comment"># 设置指定位置</span></span><br><span class="line"><span class="string">'world hello world'</span></span><br></pre></td></tr></table></figure></li><li><p>这里我是用<code>lineText[0:3]</code>分片来判断该行的性质，其实也可以用字符串的<code>startswith()</code>函数，看起来应该会友好点。例如<code>lineText.startwith(&#39;&quot;&quot;&quot;&#39;)</code>来判断是否是注释行。</p></li></ul><hr><h4 id="拓展阅读："><a href="#拓展阅读：" class="headerlink" title="拓展阅读："></a>拓展阅读：</h4><ul><li><a href="https://docs.python.org/3/library/functions.html" target="_blank" rel="noopener"><code>Python3</code>内建函数表（官方）</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> python练习册 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 文件读写 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>统计英文纯文本单词频率（python）</title>
      <link href="/%E7%BB%9F%E8%AE%A1%E8%8B%B1%E6%96%87%E7%BA%AF%E6%96%87%E6%9C%AC%E5%8D%95%E8%AF%8D%E9%A2%91%E7%8E%87%EF%BC%88python%EF%BC%89.html"/>
      <url>/%E7%BB%9F%E8%AE%A1%E8%8B%B1%E6%96%87%E7%BA%AF%E6%96%87%E6%9C%AC%E5%8D%95%E8%AF%8D%E9%A2%91%E7%8E%87%EF%BC%88python%EF%BC%89.html</url>
      
        <content type="html"><![CDATA[<p><strong>思路：</strong>要统计单词的词频，首先要打开文件，读取其中的内容，然后通过正则表达式处理一下，排除符号的干扰，剩下的就是单词，最后将单词加入字典并统计次数。<a id="more"></a>下面上具体代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Counter</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">countFromFile</span><span class="params">(filePath)</span>:</span></span><br><span class="line">    dic = &#123;&#125;</span><br><span class="line">    <span class="keyword">with</span> open(filePath, <span class="string">'r'</span>) <span class="keyword">as</span> f:</span><br><span class="line">        <span class="keyword">for</span> line <span class="keyword">in</span> f.readlines():</span><br><span class="line">            txt = re.sub(<span class="string">r'[.?!,""/]'</span>, <span class="string">' '</span>, line)</span><br><span class="line">            <span class="keyword">for</span> word <span class="keyword">in</span> txt.lower().split():</span><br><span class="line">                <span class="keyword">if</span> word <span class="keyword">in</span> dic:</span><br><span class="line">                    dic[word] += <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dic[word] = <span class="number">1</span></span><br><span class="line">                    </span><br><span class="line">    <span class="keyword">for</span> word, count <span class="keyword">in</span> Counter(dic).most_common(<span class="number">5</span>):</span><br><span class="line">        print(word, count)</span><br><span class="line">    print(<span class="string">'----------------------'</span>)</span><br><span class="line">    <span class="keyword">for</span> word, count <span class="keyword">in</span> dic.items():</span><br><span class="line">        print(word, count)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    countFromFile(<span class="string">'C:/Users/尹鑫/Desktop/test.txt'</span>)</span><br></pre></td></tr></table></figure><p>效果图：</p><p><img src="http://m-markdown-image.oss-cn-beijing.aliyuncs.com/18-10-10/69281632.jpg" alt=""></p><hr><h4 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h4><ul><li><strong>关于文件读写：</strong><br>这里的写法是最常用的，在<code>with</code>语句中随便对文件操作，而不需要关心文件关闭的问题，会自动帮我们调用<code>f.close()</code>方法。然后就是文件的读，<code>read()</code>和<code>readlines()</code>会一次性读取文件的全部内容，区别是前者是将整个文件当作字符串处理，后者会返回一个list，每个元素就是一行。而<code>readline()</code>则是每次只会读取一行的内容，适用于内存小而文件巨大的情况（反正现在没碰到过，暂且不管），并且它的速度也很慢，一般都不会用它的。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">countFromFile</span><span class="params">(filePath)</span>:</span></span><br><span class="line">    <span class="keyword">with</span> open(filePath, <span class="string">'r'</span>) <span class="keyword">as</span> f:</span><br><span class="line">        print(<span class="string">'read()返回的类型：'</span>, type(f.read()))</span><br><span class="line">        print(<span class="string">'readlines()返回的类型：'</span>, type(f.readlines()))</span><br><span class="line">        print(<span class="string">'readline()返回的类型：'</span>, type(f.readline()))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    countFromFile(<span class="string">'C:/Users/尹鑫/Desktop/test.txt'</span>)</span><br></pre></td></tr></table></figure><p><img src="http://m-markdown-image.oss-cn-beijing.aliyuncs.com/18-10-11/65223050.jpg" alt="">        </p><ul><li><p><strong>关于<code>re</code>模块:</strong><br>在python中<code>re</code>模块是用来处理正则表达式的。由于在正则表达式中用<code>\</code>转义，python中也用<code>\</code>来转义，所以为了保护视力，一般用<code>r</code>前缀的字符串表达形式，如<code>s = r&#39;aBc\-6&#39;</code>，<code>r</code>后面引号内就是字符串的内容，不用考虑转义的问题了。这里用到的<code>re.sub()</code>，官方是这样说的：<br><img src="http://m-markdown-image.oss-cn-beijing.aliyuncs.com/18-10-11/31817055.jpg" alt=""></p><p>简单理解一下就是用<code>pattern</code>对象来匹配<code>string</code>，将匹配成功的部分用<code>repl</code>替换。这里就是用空格来替换<code>[.?!,&quot;&quot;/]</code>这些在英文中可能出现的符号。</p></li><li><p><strong>关于<code>Counter</code>对象:</strong></p><p>看看官方是怎么说的:</p><p><img src="http://m-markdown-image.oss-cn-beijing.aliyuncs.com/18-10-11/66.jpg" alt=""></p><p>它是dict的子类，可以对字典里的数据做一些统计操作，例如这里用到的<code>most_common(n)</code>方法：</p><p><img src="http://m-markdown-image.oss-cn-beijing.aliyuncs.com/18-10-11/1539246393%281%29.jpg" alt=""></p><p>它返回频次最高的n组数据</p></li></ul><hr><h4 id="小小拓展一下："><a href="#小小拓展一下：" class="headerlink" title="小小拓展一下："></a>小小拓展一下：</h4><ul><li><p><strong>在上面的基础上，考虑单词通过<code>-</code>换行的情况，修改代码如下：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Counter</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">countFromFile</span><span class="params">(filePath)</span>:</span></span><br><span class="line">    dic = &#123;&#125;</span><br><span class="line">    <span class="keyword">with</span> open(filePath, <span class="string">'r'</span>) <span class="keyword">as</span> f:</span><br><span class="line">        flag = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> line <span class="keyword">in</span> f.readlines():</span><br><span class="line">            txt = re.sub(<span class="string">r'[.?!,""/]'</span>, <span class="string">' '</span>, line)</span><br><span class="line">            <span class="keyword">for</span> word <span class="keyword">in</span> txt.lower().split():</span><br><span class="line">                <span class="keyword">if</span> word[<span class="number">-1</span>] == <span class="string">'-'</span>:</span><br><span class="line">                    halfWord = word[:<span class="number">-1</span>]</span><br><span class="line">                    flag = <span class="number">1</span></span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                <span class="keyword">if</span> flag == <span class="number">1</span>:</span><br><span class="line">                    word = halfWord + word</span><br><span class="line">                    flag = <span class="number">0</span></span><br><span class="line">                <span class="keyword">if</span> word <span class="keyword">in</span> dic:</span><br><span class="line">                    dic[word] += <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dic[word] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> word, count <span class="keyword">in</span> Counter(dic).most_common(<span class="number">5</span>):</span><br><span class="line">        print(word, count)</span><br><span class="line">    print(<span class="string">'----------------------'</span>)</span><br><span class="line">    <span class="keyword">for</span> word, count <span class="keyword">in</span> dic.items():</span><br><span class="line">        print(word, count)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    countFromFile(<span class="string">'C:/Users/尹鑫/Desktop/test.txt'</span>)</span><br></pre></td></tr></table></figure><p>在<code>test.txt</code>文件中，故意将<code>restricted</code>和<code>China</code>通过<code>-</code>连在一起，看是否能正确合并为一个单词：</p><p><img src="http://m-markdown-image.oss-cn-beijing.aliyuncs.com/18-10-11/1539252673%281%29.jpg" alt=""></p><p>结果正确！</p><p><img src="http://m-markdown-image.oss-cn-beijing.aliyuncs.com/18-10-11/1539252711%281%29.jpg" alt=""></p></li><li><p><strong>上面统计的单词，这里统计字母的频次，修改代码如下：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Counter</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">countFromFile</span><span class="params">(filePath)</span>:</span></span><br><span class="line">    dic = &#123;&#125;</span><br><span class="line">    notCount = <span class="string">r'[],./?!’“”-'</span></span><br><span class="line">    <span class="keyword">with</span> open(filePath, <span class="string">'r'</span>) <span class="keyword">as</span> f:</span><br><span class="line">        <span class="keyword">for</span> line <span class="keyword">in</span> f.readlines():</span><br><span class="line">            txt = line.lower().split()</span><br><span class="line">            <span class="keyword">for</span> word <span class="keyword">in</span> txt:</span><br><span class="line">                <span class="keyword">for</span> alph <span class="keyword">in</span> word:</span><br><span class="line">                    <span class="keyword">if</span> alph <span class="keyword">not</span> <span class="keyword">in</span> notCount:</span><br><span class="line">                        <span class="keyword">if</span> alph <span class="keyword">in</span> dic:</span><br><span class="line">                            dic[alph] += <span class="number">1</span></span><br><span class="line">                        <span class="keyword">else</span>:</span><br><span class="line">                            dic[alph] = <span class="number">1</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">for</span> key,value <span class="keyword">in</span> Counter(dic).most_common(<span class="number">5</span>):</span><br><span class="line">        print(key, value)</span><br><span class="line">    print(<span class="string">'--------------------'</span>)</span><br><span class="line">    <span class="keyword">for</span> key,value <span class="keyword">in</span> dic.items():</span><br><span class="line">        print(key, value)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    countFromFile(<span class="string">'C:/Users/尹鑫/Desktop/test.txt'</span>)</span><br></pre></td></tr></table></figure><p>这里没有用正则表达式，而是定义了可能出现符号的字符串，最后判断<code>not in</code>就好。结果如下：</p><p><img src="http://m-markdown-image.oss-cn-beijing.aliyuncs.com/18-10-11/1539256524%281%29.jpg" alt=""></p></li></ul><hr><h4 id="拓展阅读："><a href="#拓展阅读：" class="headerlink" title="拓展阅读："></a>拓展阅读：</h4><ul><li><a href="https://mp.weixin.qq.com/s/Md07VoaULda7qnMO4ob7Ww" target="_blank" rel="noopener">给Python学习者的文件读写指南</a></li><li><a href="http://wiki.jikexueyuan.com/project/explore-python/Regular-Expressions/re.html" target="_blank" rel="noopener">re模块-极客学院</a></li><li><a href="https://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/00143193331387014ccd1040c814dee8b2164bb4f064cff000" target="_blank" rel="noopener">正则表达式-廖雪峰</a></li><li><a href="https://docs.python.org/2/library/collections.html#collections.Counter" target="_blank" rel="noopener">Collections:Counter 官方文档</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> python练习册 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 文件读写 </tag>
            
            <tag> 正则表达式 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>【easy】Length of Last Word</title>
      <link href="/LeetCode-058-Length%20of%20Last%20Word.html"/>
      <url>/LeetCode-058-Length%20of%20Last%20Word.html</url>
      
        <content type="html"><![CDATA[<p>Given a string <em>s</em> consists of upper/lower-case alphabets and empty space characters <code>&#39; &#39;</code>, return the length of last word in the string.</p><p>If the last word does not exist, return 0.</p><p><strong>Note:</strong> A word is defined as a character sequence consists of non-space characters only.</p><p><strong>Example:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;Hello World&quot;</span><br><span class="line">Output: 5</span><br></pre></td></tr></table></figure><p>乍一看很简单，也确实简单，只不过给的栗子只有一个标准情况，而我考虑问题又不全面，所以并没有一次提交成功，注意如果是<code>&quot;a &quot;</code>，应该返回 1 而不是 0，<code>&quot;a  b  &quot;</code>也是返回 1 ，注意到这些情况后就不难了。</p><a id="more"></a><hr><h3 id="代码实现："><a href="#代码实现：" class="headerlink" title="代码实现："></a>代码实现：</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lengthOfLastWord</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        s = s.rstrip()</span><br><span class="line">        <span class="keyword">if</span> s:</span><br><span class="line">            wordList = s.split(<span class="string">' '</span>)</span><br><span class="line">            print(wordList)</span><br><span class="line">            <span class="keyword">return</span> len(wordList[<span class="number">-1</span>]) <span class="keyword">if</span> wordList[<span class="number">-1</span>] <span class="keyword">else</span> len(wordList[<span class="number">-2</span>])</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br></pre></td></tr></table></figure><hr><h3 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h3><ul><li><a href="https://leetcode.com/problems/length-of-last-word/" target="_blank" rel="noopener">题目链接</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> LeetCode日记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 字符串 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>【easy】Plus One</title>
      <link href="/LeetCode-066-Plus%20One.html"/>
      <url>/LeetCode-066-Plus%20One.html</url>
      
        <content type="html"><![CDATA[<p>Given a <strong>non-empty</strong> array of digits representing a non-negative integer, plus one to the integer.</p><p>The digits are stored such that the most significant digit is at the head of the list, and each element in the array contain a single digit.</p><p>You may assume the integer does not contain any leading zero, except the number 0 itself.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,2,3]</span><br><span class="line">Output: [1,2,4]</span><br><span class="line">Explanation: The array represents the integer 123.</span><br></pre></td></tr></table></figure><a id="more"></a><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [4,3,2,1]</span><br><span class="line">Output: [4,3,2,2]</span><br><span class="line">Explanation: The array represents the integer 4321.</span><br></pre></td></tr></table></figure><p>前面做过类似的题，难度比这大，可以看下面贴的链接，共写了 2 种实现，思路前面写过就不写了，这里就直接贴代码，相当于前面的一次回顾吧，温故而知新嘛。</p><hr><h3 id="代码实现："><a href="#代码实现：" class="headerlink" title="代码实现："></a>代码实现：</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">plusOne</span><span class="params">(self, digits)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type digits: List[int]</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        tempStr = <span class="string">''</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> value <span class="keyword">in</span> digits:</span><br><span class="line">            tempStr += str(value)</span><br><span class="line">        tempNum = int(tempStr) + <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> value <span class="keyword">in</span> str(tempNum):</span><br><span class="line">            res.append(int(value))</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p>这个是转换成字符串处理，总感觉有点无脑，我更喜欢下面的进位方法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">plusOne</span><span class="params">(self, digits)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type digits: List[int]</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        flag = <span class="number">1</span></span><br><span class="line">        digits.reverse()</span><br><span class="line">        <span class="keyword">for</span> item <span class="keyword">in</span> enumerate(digits):</span><br><span class="line">            <span class="keyword">if</span> item[<span class="number">1</span>]+flag == <span class="number">10</span>:</span><br><span class="line">                flag = <span class="number">1</span></span><br><span class="line">                digits[item[<span class="number">0</span>]] = <span class="number">0</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                digits[item[<span class="number">0</span>]]+=<span class="number">1</span></span><br><span class="line">                flag = <span class="number">0</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">if</span> digits[<span class="number">-1</span>] == <span class="number">0</span>:</span><br><span class="line">            digits.append(<span class="number">1</span>)</span><br><span class="line">        digits.reverse()</span><br><span class="line">        <span class="keyword">return</span> digits</span><br></pre></td></tr></table></figure><p>这里的进位其实很简单，因为只加 1 ，那么一旦进位不为 1 的话，就可以直接退出了，不会新产生进位了。</p><hr><h3 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h3><ul><li><a href="https://leetcode.com/problems/plus-one/" target="_blank" rel="noopener">题目链接</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> LeetCode日记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 字符串 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>写在诞生之初</title>
      <link href="/%E5%86%99%E5%9C%A8%E8%AF%9E%E7%94%9F%E4%B9%8B%E5%88%9D.html"/>
      <url>/%E5%86%99%E5%9C%A8%E8%AF%9E%E7%94%9F%E4%B9%8B%E5%88%9D.html</url>
      
        <content type="html"><![CDATA[<p>其实半年前我就搭过一个博客，开始建的时候激情满满，结果仍旧是3分钟热度，更了几篇就停下了，总是觉得我写的东西太低端，网上一搜一大堆，写这些东西浪费时间。但最近时不时在网上看见一些优秀的博客，其作者也是跟我差不多年龄，而且最开始写的很基础的人大有人在，可以清晰的看到他们的成长轨迹。我突然觉得这样也挺好的，回首能清楚的看到自己学了什么，干了什么，不至于每到年末，都不知道今年到底做了什么。</p><a id="more"></a><p>于是我又开始搜博客搭建方案（和半年前一样），原来采取的是<code>Hexo + github pages</code>，但最近看到了用<code>Netlify</code>来部署博客的，心想总要做点改变吧，嗯，就用<code>Hexo + Netlify</code>！选主题的时候着实又纠结了一把，我这个人对视觉体验有种莫名的执着，于是对主题的美感要求就比较高，好不容易在众多主题中找到了一个<a href="https://github.com/ahonn/hexo-theme-even" target="_blank" rel="noopener"><code>even</code></a>主题，配色很是喜欢，但无奈作者就是没有添加站内搜索功能（个人觉得这个功能非常重要），我自己来定制吧，可惜没那个能力，只好还是选择烂大街的<code>next</code>主题，暂时先这样吧，最近会把笔记迁移到这里来，最后，希望自己这次能把博客持续的更新下去！</p><p><img src="http://m-markdown-image.oss-cn-beijing.aliyuncs.com/2018-12-06-0fc951db7b786ace3b418a36ac2dde14.jpg" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 瞎bb而已 </category>
          
      </categories>
      
      
    </entry>
    
  
  
</search>
